var Rw = Object.defineProperty; var Ow = (t, e, n) => e in t ? Rw(t, e, { enumerable: !0, configurable: !0, writable: !0, value: n }) : t[e] = n; var nn = (t, e, n) => Ow(t, typeof e != "symbol" ? e + "" : e, n); function Bm(t, e) { for (var n = 0; n < e.length; n++) { const r = e[n]; if (typeof r != "string" && !Array.isArray(r)) { for (const i in r) if (i !== "default" && !(i in t)) { const s = Object.getOwnPropertyDescriptor(r, i); s && Object.defineProperty(t, i, s.get ? s : { enumerable: !0, get: () => r[i] }) } } } return Object.freeze(Object.defineProperty(t, Symbol.toStringTag, { value: "Module" })) } (function () { const e = document.createElement("link").relList; if (e && e.supports && e.supports("modulepreload")) return; for (const i of document.querySelectorAll('link[rel="modulepreload"]')) r(i); new MutationObserver(i => { for (const s of i) if (s.type === "childList") for (const o of s.addedNodes) o.tagName === "LINK" && o.rel === "modulepreload" && r(o) }).observe(document, { childList: !0, subtree: !0 }); function n(i) { const s = {}; return i.integrity && (s.integrity = i.integrity), i.referrerPolicy && (s.referrerPolicy = i.referrerPolicy), i.crossOrigin === "use-credentials" ? s.credentials = "include" : i.crossOrigin === "anonymous" ? s.credentials = "omit" : s.credentials = "same-origin", s } function r(i) { if (i.ep) return; i.ep = !0; const s = n(i); fetch(i.href, s) } })(); function io(t) { return t && t.__esModule && Object.prototype.hasOwnProperty.call(t, "default") ? t.default : t } var Hm = { exports: {} }, ml = {}, Vm = { exports: {} }, te = {};/**
 * @license React
 * react.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */var so = Symbol.for("react.element"), jw = Symbol.for("react.portal"), Aw = Symbol.for("react.fragment"), Lw = Symbol.for("react.strict_mode"), Dw = Symbol.for("react.profiler"), Mw = Symbol.for("react.provider"), Fw = Symbol.for("react.context"), Uw = Symbol.for("react.forward_ref"), zw = Symbol.for("react.suspense"), $w = Symbol.for("react.memo"), Bw = Symbol.for("react.lazy"), sp = Symbol.iterator; function Hw(t) { return t === null || typeof t != "object" ? null : (t = sp && t[sp] || t["@@iterator"], typeof t == "function" ? t : null) } var Wm = { isMounted: function () { return !1 }, enqueueForceUpdate: function () { }, enqueueReplaceState: function () { }, enqueueSetState: function () { } }, Gm = Object.assign, Km = {}; function Bi(t, e, n) { this.props = t, this.context = e, this.refs = Km, this.updater = n || Wm } Bi.prototype.isReactComponent = {}; Bi.prototype.setState = function (t, e) { if (typeof t != "object" && typeof t != "function" && t != null) throw Error("setState(...): takes an object of state variables to update or a function which returns an object of state variables."); this.updater.enqueueSetState(this, t, e, "setState") }; Bi.prototype.forceUpdate = function (t) { this.updater.enqueueForceUpdate(this, t, "forceUpdate") }; function qm() { } qm.prototype = Bi.prototype; function bd(t, e, n) { this.props = t, this.context = e, this.refs = Km, this.updater = n || Wm } var Td = bd.prototype = new qm; Td.constructor = bd; Gm(Td, Bi.prototype); Td.isPureReactComponent = !0; var op = Array.isArray, Ym = Object.prototype.hasOwnProperty, Cd = { current: null }, Jm = { key: !0, ref: !0, __self: !0, __source: !0 }; function Xm(t, e, n) { var r, i = {}, s = null, o = null; if (e != null) for (r in e.ref !== void 0 && (o = e.ref), e.key !== void 0 && (s = "" + e.key), e) Ym.call(e, r) && !Jm.hasOwnProperty(r) && (i[r] = e[r]); var l = arguments.length - 2; if (l === 1) i.children = n; else if (1 < l) { for (var a = Array(l), c = 0; c < l; c++)a[c] = arguments[c + 2]; i.children = a } if (t && t.defaultProps) for (r in l = t.defaultProps, l) i[r] === void 0 && (i[r] = l[r]); return { $$typeof: so, type: t, key: s, ref: o, props: i, _owner: Cd.current } } function Vw(t, e) { return { $$typeof: so, type: t.type, key: e, ref: t.ref, props: t.props, _owner: t._owner } } function _d(t) { return typeof t == "object" && t !== null && t.$$typeof === so } function Ww(t) { var e = { "=": "=0", ":": "=2" }; return "$" + t.replace(/[=:]/g, function (n) { return e[n] }) } var ap = /\/+/g; function Ql(t, e) { return typeof t == "object" && t !== null && t.key != null ? Ww("" + t.key) : e.toString(36) } function Qo(t, e, n, r, i) { var s = typeof t; (s === "undefined" || s === "boolean") && (t = null); var o = !1; if (t === null) o = !0; else switch (s) { case "string": case "number": o = !0; break; case "object": switch (t.$$typeof) { case so: case jw: o = !0 } }if (o) return o = t, i = i(o), t = r === "" ? "." + Ql(o, 0) : r, op(i) ? (n = "", t != null && (n = t.replace(ap, "$&/") + "/"), Qo(i, e, n, "", function (c) { return c })) : i != null && (_d(i) && (i = Vw(i, n + (!i.key || o && o.key === i.key ? "" : ("" + i.key).replace(ap, "$&/") + "/") + t)), e.push(i)), 1; if (o = 0, r = r === "" ? "." : r + ":", op(t)) for (var l = 0; l < t.length; l++) { s = t[l]; var a = r + Ql(s, l); o += Qo(s, e, n, a, i) } else if (a = Hw(t), typeof a == "function") for (t = a.call(t), l = 0; !(s = t.next()).done;)s = s.value, a = r + Ql(s, l++), o += Qo(s, e, n, a, i); else if (s === "object") throw e = String(t), Error("Objects are not valid as a React child (found: " + (e === "[object Object]" ? "object with keys {" + Object.keys(t).join(", ") + "}" : e) + "). If you meant to render a collection of children, use an array instead."); return o } function Io(t, e, n) { if (t == null) return t; var r = [], i = 0; return Qo(t, r, "", "", function (s) { return e.call(n, s, i++) }), r } function Gw(t) { if (t._status === -1) { var e = t._result; e = e(), e.then(function (n) { (t._status === 0 || t._status === -1) && (t._status = 1, t._result = n) }, function (n) { (t._status === 0 || t._status === -1) && (t._status = 2, t._result = n) }), t._status === -1 && (t._status = 0, t._result = e) } if (t._status === 1) return t._result.default; throw t._result } var et = { current: null }, Zo = { transition: null }, Kw = { ReactCurrentDispatcher: et, ReactCurrentBatchConfig: Zo, ReactCurrentOwner: Cd }; function Qm() { throw Error("act(...) is not supported in production builds of React.") } te.Children = { map: Io, forEach: function (t, e, n) { Io(t, function () { e.apply(this, arguments) }, n) }, count: function (t) { var e = 0; return Io(t, function () { e++ }), e }, toArray: function (t) { return Io(t, function (e) { return e }) || [] }, only: function (t) { if (!_d(t)) throw Error("React.Children.only expected to receive a single React element child."); return t } }; te.Component = Bi; te.Fragment = Aw; te.Profiler = Dw; te.PureComponent = bd; te.StrictMode = Lw; te.Suspense = zw; te.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = Kw; te.act = Qm; te.cloneElement = function (t, e, n) { if (t == null) throw Error("React.cloneElement(...): The argument must be a React element, but you passed " + t + "."); var r = Gm({}, t.props), i = t.key, s = t.ref, o = t._owner; if (e != null) { if (e.ref !== void 0 && (s = e.ref, o = Cd.current), e.key !== void 0 && (i = "" + e.key), t.type && t.type.defaultProps) var l = t.type.defaultProps; for (a in e) Ym.call(e, a) && !Jm.hasOwnProperty(a) && (r[a] = e[a] === void 0 && l !== void 0 ? l[a] : e[a]) } var a = arguments.length - 2; if (a === 1) r.children = n; else if (1 < a) { l = Array(a); for (var c = 0; c < a; c++)l[c] = arguments[c + 2]; r.children = l } return { $$typeof: so, type: t.type, key: i, ref: s, props: r, _owner: o } }; te.createContext = function (t) { return t = { $$typeof: Fw, _currentValue: t, _currentValue2: t, _threadCount: 0, Provider: null, Consumer: null, _defaultValue: null, _globalName: null }, t.Provider = { $$typeof: Mw, _context: t }, t.Consumer = t }; te.createElement = Xm; te.createFactory = function (t) { var e = Xm.bind(null, t); return e.type = t, e }; te.createRef = function () { return { current: null } }; te.forwardRef = function (t) { return { $$typeof: Uw, render: t } }; te.isValidElement = _d; te.lazy = function (t) { return { $$typeof: Bw, _payload: { _status: -1, _result: t }, _init: Gw } }; te.memo = function (t, e) { return { $$typeof: $w, type: t, compare: e === void 0 ? null : e } }; te.startTransition = function (t) { var e = Zo.transition; Zo.transition = {}; try { t() } finally { Zo.transition = e } }; te.unstable_act = Qm; te.useCallback = function (t, e) { return et.current.useCallback(t, e) }; te.useContext = function (t) { return et.current.useContext(t) }; te.useDebugValue = function () { }; te.useDeferredValue = function (t) { return et.current.useDeferredValue(t) }; te.useEffect = function (t, e) { return et.current.useEffect(t, e) }; te.useId = function () { return et.current.useId() }; te.useImperativeHandle = function (t, e, n) { return et.current.useImperativeHandle(t, e, n) }; te.useInsertionEffect = function (t, e) { return et.current.useInsertionEffect(t, e) }; te.useLayoutEffect = function (t, e) { return et.current.useLayoutEffect(t, e) }; te.useMemo = function (t, e) { return et.current.useMemo(t, e) }; te.useReducer = function (t, e, n) { return et.current.useReducer(t, e, n) }; te.useRef = function (t) { return et.current.useRef(t) }; te.useState = function (t) { return et.current.useState(t) }; te.useSyncExternalStore = function (t, e, n) { return et.current.useSyncExternalStore(t, e, n) }; te.useTransition = function () { return et.current.useTransition() }; te.version = "18.3.1"; Vm.exports = te; var b = Vm.exports; const ce = io(b), qw = Bm({ __proto__: null, default: ce }, [b]);/**
 * @license React
 * react-jsx-runtime.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */var Yw = b, Jw = Symbol.for("react.element"), Xw = Symbol.for("react.fragment"), Qw = Object.prototype.hasOwnProperty, Zw = Yw.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner, e1 = { key: !0, ref: !0, __self: !0, __source: !0 }; function Zm(t, e, n) { var r, i = {}, s = null, o = null; n !== void 0 && (s = "" + n), e.key !== void 0 && (s = "" + e.key), e.ref !== void 0 && (o = e.ref); for (r in e) Qw.call(e, r) && !e1.hasOwnProperty(r) && (i[r] = e[r]); if (t && t.defaultProps) for (r in e = t.defaultProps, e) i[r] === void 0 && (i[r] = e[r]); return { $$typeof: Jw, type: t, key: s, ref: o, props: i, _owner: Zw.current } } ml.Fragment = Xw; ml.jsx = Zm; ml.jsxs = Zm; Hm.exports = ml; var d = Hm.exports, Ta = {}, eg = { exports: {} }, vt = {}, tg = { exports: {} }, ng = {};/**
 * @license React
 * scheduler.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */(function (t) { function e(A, U) { var z = A.length; A.push(U); e: for (; 0 < z;) { var Z = z - 1 >>> 1, le = A[Z]; if (0 < i(le, U)) A[Z] = U, A[z] = le, z = Z; else break e } } function n(A) { return A.length === 0 ? null : A[0] } function r(A) { if (A.length === 0) return null; var U = A[0], z = A.pop(); if (z !== U) { A[0] = z; e: for (var Z = 0, le = A.length, Bt = le >>> 1; Z < Bt;) { var Me = 2 * (Z + 1) - 1, kt = A[Me], qe = Me + 1, Zt = A[qe]; if (0 > i(kt, z)) qe < le && 0 > i(Zt, kt) ? (A[Z] = Zt, A[qe] = z, Z = qe) : (A[Z] = kt, A[Me] = z, Z = Me); else if (qe < le && 0 > i(Zt, z)) A[Z] = Zt, A[qe] = z, Z = qe; else break e } } return U } function i(A, U) { var z = A.sortIndex - U.sortIndex; return z !== 0 ? z : A.id - U.id } if (typeof performance == "object" && typeof performance.now == "function") { var s = performance; t.unstable_now = function () { return s.now() } } else { var o = Date, l = o.now(); t.unstable_now = function () { return o.now() - l } } var a = [], c = [], u = 1, f = null, h = 3, y = !1, g = !1, w = !1, E = typeof setTimeout == "function" ? setTimeout : null, v = typeof clearTimeout == "function" ? clearTimeout : null, p = typeof setImmediate < "u" ? setImmediate : null; typeof navigator < "u" && navigator.scheduling !== void 0 && navigator.scheduling.isInputPending !== void 0 && navigator.scheduling.isInputPending.bind(navigator.scheduling); function m(A) { for (var U = n(c); U !== null;) { if (U.callback === null) r(c); else if (U.startTime <= A) r(c), U.sortIndex = U.expirationTime, e(a, U); else break; U = n(c) } } function S(A) { if (w = !1, m(A), !g) if (n(a) !== null) g = !0, de(T); else { var U = n(c); U !== null && pe(S, U.startTime - A) } } function T(A, U) { g = !1, w && (w = !1, v(I), I = -1), y = !0; var z = h; try { for (m(U), f = n(a); f !== null && (!(f.expirationTime > U) || A && !j());) { var Z = f.callback; if (typeof Z == "function") { f.callback = null, h = f.priorityLevel; var le = Z(f.expirationTime <= U); U = t.unstable_now(), typeof le == "function" ? f.callback = le : f === n(a) && r(a), m(U) } else r(a); f = n(a) } if (f !== null) var Bt = !0; else { var Me = n(c); Me !== null && pe(S, Me.startTime - U), Bt = !1 } return Bt } finally { f = null, h = z, y = !1 } } var x = !1, P = null, I = -1, N = 5, k = -1; function j() { return !(t.unstable_now() - k < N) } function F() { if (P !== null) { var A = t.unstable_now(); k = A; var U = !0; try { U = P(!0, A) } finally { U ? D() : (x = !1, P = null) } } else x = !1 } var D; if (typeof p == "function") D = function () { p(F) }; else if (typeof MessageChannel < "u") { var B = new MessageChannel, J = B.port2; B.port1.onmessage = F, D = function () { J.postMessage(null) } } else D = function () { E(F, 0) }; function de(A) { P = A, x || (x = !0, D()) } function pe(A, U) { I = E(function () { A(t.unstable_now()) }, U) } t.unstable_IdlePriority = 5, t.unstable_ImmediatePriority = 1, t.unstable_LowPriority = 4, t.unstable_NormalPriority = 3, t.unstable_Profiling = null, t.unstable_UserBlockingPriority = 2, t.unstable_cancelCallback = function (A) { A.callback = null }, t.unstable_continueExecution = function () { g || y || (g = !0, de(T)) }, t.unstable_forceFrameRate = function (A) { 0 > A || 125 < A ? console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported") : N = 0 < A ? Math.floor(1e3 / A) : 5 }, t.unstable_getCurrentPriorityLevel = function () { return h }, t.unstable_getFirstCallbackNode = function () { return n(a) }, t.unstable_next = function (A) { switch (h) { case 1: case 2: case 3: var U = 3; break; default: U = h }var z = h; h = U; try { return A() } finally { h = z } }, t.unstable_pauseExecution = function () { }, t.unstable_requestPaint = function () { }, t.unstable_runWithPriority = function (A, U) { switch (A) { case 1: case 2: case 3: case 4: case 5: break; default: A = 3 }var z = h; h = A; try { return U() } finally { h = z } }, t.unstable_scheduleCallback = function (A, U, z) { var Z = t.unstable_now(); switch (typeof z == "object" && z !== null ? (z = z.delay, z = typeof z == "number" && 0 < z ? Z + z : Z) : z = Z, A) { case 1: var le = -1; break; case 2: le = 250; break; case 5: le = 1073741823; break; case 4: le = 1e4; break; default: le = 5e3 }return le = z + le, A = { id: u++, callback: U, priorityLevel: A, startTime: z, expirationTime: le, sortIndex: -1 }, z > Z ? (A.sortIndex = z, e(c, A), n(a) === null && A === n(c) && (w ? (v(I), I = -1) : w = !0, pe(S, z - Z))) : (A.sortIndex = le, e(a, A), g || y || (g = !0, de(T))), A }, t.unstable_shouldYield = j, t.unstable_wrapCallback = function (A) { var U = h; return function () { var z = h; h = U; try { return A.apply(this, arguments) } finally { h = z } } } })(ng); tg.exports = ng; var t1 = tg.exports;/**
 * @license React
 * react-dom.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */var n1 = b, gt = t1; function M(t) { for (var e = "https://reactjs.org/docs/error-decoder.html?invariant=" + t, n = 1; n < arguments.length; n++)e += "&args[]=" + encodeURIComponent(arguments[n]); return "Minified React error #" + t + "; visit " + e + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings." } var rg = new Set, Ds = {}; function Wr(t, e) { Ni(t, e), Ni(t + "Capture", e) } function Ni(t, e) { for (Ds[t] = e, t = 0; t < e.length; t++)rg.add(e[t]) } var yn = !(typeof window > "u" || typeof window.document > "u" || typeof window.document.createElement > "u"), Xc = Object.prototype.hasOwnProperty, r1 = /^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/, lp = {}, cp = {}; function i1(t) { return Xc.call(cp, t) ? !0 : Xc.call(lp, t) ? !1 : r1.test(t) ? cp[t] = !0 : (lp[t] = !0, !1) } function s1(t, e, n, r) { if (n !== null && n.type === 0) return !1; switch (typeof e) { case "function": case "symbol": return !0; case "boolean": return r ? !1 : n !== null ? !n.acceptsBooleans : (t = t.toLowerCase().slice(0, 5), t !== "data-" && t !== "aria-"); default: return !1 } } function o1(t, e, n, r) { if (e === null || typeof e > "u" || s1(t, e, n, r)) return !0; if (r) return !1; if (n !== null) switch (n.type) { case 3: return !e; case 4: return e === !1; case 5: return isNaN(e); case 6: return isNaN(e) || 1 > e }return !1 } function tt(t, e, n, r, i, s, o) { this.acceptsBooleans = e === 2 || e === 3 || e === 4, this.attributeName = r, this.attributeNamespace = i, this.mustUseProperty = n, this.propertyName = t, this.type = e, this.sanitizeURL = s, this.removeEmptyString = o } var Be = {}; "children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style".split(" ").forEach(function (t) { Be[t] = new tt(t, 0, !1, t, null, !1, !1) });[["acceptCharset", "accept-charset"], ["className", "class"], ["htmlFor", "for"], ["httpEquiv", "http-equiv"]].forEach(function (t) { var e = t[0]; Be[e] = new tt(e, 1, !1, t[1], null, !1, !1) });["contentEditable", "draggable", "spellCheck", "value"].forEach(function (t) { Be[t] = new tt(t, 2, !1, t.toLowerCase(), null, !1, !1) });["autoReverse", "externalResourcesRequired", "focusable", "preserveAlpha"].forEach(function (t) { Be[t] = new tt(t, 2, !1, t, null, !1, !1) }); "allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture disableRemotePlayback formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope".split(" ").forEach(function (t) { Be[t] = new tt(t, 3, !1, t.toLowerCase(), null, !1, !1) });["checked", "multiple", "muted", "selected"].forEach(function (t) { Be[t] = new tt(t, 3, !0, t, null, !1, !1) });["capture", "download"].forEach(function (t) { Be[t] = new tt(t, 4, !1, t, null, !1, !1) });["cols", "rows", "size", "span"].forEach(function (t) { Be[t] = new tt(t, 6, !1, t, null, !1, !1) });["rowSpan", "start"].forEach(function (t) { Be[t] = new tt(t, 5, !1, t.toLowerCase(), null, !1, !1) }); var Pd = /[\-:]([a-z])/g; function Id(t) { return t[1].toUpperCase() } "accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height".split(" ").forEach(function (t) { var e = t.replace(Pd, Id); Be[e] = new tt(e, 1, !1, t, null, !1, !1) }); "xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type".split(" ").forEach(function (t) { var e = t.replace(Pd, Id); Be[e] = new tt(e, 1, !1, t, "http://www.w3.org/1999/xlink", !1, !1) });["xml:base", "xml:lang", "xml:space"].forEach(function (t) { var e = t.replace(Pd, Id); Be[e] = new tt(e, 1, !1, t, "http://www.w3.org/XML/1998/namespace", !1, !1) });["tabIndex", "crossOrigin"].forEach(function (t) { Be[t] = new tt(t, 1, !1, t.toLowerCase(), null, !1, !1) }); Be.xlinkHref = new tt("xlinkHref", 1, !1, "xlink:href", "http://www.w3.org/1999/xlink", !0, !1);["src", "href", "action", "formAction"].forEach(function (t) { Be[t] = new tt(t, 1, !1, t.toLowerCase(), null, !0, !0) }); function kd(t, e, n, r) { var i = Be.hasOwnProperty(e) ? Be[e] : null; (i !== null ? i.type !== 0 : r || !(2 < e.length) || e[0] !== "o" && e[0] !== "O" || e[1] !== "n" && e[1] !== "N") && (o1(e, n, i, r) && (n = null), r || i === null ? i1(e) && (n === null ? t.removeAttribute(e) : t.setAttribute(e, "" + n)) : i.mustUseProperty ? t[i.propertyName] = n === null ? i.type === 3 ? !1 : "" : n : (e = i.attributeName, r = i.attributeNamespace, n === null ? t.removeAttribute(e) : (i = i.type, n = i === 3 || i === 4 && n === !0 ? "" : "" + n, r ? t.setAttributeNS(r, e, n) : t.setAttribute(e, n)))) } var _n = n1.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED, ko = Symbol.for("react.element"), si = Symbol.for("react.portal"), oi = Symbol.for("react.fragment"), Nd = Symbol.for("react.strict_mode"), Qc = Symbol.for("react.profiler"), ig = Symbol.for("react.provider"), sg = Symbol.for("react.context"), Rd = Symbol.for("react.forward_ref"), Zc = Symbol.for("react.suspense"), eu = Symbol.for("react.suspense_list"), Od = Symbol.for("react.memo"), Dn = Symbol.for("react.lazy"), og = Symbol.for("react.offscreen"), up = Symbol.iterator; function Zi(t) { return t === null || typeof t != "object" ? null : (t = up && t[up] || t["@@iterator"], typeof t == "function" ? t : null) } var Te = Object.assign, Zl; function ms(t) {
  if (Zl === void 0) try { throw Error() } catch (n) { var e = n.stack.trim().match(/\n( *(at )?)/); Zl = e && e[1] || "" } return `
`+ Zl + t
} var ec = !1; function tc(t, e) {
  if (!t || ec) return ""; ec = !0; var n = Error.prepareStackTrace; Error.prepareStackTrace = void 0; try { if (e) if (e = function () { throw Error() }, Object.defineProperty(e.prototype, "props", { set: function () { throw Error() } }), typeof Reflect == "object" && Reflect.construct) { try { Reflect.construct(e, []) } catch (c) { var r = c } Reflect.construct(t, [], e) } else { try { e.call() } catch (c) { r = c } t.call(e.prototype) } else { try { throw Error() } catch (c) { r = c } t() } } catch (c) {
    if (c && r && typeof c.stack == "string") {
      for (var i = c.stack.split(`
`), s = r.stack.split(`
`), o = i.length - 1, l = s.length - 1; 1 <= o && 0 <= l && i[o] !== s[l];)l--; for (; 1 <= o && 0 <= l; o--, l--)if (i[o] !== s[l]) {
        if (o !== 1 || l !== 1) do if (o--, l--, 0 > l || i[o] !== s[l]) {
          var a = `
`+ i[o].replace(" at new ", " at "); return t.displayName && a.includes("<anonymous>") && (a = a.replace("<anonymous>", t.displayName)), a
        } while (1 <= o && 0 <= l); break
      }
    }
  } finally { ec = !1, Error.prepareStackTrace = n } return (t = t ? t.displayName || t.name : "") ? ms(t) : ""
} function a1(t) { switch (t.tag) { case 5: return ms(t.type); case 16: return ms("Lazy"); case 13: return ms("Suspense"); case 19: return ms("SuspenseList"); case 0: case 2: case 15: return t = tc(t.type, !1), t; case 11: return t = tc(t.type.render, !1), t; case 1: return t = tc(t.type, !0), t; default: return "" } } function tu(t) { if (t == null) return null; if (typeof t == "function") return t.displayName || t.name || null; if (typeof t == "string") return t; switch (t) { case oi: return "Fragment"; case si: return "Portal"; case Qc: return "Profiler"; case Nd: return "StrictMode"; case Zc: return "Suspense"; case eu: return "SuspenseList" }if (typeof t == "object") switch (t.$$typeof) { case sg: return (t.displayName || "Context") + ".Consumer"; case ig: return (t._context.displayName || "Context") + ".Provider"; case Rd: var e = t.render; return t = t.displayName, t || (t = e.displayName || e.name || "", t = t !== "" ? "ForwardRef(" + t + ")" : "ForwardRef"), t; case Od: return e = t.displayName || null, e !== null ? e : tu(t.type) || "Memo"; case Dn: e = t._payload, t = t._init; try { return tu(t(e)) } catch { } }return null } function l1(t) { var e = t.type; switch (t.tag) { case 24: return "Cache"; case 9: return (e.displayName || "Context") + ".Consumer"; case 10: return (e._context.displayName || "Context") + ".Provider"; case 18: return "DehydratedFragment"; case 11: return t = e.render, t = t.displayName || t.name || "", e.displayName || (t !== "" ? "ForwardRef(" + t + ")" : "ForwardRef"); case 7: return "Fragment"; case 5: return e; case 4: return "Portal"; case 3: return "Root"; case 6: return "Text"; case 16: return tu(e); case 8: return e === Nd ? "StrictMode" : "Mode"; case 22: return "Offscreen"; case 12: return "Profiler"; case 21: return "Scope"; case 13: return "Suspense"; case 19: return "SuspenseList"; case 25: return "TracingMarker"; case 1: case 0: case 17: case 2: case 14: case 15: if (typeof e == "function") return e.displayName || e.name || null; if (typeof e == "string") return e }return null } function sr(t) { switch (typeof t) { case "boolean": case "number": case "string": case "undefined": return t; case "object": return t; default: return "" } } function ag(t) { var e = t.type; return (t = t.nodeName) && t.toLowerCase() === "input" && (e === "checkbox" || e === "radio") } function c1(t) { var e = ag(t) ? "checked" : "value", n = Object.getOwnPropertyDescriptor(t.constructor.prototype, e), r = "" + t[e]; if (!t.hasOwnProperty(e) && typeof n < "u" && typeof n.get == "function" && typeof n.set == "function") { var i = n.get, s = n.set; return Object.defineProperty(t, e, { configurable: !0, get: function () { return i.call(this) }, set: function (o) { r = "" + o, s.call(this, o) } }), Object.defineProperty(t, e, { enumerable: n.enumerable }), { getValue: function () { return r }, setValue: function (o) { r = "" + o }, stopTracking: function () { t._valueTracker = null, delete t[e] } } } } function No(t) { t._valueTracker || (t._valueTracker = c1(t)) } function lg(t) { if (!t) return !1; var e = t._valueTracker; if (!e) return !0; var n = e.getValue(), r = ""; return t && (r = ag(t) ? t.checked ? "true" : "false" : t.value), t = r, t !== n ? (e.setValue(t), !0) : !1 } function Ca(t) { if (t = t || (typeof document < "u" ? document : void 0), typeof t > "u") return null; try { return t.activeElement || t.body } catch { return t.body } } function nu(t, e) { var n = e.checked; return Te({}, e, { defaultChecked: void 0, defaultValue: void 0, value: void 0, checked: n ?? t._wrapperState.initialChecked }) } function dp(t, e) { var n = e.defaultValue == null ? "" : e.defaultValue, r = e.checked != null ? e.checked : e.defaultChecked; n = sr(e.value != null ? e.value : n), t._wrapperState = { initialChecked: r, initialValue: n, controlled: e.type === "checkbox" || e.type === "radio" ? e.checked != null : e.value != null } } function cg(t, e) { e = e.checked, e != null && kd(t, "checked", e, !1) } function ru(t, e) { cg(t, e); var n = sr(e.value), r = e.type; if (n != null) r === "number" ? (n === 0 && t.value === "" || t.value != n) && (t.value = "" + n) : t.value !== "" + n && (t.value = "" + n); else if (r === "submit" || r === "reset") { t.removeAttribute("value"); return } e.hasOwnProperty("value") ? iu(t, e.type, n) : e.hasOwnProperty("defaultValue") && iu(t, e.type, sr(e.defaultValue)), e.checked == null && e.defaultChecked != null && (t.defaultChecked = !!e.defaultChecked) } function fp(t, e, n) { if (e.hasOwnProperty("value") || e.hasOwnProperty("defaultValue")) { var r = e.type; if (!(r !== "submit" && r !== "reset" || e.value !== void 0 && e.value !== null)) return; e = "" + t._wrapperState.initialValue, n || e === t.value || (t.value = e), t.defaultValue = e } n = t.name, n !== "" && (t.name = ""), t.defaultChecked = !!t._wrapperState.initialChecked, n !== "" && (t.name = n) } function iu(t, e, n) { (e !== "number" || Ca(t.ownerDocument) !== t) && (n == null ? t.defaultValue = "" + t._wrapperState.initialValue : t.defaultValue !== "" + n && (t.defaultValue = "" + n)) } var gs = Array.isArray; function vi(t, e, n, r) { if (t = t.options, e) { e = {}; for (var i = 0; i < n.length; i++)e["$" + n[i]] = !0; for (n = 0; n < t.length; n++)i = e.hasOwnProperty("$" + t[n].value), t[n].selected !== i && (t[n].selected = i), i && r && (t[n].defaultSelected = !0) } else { for (n = "" + sr(n), e = null, i = 0; i < t.length; i++) { if (t[i].value === n) { t[i].selected = !0, r && (t[i].defaultSelected = !0); return } e !== null || t[i].disabled || (e = t[i]) } e !== null && (e.selected = !0) } } function su(t, e) { if (e.dangerouslySetInnerHTML != null) throw Error(M(91)); return Te({}, e, { value: void 0, defaultValue: void 0, children: "" + t._wrapperState.initialValue }) } function pp(t, e) { var n = e.value; if (n == null) { if (n = e.children, e = e.defaultValue, n != null) { if (e != null) throw Error(M(92)); if (gs(n)) { if (1 < n.length) throw Error(M(93)); n = n[0] } e = n } e == null && (e = ""), n = e } t._wrapperState = { initialValue: sr(n) } } function ug(t, e) { var n = sr(e.value), r = sr(e.defaultValue); n != null && (n = "" + n, n !== t.value && (t.value = n), e.defaultValue == null && t.defaultValue !== n && (t.defaultValue = n)), r != null && (t.defaultValue = "" + r) } function hp(t) { var e = t.textContent; e === t._wrapperState.initialValue && e !== "" && e !== null && (t.value = e) } function dg(t) { switch (t) { case "svg": return "http://www.w3.org/2000/svg"; case "math": return "http://www.w3.org/1998/Math/MathML"; default: return "http://www.w3.org/1999/xhtml" } } function ou(t, e) { return t == null || t === "http://www.w3.org/1999/xhtml" ? dg(e) : t === "http://www.w3.org/2000/svg" && e === "foreignObject" ? "http://www.w3.org/1999/xhtml" : t } var Ro, fg = function (t) { return typeof MSApp < "u" && MSApp.execUnsafeLocalFunction ? function (e, n, r, i) { MSApp.execUnsafeLocalFunction(function () { return t(e, n, r, i) }) } : t }(function (t, e) { if (t.namespaceURI !== "http://www.w3.org/2000/svg" || "innerHTML" in t) t.innerHTML = e; else { for (Ro = Ro || document.createElement("div"), Ro.innerHTML = "<svg>" + e.valueOf().toString() + "</svg>", e = Ro.firstChild; t.firstChild;)t.removeChild(t.firstChild); for (; e.firstChild;)t.appendChild(e.firstChild) } }); function Ms(t, e) { if (e) { var n = t.firstChild; if (n && n === t.lastChild && n.nodeType === 3) { n.nodeValue = e; return } } t.textContent = e } var bs = { animationIterationCount: !0, aspectRatio: !0, borderImageOutset: !0, borderImageSlice: !0, borderImageWidth: !0, boxFlex: !0, boxFlexGroup: !0, boxOrdinalGroup: !0, columnCount: !0, columns: !0, flex: !0, flexGrow: !0, flexPositive: !0, flexShrink: !0, flexNegative: !0, flexOrder: !0, gridArea: !0, gridRow: !0, gridRowEnd: !0, gridRowSpan: !0, gridRowStart: !0, gridColumn: !0, gridColumnEnd: !0, gridColumnSpan: !0, gridColumnStart: !0, fontWeight: !0, lineClamp: !0, lineHeight: !0, opacity: !0, order: !0, orphans: !0, tabSize: !0, widows: !0, zIndex: !0, zoom: !0, fillOpacity: !0, floodOpacity: !0, stopOpacity: !0, strokeDasharray: !0, strokeDashoffset: !0, strokeMiterlimit: !0, strokeOpacity: !0, strokeWidth: !0 }, u1 = ["Webkit", "ms", "Moz", "O"]; Object.keys(bs).forEach(function (t) { u1.forEach(function (e) { e = e + t.charAt(0).toUpperCase() + t.substring(1), bs[e] = bs[t] }) }); function pg(t, e, n) { return e == null || typeof e == "boolean" || e === "" ? "" : n || typeof e != "number" || e === 0 || bs.hasOwnProperty(t) && bs[t] ? ("" + e).trim() : e + "px" } function hg(t, e) { t = t.style; for (var n in e) if (e.hasOwnProperty(n)) { var r = n.indexOf("--") === 0, i = pg(n, e[n], r); n === "float" && (n = "cssFloat"), r ? t.setProperty(n, i) : t[n] = i } } var d1 = Te({ menuitem: !0 }, { area: !0, base: !0, br: !0, col: !0, embed: !0, hr: !0, img: !0, input: !0, keygen: !0, link: !0, meta: !0, param: !0, source: !0, track: !0, wbr: !0 }); function au(t, e) { if (e) { if (d1[t] && (e.children != null || e.dangerouslySetInnerHTML != null)) throw Error(M(137, t)); if (e.dangerouslySetInnerHTML != null) { if (e.children != null) throw Error(M(60)); if (typeof e.dangerouslySetInnerHTML != "object" || !("__html" in e.dangerouslySetInnerHTML)) throw Error(M(61)) } if (e.style != null && typeof e.style != "object") throw Error(M(62)) } } function lu(t, e) { if (t.indexOf("-") === -1) return typeof e.is == "string"; switch (t) { case "annotation-xml": case "color-profile": case "font-face": case "font-face-src": case "font-face-uri": case "font-face-format": case "font-face-name": case "missing-glyph": return !1; default: return !0 } } var cu = null; function jd(t) { return t = t.target || t.srcElement || window, t.correspondingUseElement && (t = t.correspondingUseElement), t.nodeType === 3 ? t.parentNode : t } var uu = null, yi = null, wi = null; function mp(t) { if (t = lo(t)) { if (typeof uu != "function") throw Error(M(280)); var e = t.stateNode; e && (e = xl(e), uu(t.stateNode, t.type, e)) } } function mg(t) { yi ? wi ? wi.push(t) : wi = [t] : yi = t } function gg() { if (yi) { var t = yi, e = wi; if (wi = yi = null, mp(t), e) for (t = 0; t < e.length; t++)mp(e[t]) } } function vg(t, e) { return t(e) } function yg() { } var nc = !1; function wg(t, e, n) { if (nc) return t(e, n); nc = !0; try { return vg(t, e, n) } finally { nc = !1, (yi !== null || wi !== null) && (yg(), gg()) } } function Fs(t, e) { var n = t.stateNode; if (n === null) return null; var r = xl(n); if (r === null) return null; n = r[e]; e: switch (e) { case "onClick": case "onClickCapture": case "onDoubleClick": case "onDoubleClickCapture": case "onMouseDown": case "onMouseDownCapture": case "onMouseMove": case "onMouseMoveCapture": case "onMouseUp": case "onMouseUpCapture": case "onMouseEnter": (r = !r.disabled) || (t = t.type, r = !(t === "button" || t === "input" || t === "select" || t === "textarea")), t = !r; break e; default: t = !1 }if (t) return null; if (n && typeof n != "function") throw Error(M(231, e, typeof n)); return n } var du = !1; if (yn) try { var es = {}; Object.defineProperty(es, "passive", { get: function () { du = !0 } }), window.addEventListener("test", es, es), window.removeEventListener("test", es, es) } catch { du = !1 } function f1(t, e, n, r, i, s, o, l, a) { var c = Array.prototype.slice.call(arguments, 3); try { e.apply(n, c) } catch (u) { this.onError(u) } } var Ts = !1, _a = null, Pa = !1, fu = null, p1 = { onError: function (t) { Ts = !0, _a = t } }; function h1(t, e, n, r, i, s, o, l, a) { Ts = !1, _a = null, f1.apply(p1, arguments) } function m1(t, e, n, r, i, s, o, l, a) { if (h1.apply(this, arguments), Ts) { if (Ts) { var c = _a; Ts = !1, _a = null } else throw Error(M(198)); Pa || (Pa = !0, fu = c) } } function Gr(t) { var e = t, n = t; if (t.alternate) for (; e.return;)e = e.return; else { t = e; do e = t, e.flags & 4098 && (n = e.return), t = e.return; while (t) } return e.tag === 3 ? n : null } function xg(t) { if (t.tag === 13) { var e = t.memoizedState; if (e === null && (t = t.alternate, t !== null && (e = t.memoizedState)), e !== null) return e.dehydrated } return null } function gp(t) { if (Gr(t) !== t) throw Error(M(188)) } function g1(t) { var e = t.alternate; if (!e) { if (e = Gr(t), e === null) throw Error(M(188)); return e !== t ? null : t } for (var n = t, r = e; ;) { var i = n.return; if (i === null) break; var s = i.alternate; if (s === null) { if (r = i.return, r !== null) { n = r; continue } break } if (i.child === s.child) { for (s = i.child; s;) { if (s === n) return gp(i), t; if (s === r) return gp(i), e; s = s.sibling } throw Error(M(188)) } if (n.return !== r.return) n = i, r = s; else { for (var o = !1, l = i.child; l;) { if (l === n) { o = !0, n = i, r = s; break } if (l === r) { o = !0, r = i, n = s; break } l = l.sibling } if (!o) { for (l = s.child; l;) { if (l === n) { o = !0, n = s, r = i; break } if (l === r) { o = !0, r = s, n = i; break } l = l.sibling } if (!o) throw Error(M(189)) } } if (n.alternate !== r) throw Error(M(190)) } if (n.tag !== 3) throw Error(M(188)); return n.stateNode.current === n ? t : e } function Sg(t) { return t = g1(t), t !== null ? Eg(t) : null } function Eg(t) { if (t.tag === 5 || t.tag === 6) return t; for (t = t.child; t !== null;) { var e = Eg(t); if (e !== null) return e; t = t.sibling } return null } var bg = gt.unstable_scheduleCallback, vp = gt.unstable_cancelCallback, v1 = gt.unstable_shouldYield, y1 = gt.unstable_requestPaint, Ie = gt.unstable_now, w1 = gt.unstable_getCurrentPriorityLevel, Ad = gt.unstable_ImmediatePriority, Tg = gt.unstable_UserBlockingPriority, Ia = gt.unstable_NormalPriority, x1 = gt.unstable_LowPriority, Cg = gt.unstable_IdlePriority, gl = null, Yt = null; function S1(t) { if (Yt && typeof Yt.onCommitFiberRoot == "function") try { Yt.onCommitFiberRoot(gl, t, void 0, (t.current.flags & 128) === 128) } catch { } } var Mt = Math.clz32 ? Math.clz32 : T1, E1 = Math.log, b1 = Math.LN2; function T1(t) { return t >>>= 0, t === 0 ? 32 : 31 - (E1(t) / b1 | 0) | 0 } var Oo = 64, jo = 4194304; function vs(t) { switch (t & -t) { case 1: return 1; case 2: return 2; case 4: return 4; case 8: return 8; case 16: return 16; case 32: return 32; case 64: case 128: case 256: case 512: case 1024: case 2048: case 4096: case 8192: case 16384: case 32768: case 65536: case 131072: case 262144: case 524288: case 1048576: case 2097152: return t & 4194240; case 4194304: case 8388608: case 16777216: case 33554432: case 67108864: return t & 130023424; case 134217728: return 134217728; case 268435456: return 268435456; case 536870912: return 536870912; case 1073741824: return 1073741824; default: return t } } function ka(t, e) { var n = t.pendingLanes; if (n === 0) return 0; var r = 0, i = t.suspendedLanes, s = t.pingedLanes, o = n & 268435455; if (o !== 0) { var l = o & ~i; l !== 0 ? r = vs(l) : (s &= o, s !== 0 && (r = vs(s))) } else o = n & ~i, o !== 0 ? r = vs(o) : s !== 0 && (r = vs(s)); if (r === 0) return 0; if (e !== 0 && e !== r && !(e & i) && (i = r & -r, s = e & -e, i >= s || i === 16 && (s & 4194240) !== 0)) return e; if (r & 4 && (r |= n & 16), e = t.entangledLanes, e !== 0) for (t = t.entanglements, e &= r; 0 < e;)n = 31 - Mt(e), i = 1 << n, r |= t[n], e &= ~i; return r } function C1(t, e) { switch (t) { case 1: case 2: case 4: return e + 250; case 8: case 16: case 32: case 64: case 128: case 256: case 512: case 1024: case 2048: case 4096: case 8192: case 16384: case 32768: case 65536: case 131072: case 262144: case 524288: case 1048576: case 2097152: return e + 5e3; case 4194304: case 8388608: case 16777216: case 33554432: case 67108864: return -1; case 134217728: case 268435456: case 536870912: case 1073741824: return -1; default: return -1 } } function _1(t, e) { for (var n = t.suspendedLanes, r = t.pingedLanes, i = t.expirationTimes, s = t.pendingLanes; 0 < s;) { var o = 31 - Mt(s), l = 1 << o, a = i[o]; a === -1 ? (!(l & n) || l & r) && (i[o] = C1(l, e)) : a <= e && (t.expiredLanes |= l), s &= ~l } } function pu(t) { return t = t.pendingLanes & -1073741825, t !== 0 ? t : t & 1073741824 ? 1073741824 : 0 } function _g() { var t = Oo; return Oo <<= 1, !(Oo & 4194240) && (Oo = 64), t } function rc(t) { for (var e = [], n = 0; 31 > n; n++)e.push(t); return e } function oo(t, e, n) { t.pendingLanes |= e, e !== 536870912 && (t.suspendedLanes = 0, t.pingedLanes = 0), t = t.eventTimes, e = 31 - Mt(e), t[e] = n } function P1(t, e) { var n = t.pendingLanes & ~e; t.pendingLanes = e, t.suspendedLanes = 0, t.pingedLanes = 0, t.expiredLanes &= e, t.mutableReadLanes &= e, t.entangledLanes &= e, e = t.entanglements; var r = t.eventTimes; for (t = t.expirationTimes; 0 < n;) { var i = 31 - Mt(n), s = 1 << i; e[i] = 0, r[i] = -1, t[i] = -1, n &= ~s } } function Ld(t, e) { var n = t.entangledLanes |= e; for (t = t.entanglements; n;) { var r = 31 - Mt(n), i = 1 << r; i & e | t[r] & e && (t[r] |= e), n &= ~i } } var ue = 0; function Pg(t) { return t &= -t, 1 < t ? 4 < t ? t & 268435455 ? 16 : 536870912 : 4 : 1 } var Ig, Dd, kg, Ng, Rg, hu = !1, Ao = [], Yn = null, Jn = null, Xn = null, Us = new Map, zs = new Map, Un = [], I1 = "mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset submit".split(" "); function yp(t, e) { switch (t) { case "focusin": case "focusout": Yn = null; break; case "dragenter": case "dragleave": Jn = null; break; case "mouseover": case "mouseout": Xn = null; break; case "pointerover": case "pointerout": Us.delete(e.pointerId); break; case "gotpointercapture": case "lostpointercapture": zs.delete(e.pointerId) } } function ts(t, e, n, r, i, s) { return t === null || t.nativeEvent !== s ? (t = { blockedOn: e, domEventName: n, eventSystemFlags: r, nativeEvent: s, targetContainers: [i] }, e !== null && (e = lo(e), e !== null && Dd(e)), t) : (t.eventSystemFlags |= r, e = t.targetContainers, i !== null && e.indexOf(i) === -1 && e.push(i), t) } function k1(t, e, n, r, i) { switch (e) { case "focusin": return Yn = ts(Yn, t, e, n, r, i), !0; case "dragenter": return Jn = ts(Jn, t, e, n, r, i), !0; case "mouseover": return Xn = ts(Xn, t, e, n, r, i), !0; case "pointerover": var s = i.pointerId; return Us.set(s, ts(Us.get(s) || null, t, e, n, r, i)), !0; case "gotpointercapture": return s = i.pointerId, zs.set(s, ts(zs.get(s) || null, t, e, n, r, i)), !0 }return !1 } function Og(t) { var e = Tr(t.target); if (e !== null) { var n = Gr(e); if (n !== null) { if (e = n.tag, e === 13) { if (e = xg(n), e !== null) { t.blockedOn = e, Rg(t.priority, function () { kg(n) }); return } } else if (e === 3 && n.stateNode.current.memoizedState.isDehydrated) { t.blockedOn = n.tag === 3 ? n.stateNode.containerInfo : null; return } } } t.blockedOn = null } function ea(t) { if (t.blockedOn !== null) return !1; for (var e = t.targetContainers; 0 < e.length;) { var n = mu(t.domEventName, t.eventSystemFlags, e[0], t.nativeEvent); if (n === null) { n = t.nativeEvent; var r = new n.constructor(n.type, n); cu = r, n.target.dispatchEvent(r), cu = null } else return e = lo(n), e !== null && Dd(e), t.blockedOn = n, !1; e.shift() } return !0 } function wp(t, e, n) { ea(t) && n.delete(e) } function N1() { hu = !1, Yn !== null && ea(Yn) && (Yn = null), Jn !== null && ea(Jn) && (Jn = null), Xn !== null && ea(Xn) && (Xn = null), Us.forEach(wp), zs.forEach(wp) } function ns(t, e) { t.blockedOn === e && (t.blockedOn = null, hu || (hu = !0, gt.unstable_scheduleCallback(gt.unstable_NormalPriority, N1))) } function $s(t) { function e(i) { return ns(i, t) } if (0 < Ao.length) { ns(Ao[0], t); for (var n = 1; n < Ao.length; n++) { var r = Ao[n]; r.blockedOn === t && (r.blockedOn = null) } } for (Yn !== null && ns(Yn, t), Jn !== null && ns(Jn, t), Xn !== null && ns(Xn, t), Us.forEach(e), zs.forEach(e), n = 0; n < Un.length; n++)r = Un[n], r.blockedOn === t && (r.blockedOn = null); for (; 0 < Un.length && (n = Un[0], n.blockedOn === null);)Og(n), n.blockedOn === null && Un.shift() } var xi = _n.ReactCurrentBatchConfig, Na = !0; function R1(t, e, n, r) { var i = ue, s = xi.transition; xi.transition = null; try { ue = 1, Md(t, e, n, r) } finally { ue = i, xi.transition = s } } function O1(t, e, n, r) { var i = ue, s = xi.transition; xi.transition = null; try { ue = 4, Md(t, e, n, r) } finally { ue = i, xi.transition = s } } function Md(t, e, n, r) { if (Na) { var i = mu(t, e, n, r); if (i === null) pc(t, e, r, Ra, n), yp(t, r); else if (k1(i, t, e, n, r)) r.stopPropagation(); else if (yp(t, r), e & 4 && -1 < I1.indexOf(t)) { for (; i !== null;) { var s = lo(i); if (s !== null && Ig(s), s = mu(t, e, n, r), s === null && pc(t, e, r, Ra, n), s === i) break; i = s } i !== null && r.stopPropagation() } else pc(t, e, r, null, n) } } var Ra = null; function mu(t, e, n, r) { if (Ra = null, t = jd(r), t = Tr(t), t !== null) if (e = Gr(t), e === null) t = null; else if (n = e.tag, n === 13) { if (t = xg(e), t !== null) return t; t = null } else if (n === 3) { if (e.stateNode.current.memoizedState.isDehydrated) return e.tag === 3 ? e.stateNode.containerInfo : null; t = null } else e !== t && (t = null); return Ra = t, null } function jg(t) { switch (t) { case "cancel": case "click": case "close": case "contextmenu": case "copy": case "cut": case "auxclick": case "dblclick": case "dragend": case "dragstart": case "drop": case "focusin": case "focusout": case "input": case "invalid": case "keydown": case "keypress": case "keyup": case "mousedown": case "mouseup": case "paste": case "pause": case "play": case "pointercancel": case "pointerdown": case "pointerup": case "ratechange": case "reset": case "resize": case "seeked": case "submit": case "touchcancel": case "touchend": case "touchstart": case "volumechange": case "change": case "selectionchange": case "textInput": case "compositionstart": case "compositionend": case "compositionupdate": case "beforeblur": case "afterblur": case "beforeinput": case "blur": case "fullscreenchange": case "focus": case "hashchange": case "popstate": case "select": case "selectstart": return 1; case "drag": case "dragenter": case "dragexit": case "dragleave": case "dragover": case "mousemove": case "mouseout": case "mouseover": case "pointermove": case "pointerout": case "pointerover": case "scroll": case "toggle": case "touchmove": case "wheel": case "mouseenter": case "mouseleave": case "pointerenter": case "pointerleave": return 4; case "message": switch (w1()) { case Ad: return 1; case Tg: return 4; case Ia: case x1: return 16; case Cg: return 536870912; default: return 16 }default: return 16 } } var Wn = null, Fd = null, ta = null; function Ag() { if (ta) return ta; var t, e = Fd, n = e.length, r, i = "value" in Wn ? Wn.value : Wn.textContent, s = i.length; for (t = 0; t < n && e[t] === i[t]; t++); var o = n - t; for (r = 1; r <= o && e[n - r] === i[s - r]; r++); return ta = i.slice(t, 1 < r ? 1 - r : void 0) } function na(t) { var e = t.keyCode; return "charCode" in t ? (t = t.charCode, t === 0 && e === 13 && (t = 13)) : t = e, t === 10 && (t = 13), 32 <= t || t === 13 ? t : 0 } function Lo() { return !0 } function xp() { return !1 } function yt(t) { function e(n, r, i, s, o) { this._reactName = n, this._targetInst = i, this.type = r, this.nativeEvent = s, this.target = o, this.currentTarget = null; for (var l in t) t.hasOwnProperty(l) && (n = t[l], this[l] = n ? n(s) : s[l]); return this.isDefaultPrevented = (s.defaultPrevented != null ? s.defaultPrevented : s.returnValue === !1) ? Lo : xp, this.isPropagationStopped = xp, this } return Te(e.prototype, { preventDefault: function () { this.defaultPrevented = !0; var n = this.nativeEvent; n && (n.preventDefault ? n.preventDefault() : typeof n.returnValue != "unknown" && (n.returnValue = !1), this.isDefaultPrevented = Lo) }, stopPropagation: function () { var n = this.nativeEvent; n && (n.stopPropagation ? n.stopPropagation() : typeof n.cancelBubble != "unknown" && (n.cancelBubble = !0), this.isPropagationStopped = Lo) }, persist: function () { }, isPersistent: Lo }), e } var Hi = { eventPhase: 0, bubbles: 0, cancelable: 0, timeStamp: function (t) { return t.timeStamp || Date.now() }, defaultPrevented: 0, isTrusted: 0 }, Ud = yt(Hi), ao = Te({}, Hi, { view: 0, detail: 0 }), j1 = yt(ao), ic, sc, rs, vl = Te({}, ao, { screenX: 0, screenY: 0, clientX: 0, clientY: 0, pageX: 0, pageY: 0, ctrlKey: 0, shiftKey: 0, altKey: 0, metaKey: 0, getModifierState: zd, button: 0, buttons: 0, relatedTarget: function (t) { return t.relatedTarget === void 0 ? t.fromElement === t.srcElement ? t.toElement : t.fromElement : t.relatedTarget }, movementX: function (t) { return "movementX" in t ? t.movementX : (t !== rs && (rs && t.type === "mousemove" ? (ic = t.screenX - rs.screenX, sc = t.screenY - rs.screenY) : sc = ic = 0, rs = t), ic) }, movementY: function (t) { return "movementY" in t ? t.movementY : sc } }), Sp = yt(vl), A1 = Te({}, vl, { dataTransfer: 0 }), L1 = yt(A1), D1 = Te({}, ao, { relatedTarget: 0 }), oc = yt(D1), M1 = Te({}, Hi, { animationName: 0, elapsedTime: 0, pseudoElement: 0 }), F1 = yt(M1), U1 = Te({}, Hi, { clipboardData: function (t) { return "clipboardData" in t ? t.clipboardData : window.clipboardData } }), z1 = yt(U1), $1 = Te({}, Hi, { data: 0 }), Ep = yt($1), B1 = { Esc: "Escape", Spacebar: " ", Left: "ArrowLeft", Up: "ArrowUp", Right: "ArrowRight", Down: "ArrowDown", Del: "Delete", Win: "OS", Menu: "ContextMenu", Apps: "ContextMenu", Scroll: "ScrollLock", MozPrintableKey: "Unidentified" }, H1 = { 8: "Backspace", 9: "Tab", 12: "Clear", 13: "Enter", 16: "Shift", 17: "Control", 18: "Alt", 19: "Pause", 20: "CapsLock", 27: "Escape", 32: " ", 33: "PageUp", 34: "PageDown", 35: "End", 36: "Home", 37: "ArrowLeft", 38: "ArrowUp", 39: "ArrowRight", 40: "ArrowDown", 45: "Insert", 46: "Delete", 112: "F1", 113: "F2", 114: "F3", 115: "F4", 116: "F5", 117: "F6", 118: "F7", 119: "F8", 120: "F9", 121: "F10", 122: "F11", 123: "F12", 144: "NumLock", 145: "ScrollLock", 224: "Meta" }, V1 = { Alt: "altKey", Control: "ctrlKey", Meta: "metaKey", Shift: "shiftKey" }; function W1(t) { var e = this.nativeEvent; return e.getModifierState ? e.getModifierState(t) : (t = V1[t]) ? !!e[t] : !1 } function zd() { return W1 } var G1 = Te({}, ao, { key: function (t) { if (t.key) { var e = B1[t.key] || t.key; if (e !== "Unidentified") return e } return t.type === "keypress" ? (t = na(t), t === 13 ? "Enter" : String.fromCharCode(t)) : t.type === "keydown" || t.type === "keyup" ? H1[t.keyCode] || "Unidentified" : "" }, code: 0, location: 0, ctrlKey: 0, shiftKey: 0, altKey: 0, metaKey: 0, repeat: 0, locale: 0, getModifierState: zd, charCode: function (t) { return t.type === "keypress" ? na(t) : 0 }, keyCode: function (t) { return t.type === "keydown" || t.type === "keyup" ? t.keyCode : 0 }, which: function (t) { return t.type === "keypress" ? na(t) : t.type === "keydown" || t.type === "keyup" ? t.keyCode : 0 } }), K1 = yt(G1), q1 = Te({}, vl, { pointerId: 0, width: 0, height: 0, pressure: 0, tangentialPressure: 0, tiltX: 0, tiltY: 0, twist: 0, pointerType: 0, isPrimary: 0 }), bp = yt(q1), Y1 = Te({}, ao, { touches: 0, targetTouches: 0, changedTouches: 0, altKey: 0, metaKey: 0, ctrlKey: 0, shiftKey: 0, getModifierState: zd }), J1 = yt(Y1), X1 = Te({}, Hi, { propertyName: 0, elapsedTime: 0, pseudoElement: 0 }), Q1 = yt(X1), Z1 = Te({}, vl, { deltaX: function (t) { return "deltaX" in t ? t.deltaX : "wheelDeltaX" in t ? -t.wheelDeltaX : 0 }, deltaY: function (t) { return "deltaY" in t ? t.deltaY : "wheelDeltaY" in t ? -t.wheelDeltaY : "wheelDelta" in t ? -t.wheelDelta : 0 }, deltaZ: 0, deltaMode: 0 }), ex = yt(Z1), tx = [9, 13, 27, 32], $d = yn && "CompositionEvent" in window, Cs = null; yn && "documentMode" in document && (Cs = document.documentMode); var nx = yn && "TextEvent" in window && !Cs, Lg = yn && (!$d || Cs && 8 < Cs && 11 >= Cs), Tp = " ", Cp = !1; function Dg(t, e) { switch (t) { case "keyup": return tx.indexOf(e.keyCode) !== -1; case "keydown": return e.keyCode !== 229; case "keypress": case "mousedown": case "focusout": return !0; default: return !1 } } function Mg(t) { return t = t.detail, typeof t == "object" && "data" in t ? t.data : null } var ai = !1; function rx(t, e) { switch (t) { case "compositionend": return Mg(e); case "keypress": return e.which !== 32 ? null : (Cp = !0, Tp); case "textInput": return t = e.data, t === Tp && Cp ? null : t; default: return null } } function ix(t, e) { if (ai) return t === "compositionend" || !$d && Dg(t, e) ? (t = Ag(), ta = Fd = Wn = null, ai = !1, t) : null; switch (t) { case "paste": return null; case "keypress": if (!(e.ctrlKey || e.altKey || e.metaKey) || e.ctrlKey && e.altKey) { if (e.char && 1 < e.char.length) return e.char; if (e.which) return String.fromCharCode(e.which) } return null; case "compositionend": return Lg && e.locale !== "ko" ? null : e.data; default: return null } } var sx = { color: !0, date: !0, datetime: !0, "datetime-local": !0, email: !0, month: !0, number: !0, password: !0, range: !0, search: !0, tel: !0, text: !0, time: !0, url: !0, week: !0 }; function _p(t) { var e = t && t.nodeName && t.nodeName.toLowerCase(); return e === "input" ? !!sx[t.type] : e === "textarea" } function Fg(t, e, n, r) { mg(r), e = Oa(e, "onChange"), 0 < e.length && (n = new Ud("onChange", "change", null, n, r), t.push({ event: n, listeners: e })) } var _s = null, Bs = null; function ox(t) { Yg(t, 0) } function yl(t) { var e = ui(t); if (lg(e)) return t } function ax(t, e) { if (t === "change") return e } var Ug = !1; if (yn) { var ac; if (yn) { var lc = "oninput" in document; if (!lc) { var Pp = document.createElement("div"); Pp.setAttribute("oninput", "return;"), lc = typeof Pp.oninput == "function" } ac = lc } else ac = !1; Ug = ac && (!document.documentMode || 9 < document.documentMode) } function Ip() { _s && (_s.detachEvent("onpropertychange", zg), Bs = _s = null) } function zg(t) { if (t.propertyName === "value" && yl(Bs)) { var e = []; Fg(e, Bs, t, jd(t)), wg(ox, e) } } function lx(t, e, n) { t === "focusin" ? (Ip(), _s = e, Bs = n, _s.attachEvent("onpropertychange", zg)) : t === "focusout" && Ip() } function cx(t) { if (t === "selectionchange" || t === "keyup" || t === "keydown") return yl(Bs) } function ux(t, e) { if (t === "click") return yl(e) } function dx(t, e) { if (t === "input" || t === "change") return yl(e) } function fx(t, e) { return t === e && (t !== 0 || 1 / t === 1 / e) || t !== t && e !== e } var zt = typeof Object.is == "function" ? Object.is : fx; function Hs(t, e) { if (zt(t, e)) return !0; if (typeof t != "object" || t === null || typeof e != "object" || e === null) return !1; var n = Object.keys(t), r = Object.keys(e); if (n.length !== r.length) return !1; for (r = 0; r < n.length; r++) { var i = n[r]; if (!Xc.call(e, i) || !zt(t[i], e[i])) return !1 } return !0 } function kp(t) { for (; t && t.firstChild;)t = t.firstChild; return t } function Np(t, e) { var n = kp(t); t = 0; for (var r; n;) { if (n.nodeType === 3) { if (r = t + n.textContent.length, t <= e && r >= e) return { node: n, offset: e - t }; t = r } e: { for (; n;) { if (n.nextSibling) { n = n.nextSibling; break e } n = n.parentNode } n = void 0 } n = kp(n) } } function $g(t, e) { return t && e ? t === e ? !0 : t && t.nodeType === 3 ? !1 : e && e.nodeType === 3 ? $g(t, e.parentNode) : "contains" in t ? t.contains(e) : t.compareDocumentPosition ? !!(t.compareDocumentPosition(e) & 16) : !1 : !1 } function Bg() { for (var t = window, e = Ca(); e instanceof t.HTMLIFrameElement;) { try { var n = typeof e.contentWindow.location.href == "string" } catch { n = !1 } if (n) t = e.contentWindow; else break; e = Ca(t.document) } return e } function Bd(t) { var e = t && t.nodeName && t.nodeName.toLowerCase(); return e && (e === "input" && (t.type === "text" || t.type === "search" || t.type === "tel" || t.type === "url" || t.type === "password") || e === "textarea" || t.contentEditable === "true") } function px(t) { var e = Bg(), n = t.focusedElem, r = t.selectionRange; if (e !== n && n && n.ownerDocument && $g(n.ownerDocument.documentElement, n)) { if (r !== null && Bd(n)) { if (e = r.start, t = r.end, t === void 0 && (t = e), "selectionStart" in n) n.selectionStart = e, n.selectionEnd = Math.min(t, n.value.length); else if (t = (e = n.ownerDocument || document) && e.defaultView || window, t.getSelection) { t = t.getSelection(); var i = n.textContent.length, s = Math.min(r.start, i); r = r.end === void 0 ? s : Math.min(r.end, i), !t.extend && s > r && (i = r, r = s, s = i), i = Np(n, s); var o = Np(n, r); i && o && (t.rangeCount !== 1 || t.anchorNode !== i.node || t.anchorOffset !== i.offset || t.focusNode !== o.node || t.focusOffset !== o.offset) && (e = e.createRange(), e.setStart(i.node, i.offset), t.removeAllRanges(), s > r ? (t.addRange(e), t.extend(o.node, o.offset)) : (e.setEnd(o.node, o.offset), t.addRange(e))) } } for (e = [], t = n; t = t.parentNode;)t.nodeType === 1 && e.push({ element: t, left: t.scrollLeft, top: t.scrollTop }); for (typeof n.focus == "function" && n.focus(), n = 0; n < e.length; n++)t = e[n], t.element.scrollLeft = t.left, t.element.scrollTop = t.top } } var hx = yn && "documentMode" in document && 11 >= document.documentMode, li = null, gu = null, Ps = null, vu = !1; function Rp(t, e, n) { var r = n.window === n ? n.document : n.nodeType === 9 ? n : n.ownerDocument; vu || li == null || li !== Ca(r) || (r = li, "selectionStart" in r && Bd(r) ? r = { start: r.selectionStart, end: r.selectionEnd } : (r = (r.ownerDocument && r.ownerDocument.defaultView || window).getSelection(), r = { anchorNode: r.anchorNode, anchorOffset: r.anchorOffset, focusNode: r.focusNode, focusOffset: r.focusOffset }), Ps && Hs(Ps, r) || (Ps = r, r = Oa(gu, "onSelect"), 0 < r.length && (e = new Ud("onSelect", "select", null, e, n), t.push({ event: e, listeners: r }), e.target = li))) } function Do(t, e) { var n = {}; return n[t.toLowerCase()] = e.toLowerCase(), n["Webkit" + t] = "webkit" + e, n["Moz" + t] = "moz" + e, n } var ci = { animationend: Do("Animation", "AnimationEnd"), animationiteration: Do("Animation", "AnimationIteration"), animationstart: Do("Animation", "AnimationStart"), transitionend: Do("Transition", "TransitionEnd") }, cc = {}, Hg = {}; yn && (Hg = document.createElement("div").style, "AnimationEvent" in window || (delete ci.animationend.animation, delete ci.animationiteration.animation, delete ci.animationstart.animation), "TransitionEvent" in window || delete ci.transitionend.transition); function wl(t) { if (cc[t]) return cc[t]; if (!ci[t]) return t; var e = ci[t], n; for (n in e) if (e.hasOwnProperty(n) && n in Hg) return cc[t] = e[n]; return t } var Vg = wl("animationend"), Wg = wl("animationiteration"), Gg = wl("animationstart"), Kg = wl("transitionend"), qg = new Map, Op = "abort auxClick cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll toggle touchMove waiting wheel".split(" "); function ar(t, e) { qg.set(t, e), Wr(e, [t]) } for (var uc = 0; uc < Op.length; uc++) { var dc = Op[uc], mx = dc.toLowerCase(), gx = dc[0].toUpperCase() + dc.slice(1); ar(mx, "on" + gx) } ar(Vg, "onAnimationEnd"); ar(Wg, "onAnimationIteration"); ar(Gg, "onAnimationStart"); ar("dblclick", "onDoubleClick"); ar("focusin", "onFocus"); ar("focusout", "onBlur"); ar(Kg, "onTransitionEnd"); Ni("onMouseEnter", ["mouseout", "mouseover"]); Ni("onMouseLeave", ["mouseout", "mouseover"]); Ni("onPointerEnter", ["pointerout", "pointerover"]); Ni("onPointerLeave", ["pointerout", "pointerover"]); Wr("onChange", "change click focusin focusout input keydown keyup selectionchange".split(" ")); Wr("onSelect", "focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(" ")); Wr("onBeforeInput", ["compositionend", "keypress", "textInput", "paste"]); Wr("onCompositionEnd", "compositionend focusout keydown keypress keyup mousedown".split(" ")); Wr("onCompositionStart", "compositionstart focusout keydown keypress keyup mousedown".split(" ")); Wr("onCompositionUpdate", "compositionupdate focusout keydown keypress keyup mousedown".split(" ")); var ys = "abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting".split(" "), vx = new Set("cancel close invalid load scroll toggle".split(" ").concat(ys)); function jp(t, e, n) { var r = t.type || "unknown-event"; t.currentTarget = n, m1(r, e, void 0, t), t.currentTarget = null } function Yg(t, e) { e = (e & 4) !== 0; for (var n = 0; n < t.length; n++) { var r = t[n], i = r.event; r = r.listeners; e: { var s = void 0; if (e) for (var o = r.length - 1; 0 <= o; o--) { var l = r[o], a = l.instance, c = l.currentTarget; if (l = l.listener, a !== s && i.isPropagationStopped()) break e; jp(i, l, c), s = a } else for (o = 0; o < r.length; o++) { if (l = r[o], a = l.instance, c = l.currentTarget, l = l.listener, a !== s && i.isPropagationStopped()) break e; jp(i, l, c), s = a } } } if (Pa) throw t = fu, Pa = !1, fu = null, t } function ye(t, e) { var n = e[Eu]; n === void 0 && (n = e[Eu] = new Set); var r = t + "__bubble"; n.has(r) || (Jg(e, t, 2, !1), n.add(r)) } function fc(t, e, n) { var r = 0; e && (r |= 4), Jg(n, t, r, e) } var Mo = "_reactListening" + Math.random().toString(36).slice(2); function Vs(t) { if (!t[Mo]) { t[Mo] = !0, rg.forEach(function (n) { n !== "selectionchange" && (vx.has(n) || fc(n, !1, t), fc(n, !0, t)) }); var e = t.nodeType === 9 ? t : t.ownerDocument; e === null || e[Mo] || (e[Mo] = !0, fc("selectionchange", !1, e)) } } function Jg(t, e, n, r) { switch (jg(e)) { case 1: var i = R1; break; case 4: i = O1; break; default: i = Md }n = i.bind(null, e, n, t), i = void 0, !du || e !== "touchstart" && e !== "touchmove" && e !== "wheel" || (i = !0), r ? i !== void 0 ? t.addEventListener(e, n, { capture: !0, passive: i }) : t.addEventListener(e, n, !0) : i !== void 0 ? t.addEventListener(e, n, { passive: i }) : t.addEventListener(e, n, !1) } function pc(t, e, n, r, i) { var s = r; if (!(e & 1) && !(e & 2) && r !== null) e: for (; ;) { if (r === null) return; var o = r.tag; if (o === 3 || o === 4) { var l = r.stateNode.containerInfo; if (l === i || l.nodeType === 8 && l.parentNode === i) break; if (o === 4) for (o = r.return; o !== null;) { var a = o.tag; if ((a === 3 || a === 4) && (a = o.stateNode.containerInfo, a === i || a.nodeType === 8 && a.parentNode === i)) return; o = o.return } for (; l !== null;) { if (o = Tr(l), o === null) return; if (a = o.tag, a === 5 || a === 6) { r = s = o; continue e } l = l.parentNode } } r = r.return } wg(function () { var c = s, u = jd(n), f = []; e: { var h = qg.get(t); if (h !== void 0) { var y = Ud, g = t; switch (t) { case "keypress": if (na(n) === 0) break e; case "keydown": case "keyup": y = K1; break; case "focusin": g = "focus", y = oc; break; case "focusout": g = "blur", y = oc; break; case "beforeblur": case "afterblur": y = oc; break; case "click": if (n.button === 2) break e; case "auxclick": case "dblclick": case "mousedown": case "mousemove": case "mouseup": case "mouseout": case "mouseover": case "contextmenu": y = Sp; break; case "drag": case "dragend": case "dragenter": case "dragexit": case "dragleave": case "dragover": case "dragstart": case "drop": y = L1; break; case "touchcancel": case "touchend": case "touchmove": case "touchstart": y = J1; break; case Vg: case Wg: case Gg: y = F1; break; case Kg: y = Q1; break; case "scroll": y = j1; break; case "wheel": y = ex; break; case "copy": case "cut": case "paste": y = z1; break; case "gotpointercapture": case "lostpointercapture": case "pointercancel": case "pointerdown": case "pointermove": case "pointerout": case "pointerover": case "pointerup": y = bp }var w = (e & 4) !== 0, E = !w && t === "scroll", v = w ? h !== null ? h + "Capture" : null : h; w = []; for (var p = c, m; p !== null;) { m = p; var S = m.stateNode; if (m.tag === 5 && S !== null && (m = S, v !== null && (S = Fs(p, v), S != null && w.push(Ws(p, S, m)))), E) break; p = p.return } 0 < w.length && (h = new y(h, g, null, n, u), f.push({ event: h, listeners: w })) } } if (!(e & 7)) { e: { if (h = t === "mouseover" || t === "pointerover", y = t === "mouseout" || t === "pointerout", h && n !== cu && (g = n.relatedTarget || n.fromElement) && (Tr(g) || g[wn])) break e; if ((y || h) && (h = u.window === u ? u : (h = u.ownerDocument) ? h.defaultView || h.parentWindow : window, y ? (g = n.relatedTarget || n.toElement, y = c, g = g ? Tr(g) : null, g !== null && (E = Gr(g), g !== E || g.tag !== 5 && g.tag !== 6) && (g = null)) : (y = null, g = c), y !== g)) { if (w = Sp, S = "onMouseLeave", v = "onMouseEnter", p = "mouse", (t === "pointerout" || t === "pointerover") && (w = bp, S = "onPointerLeave", v = "onPointerEnter", p = "pointer"), E = y == null ? h : ui(y), m = g == null ? h : ui(g), h = new w(S, p + "leave", y, n, u), h.target = E, h.relatedTarget = m, S = null, Tr(u) === c && (w = new w(v, p + "enter", g, n, u), w.target = m, w.relatedTarget = E, S = w), E = S, y && g) t: { for (w = y, v = g, p = 0, m = w; m; m = ei(m))p++; for (m = 0, S = v; S; S = ei(S))m++; for (; 0 < p - m;)w = ei(w), p--; for (; 0 < m - p;)v = ei(v), m--; for (; p--;) { if (w === v || v !== null && w === v.alternate) break t; w = ei(w), v = ei(v) } w = null } else w = null; y !== null && Ap(f, h, y, w, !1), g !== null && E !== null && Ap(f, E, g, w, !0) } } e: { if (h = c ? ui(c) : window, y = h.nodeName && h.nodeName.toLowerCase(), y === "select" || y === "input" && h.type === "file") var T = ax; else if (_p(h)) if (Ug) T = dx; else { T = cx; var x = lx } else (y = h.nodeName) && y.toLowerCase() === "input" && (h.type === "checkbox" || h.type === "radio") && (T = ux); if (T && (T = T(t, c))) { Fg(f, T, n, u); break e } x && x(t, h, c), t === "focusout" && (x = h._wrapperState) && x.controlled && h.type === "number" && iu(h, "number", h.value) } switch (x = c ? ui(c) : window, t) { case "focusin": (_p(x) || x.contentEditable === "true") && (li = x, gu = c, Ps = null); break; case "focusout": Ps = gu = li = null; break; case "mousedown": vu = !0; break; case "contextmenu": case "mouseup": case "dragend": vu = !1, Rp(f, n, u); break; case "selectionchange": if (hx) break; case "keydown": case "keyup": Rp(f, n, u) }var P; if ($d) e: { switch (t) { case "compositionstart": var I = "onCompositionStart"; break e; case "compositionend": I = "onCompositionEnd"; break e; case "compositionupdate": I = "onCompositionUpdate"; break e }I = void 0 } else ai ? Dg(t, n) && (I = "onCompositionEnd") : t === "keydown" && n.keyCode === 229 && (I = "onCompositionStart"); I && (Lg && n.locale !== "ko" && (ai || I !== "onCompositionStart" ? I === "onCompositionEnd" && ai && (P = Ag()) : (Wn = u, Fd = "value" in Wn ? Wn.value : Wn.textContent, ai = !0)), x = Oa(c, I), 0 < x.length && (I = new Ep(I, t, null, n, u), f.push({ event: I, listeners: x }), P ? I.data = P : (P = Mg(n), P !== null && (I.data = P)))), (P = nx ? rx(t, n) : ix(t, n)) && (c = Oa(c, "onBeforeInput"), 0 < c.length && (u = new Ep("onBeforeInput", "beforeinput", null, n, u), f.push({ event: u, listeners: c }), u.data = P)) } Yg(f, e) }) } function Ws(t, e, n) { return { instance: t, listener: e, currentTarget: n } } function Oa(t, e) { for (var n = e + "Capture", r = []; t !== null;) { var i = t, s = i.stateNode; i.tag === 5 && s !== null && (i = s, s = Fs(t, n), s != null && r.unshift(Ws(t, s, i)), s = Fs(t, e), s != null && r.push(Ws(t, s, i))), t = t.return } return r } function ei(t) { if (t === null) return null; do t = t.return; while (t && t.tag !== 5); return t || null } function Ap(t, e, n, r, i) { for (var s = e._reactName, o = []; n !== null && n !== r;) { var l = n, a = l.alternate, c = l.stateNode; if (a !== null && a === r) break; l.tag === 5 && c !== null && (l = c, i ? (a = Fs(n, s), a != null && o.unshift(Ws(n, a, l))) : i || (a = Fs(n, s), a != null && o.push(Ws(n, a, l)))), n = n.return } o.length !== 0 && t.push({ event: e, listeners: o }) } var yx = /\r\n?/g, wx = /\u0000|\uFFFD/g; function Lp(t) {
  return (typeof t == "string" ? t : "" + t).replace(yx, `
`).replace(wx, "")
} function Fo(t, e, n) { if (e = Lp(e), Lp(t) !== e && n) throw Error(M(425)) } function ja() { } var yu = null, wu = null; function xu(t, e) { return t === "textarea" || t === "noscript" || typeof e.children == "string" || typeof e.children == "number" || typeof e.dangerouslySetInnerHTML == "object" && e.dangerouslySetInnerHTML !== null && e.dangerouslySetInnerHTML.__html != null } var Su = typeof setTimeout == "function" ? setTimeout : void 0, xx = typeof clearTimeout == "function" ? clearTimeout : void 0, Dp = typeof Promise == "function" ? Promise : void 0, Sx = typeof queueMicrotask == "function" ? queueMicrotask : typeof Dp < "u" ? function (t) { return Dp.resolve(null).then(t).catch(Ex) } : Su; function Ex(t) { setTimeout(function () { throw t }) } function hc(t, e) { var n = e, r = 0; do { var i = n.nextSibling; if (t.removeChild(n), i && i.nodeType === 8) if (n = i.data, n === "/$") { if (r === 0) { t.removeChild(i), $s(e); return } r-- } else n !== "$" && n !== "$?" && n !== "$!" || r++; n = i } while (n); $s(e) } function Qn(t) { for (; t != null; t = t.nextSibling) { var e = t.nodeType; if (e === 1 || e === 3) break; if (e === 8) { if (e = t.data, e === "$" || e === "$!" || e === "$?") break; if (e === "/$") return null } } return t } function Mp(t) { t = t.previousSibling; for (var e = 0; t;) { if (t.nodeType === 8) { var n = t.data; if (n === "$" || n === "$!" || n === "$?") { if (e === 0) return t; e-- } else n === "/$" && e++ } t = t.previousSibling } return null } var Vi = Math.random().toString(36).slice(2), Gt = "__reactFiber$" + Vi, Gs = "__reactProps$" + Vi, wn = "__reactContainer$" + Vi, Eu = "__reactEvents$" + Vi, bx = "__reactListeners$" + Vi, Tx = "__reactHandles$" + Vi; function Tr(t) { var e = t[Gt]; if (e) return e; for (var n = t.parentNode; n;) { if (e = n[wn] || n[Gt]) { if (n = e.alternate, e.child !== null || n !== null && n.child !== null) for (t = Mp(t); t !== null;) { if (n = t[Gt]) return n; t = Mp(t) } return e } t = n, n = t.parentNode } return null } function lo(t) { return t = t[Gt] || t[wn], !t || t.tag !== 5 && t.tag !== 6 && t.tag !== 13 && t.tag !== 3 ? null : t } function ui(t) { if (t.tag === 5 || t.tag === 6) return t.stateNode; throw Error(M(33)) } function xl(t) { return t[Gs] || null } var bu = [], di = -1; function lr(t) { return { current: t } } function we(t) { 0 > di || (t.current = bu[di], bu[di] = null, di--) } function ve(t, e) { di++, bu[di] = t.current, t.current = e } var or = {}, Ge = lr(or), st = lr(!1), Ar = or; function Ri(t, e) { var n = t.type.contextTypes; if (!n) return or; var r = t.stateNode; if (r && r.__reactInternalMemoizedUnmaskedChildContext === e) return r.__reactInternalMemoizedMaskedChildContext; var i = {}, s; for (s in n) i[s] = e[s]; return r && (t = t.stateNode, t.__reactInternalMemoizedUnmaskedChildContext = e, t.__reactInternalMemoizedMaskedChildContext = i), i } function ot(t) { return t = t.childContextTypes, t != null } function Aa() { we(st), we(Ge) } function Fp(t, e, n) { if (Ge.current !== or) throw Error(M(168)); ve(Ge, e), ve(st, n) } function Xg(t, e, n) { var r = t.stateNode; if (e = e.childContextTypes, typeof r.getChildContext != "function") return n; r = r.getChildContext(); for (var i in r) if (!(i in e)) throw Error(M(108, l1(t) || "Unknown", i)); return Te({}, n, r) } function La(t) { return t = (t = t.stateNode) && t.__reactInternalMemoizedMergedChildContext || or, Ar = Ge.current, ve(Ge, t), ve(st, st.current), !0 } function Up(t, e, n) { var r = t.stateNode; if (!r) throw Error(M(169)); n ? (t = Xg(t, e, Ar), r.__reactInternalMemoizedMergedChildContext = t, we(st), we(Ge), ve(Ge, t)) : we(st), ve(st, n) } var an = null, Sl = !1, mc = !1; function Qg(t) { an === null ? an = [t] : an.push(t) } function Cx(t) { Sl = !0, Qg(t) } function cr() { if (!mc && an !== null) { mc = !0; var t = 0, e = ue; try { var n = an; for (ue = 1; t < n.length; t++) { var r = n[t]; do r = r(!0); while (r !== null) } an = null, Sl = !1 } catch (i) { throw an !== null && (an = an.slice(t + 1)), bg(Ad, cr), i } finally { ue = e, mc = !1 } } return null } var fi = [], pi = 0, Da = null, Ma = 0, Et = [], bt = 0, Lr = null, cn = 1, un = ""; function wr(t, e) { fi[pi++] = Ma, fi[pi++] = Da, Da = t, Ma = e } function Zg(t, e, n) { Et[bt++] = cn, Et[bt++] = un, Et[bt++] = Lr, Lr = t; var r = cn; t = un; var i = 32 - Mt(r) - 1; r &= ~(1 << i), n += 1; var s = 32 - Mt(e) + i; if (30 < s) { var o = i - i % 5; s = (r & (1 << o) - 1).toString(32), r >>= o, i -= o, cn = 1 << 32 - Mt(e) + i | n << i | r, un = s + t } else cn = 1 << s | n << i | r, un = t } function Hd(t) { t.return !== null && (wr(t, 1), Zg(t, 1, 0)) } function Vd(t) { for (; t === Da;)Da = fi[--pi], fi[pi] = null, Ma = fi[--pi], fi[pi] = null; for (; t === Lr;)Lr = Et[--bt], Et[bt] = null, un = Et[--bt], Et[bt] = null, cn = Et[--bt], Et[bt] = null } var ht = null, pt = null, Se = !1, At = null; function ev(t, e) { var n = Tt(5, null, null, 0); n.elementType = "DELETED", n.stateNode = e, n.return = t, e = t.deletions, e === null ? (t.deletions = [n], t.flags |= 16) : e.push(n) } function zp(t, e) { switch (t.tag) { case 5: var n = t.type; return e = e.nodeType !== 1 || n.toLowerCase() !== e.nodeName.toLowerCase() ? null : e, e !== null ? (t.stateNode = e, ht = t, pt = Qn(e.firstChild), !0) : !1; case 6: return e = t.pendingProps === "" || e.nodeType !== 3 ? null : e, e !== null ? (t.stateNode = e, ht = t, pt = null, !0) : !1; case 13: return e = e.nodeType !== 8 ? null : e, e !== null ? (n = Lr !== null ? { id: cn, overflow: un } : null, t.memoizedState = { dehydrated: e, treeContext: n, retryLane: 1073741824 }, n = Tt(18, null, null, 0), n.stateNode = e, n.return = t, t.child = n, ht = t, pt = null, !0) : !1; default: return !1 } } function Tu(t) { return (t.mode & 1) !== 0 && (t.flags & 128) === 0 } function Cu(t) { if (Se) { var e = pt; if (e) { var n = e; if (!zp(t, e)) { if (Tu(t)) throw Error(M(418)); e = Qn(n.nextSibling); var r = ht; e && zp(t, e) ? ev(r, n) : (t.flags = t.flags & -4097 | 2, Se = !1, ht = t) } } else { if (Tu(t)) throw Error(M(418)); t.flags = t.flags & -4097 | 2, Se = !1, ht = t } } } function $p(t) { for (t = t.return; t !== null && t.tag !== 5 && t.tag !== 3 && t.tag !== 13;)t = t.return; ht = t } function Uo(t) { if (t !== ht) return !1; if (!Se) return $p(t), Se = !0, !1; var e; if ((e = t.tag !== 3) && !(e = t.tag !== 5) && (e = t.type, e = e !== "head" && e !== "body" && !xu(t.type, t.memoizedProps)), e && (e = pt)) { if (Tu(t)) throw tv(), Error(M(418)); for (; e;)ev(t, e), e = Qn(e.nextSibling) } if ($p(t), t.tag === 13) { if (t = t.memoizedState, t = t !== null ? t.dehydrated : null, !t) throw Error(M(317)); e: { for (t = t.nextSibling, e = 0; t;) { if (t.nodeType === 8) { var n = t.data; if (n === "/$") { if (e === 0) { pt = Qn(t.nextSibling); break e } e-- } else n !== "$" && n !== "$!" && n !== "$?" || e++ } t = t.nextSibling } pt = null } } else pt = ht ? Qn(t.stateNode.nextSibling) : null; return !0 } function tv() { for (var t = pt; t;)t = Qn(t.nextSibling) } function Oi() { pt = ht = null, Se = !1 } function Wd(t) { At === null ? At = [t] : At.push(t) } var _x = _n.ReactCurrentBatchConfig; function is(t, e, n) { if (t = n.ref, t !== null && typeof t != "function" && typeof t != "object") { if (n._owner) { if (n = n._owner, n) { if (n.tag !== 1) throw Error(M(309)); var r = n.stateNode } if (!r) throw Error(M(147, t)); var i = r, s = "" + t; return e !== null && e.ref !== null && typeof e.ref == "function" && e.ref._stringRef === s ? e.ref : (e = function (o) { var l = i.refs; o === null ? delete l[s] : l[s] = o }, e._stringRef = s, e) } if (typeof t != "string") throw Error(M(284)); if (!n._owner) throw Error(M(290, t)) } return t } function zo(t, e) { throw t = Object.prototype.toString.call(e), Error(M(31, t === "[object Object]" ? "object with keys {" + Object.keys(e).join(", ") + "}" : t)) } function Bp(t) { var e = t._init; return e(t._payload) } function nv(t) { function e(v, p) { if (t) { var m = v.deletions; m === null ? (v.deletions = [p], v.flags |= 16) : m.push(p) } } function n(v, p) { if (!t) return null; for (; p !== null;)e(v, p), p = p.sibling; return null } function r(v, p) { for (v = new Map; p !== null;)p.key !== null ? v.set(p.key, p) : v.set(p.index, p), p = p.sibling; return v } function i(v, p) { return v = nr(v, p), v.index = 0, v.sibling = null, v } function s(v, p, m) { return v.index = m, t ? (m = v.alternate, m !== null ? (m = m.index, m < p ? (v.flags |= 2, p) : m) : (v.flags |= 2, p)) : (v.flags |= 1048576, p) } function o(v) { return t && v.alternate === null && (v.flags |= 2), v } function l(v, p, m, S) { return p === null || p.tag !== 6 ? (p = Ec(m, v.mode, S), p.return = v, p) : (p = i(p, m), p.return = v, p) } function a(v, p, m, S) { var T = m.type; return T === oi ? u(v, p, m.props.children, S, m.key) : p !== null && (p.elementType === T || typeof T == "object" && T !== null && T.$$typeof === Dn && Bp(T) === p.type) ? (S = i(p, m.props), S.ref = is(v, p, m), S.return = v, S) : (S = ca(m.type, m.key, m.props, null, v.mode, S), S.ref = is(v, p, m), S.return = v, S) } function c(v, p, m, S) { return p === null || p.tag !== 4 || p.stateNode.containerInfo !== m.containerInfo || p.stateNode.implementation !== m.implementation ? (p = bc(m, v.mode, S), p.return = v, p) : (p = i(p, m.children || []), p.return = v, p) } function u(v, p, m, S, T) { return p === null || p.tag !== 7 ? (p = Or(m, v.mode, S, T), p.return = v, p) : (p = i(p, m), p.return = v, p) } function f(v, p, m) { if (typeof p == "string" && p !== "" || typeof p == "number") return p = Ec("" + p, v.mode, m), p.return = v, p; if (typeof p == "object" && p !== null) { switch (p.$$typeof) { case ko: return m = ca(p.type, p.key, p.props, null, v.mode, m), m.ref = is(v, null, p), m.return = v, m; case si: return p = bc(p, v.mode, m), p.return = v, p; case Dn: var S = p._init; return f(v, S(p._payload), m) }if (gs(p) || Zi(p)) return p = Or(p, v.mode, m, null), p.return = v, p; zo(v, p) } return null } function h(v, p, m, S) { var T = p !== null ? p.key : null; if (typeof m == "string" && m !== "" || typeof m == "number") return T !== null ? null : l(v, p, "" + m, S); if (typeof m == "object" && m !== null) { switch (m.$$typeof) { case ko: return m.key === T ? a(v, p, m, S) : null; case si: return m.key === T ? c(v, p, m, S) : null; case Dn: return T = m._init, h(v, p, T(m._payload), S) }if (gs(m) || Zi(m)) return T !== null ? null : u(v, p, m, S, null); zo(v, m) } return null } function y(v, p, m, S, T) { if (typeof S == "string" && S !== "" || typeof S == "number") return v = v.get(m) || null, l(p, v, "" + S, T); if (typeof S == "object" && S !== null) { switch (S.$$typeof) { case ko: return v = v.get(S.key === null ? m : S.key) || null, a(p, v, S, T); case si: return v = v.get(S.key === null ? m : S.key) || null, c(p, v, S, T); case Dn: var x = S._init; return y(v, p, m, x(S._payload), T) }if (gs(S) || Zi(S)) return v = v.get(m) || null, u(p, v, S, T, null); zo(p, S) } return null } function g(v, p, m, S) { for (var T = null, x = null, P = p, I = p = 0, N = null; P !== null && I < m.length; I++) { P.index > I ? (N = P, P = null) : N = P.sibling; var k = h(v, P, m[I], S); if (k === null) { P === null && (P = N); break } t && P && k.alternate === null && e(v, P), p = s(k, p, I), x === null ? T = k : x.sibling = k, x = k, P = N } if (I === m.length) return n(v, P), Se && wr(v, I), T; if (P === null) { for (; I < m.length; I++)P = f(v, m[I], S), P !== null && (p = s(P, p, I), x === null ? T = P : x.sibling = P, x = P); return Se && wr(v, I), T } for (P = r(v, P); I < m.length; I++)N = y(P, v, I, m[I], S), N !== null && (t && N.alternate !== null && P.delete(N.key === null ? I : N.key), p = s(N, p, I), x === null ? T = N : x.sibling = N, x = N); return t && P.forEach(function (j) { return e(v, j) }), Se && wr(v, I), T } function w(v, p, m, S) { var T = Zi(m); if (typeof T != "function") throw Error(M(150)); if (m = T.call(m), m == null) throw Error(M(151)); for (var x = T = null, P = p, I = p = 0, N = null, k = m.next(); P !== null && !k.done; I++, k = m.next()) { P.index > I ? (N = P, P = null) : N = P.sibling; var j = h(v, P, k.value, S); if (j === null) { P === null && (P = N); break } t && P && j.alternate === null && e(v, P), p = s(j, p, I), x === null ? T = j : x.sibling = j, x = j, P = N } if (k.done) return n(v, P), Se && wr(v, I), T; if (P === null) { for (; !k.done; I++, k = m.next())k = f(v, k.value, S), k !== null && (p = s(k, p, I), x === null ? T = k : x.sibling = k, x = k); return Se && wr(v, I), T } for (P = r(v, P); !k.done; I++, k = m.next())k = y(P, v, I, k.value, S), k !== null && (t && k.alternate !== null && P.delete(k.key === null ? I : k.key), p = s(k, p, I), x === null ? T = k : x.sibling = k, x = k); return t && P.forEach(function (F) { return e(v, F) }), Se && wr(v, I), T } function E(v, p, m, S) { if (typeof m == "object" && m !== null && m.type === oi && m.key === null && (m = m.props.children), typeof m == "object" && m !== null) { switch (m.$$typeof) { case ko: e: { for (var T = m.key, x = p; x !== null;) { if (x.key === T) { if (T = m.type, T === oi) { if (x.tag === 7) { n(v, x.sibling), p = i(x, m.props.children), p.return = v, v = p; break e } } else if (x.elementType === T || typeof T == "object" && T !== null && T.$$typeof === Dn && Bp(T) === x.type) { n(v, x.sibling), p = i(x, m.props), p.ref = is(v, x, m), p.return = v, v = p; break e } n(v, x); break } else e(v, x); x = x.sibling } m.type === oi ? (p = Or(m.props.children, v.mode, S, m.key), p.return = v, v = p) : (S = ca(m.type, m.key, m.props, null, v.mode, S), S.ref = is(v, p, m), S.return = v, v = S) } return o(v); case si: e: { for (x = m.key; p !== null;) { if (p.key === x) if (p.tag === 4 && p.stateNode.containerInfo === m.containerInfo && p.stateNode.implementation === m.implementation) { n(v, p.sibling), p = i(p, m.children || []), p.return = v, v = p; break e } else { n(v, p); break } else e(v, p); p = p.sibling } p = bc(m, v.mode, S), p.return = v, v = p } return o(v); case Dn: return x = m._init, E(v, p, x(m._payload), S) }if (gs(m)) return g(v, p, m, S); if (Zi(m)) return w(v, p, m, S); zo(v, m) } return typeof m == "string" && m !== "" || typeof m == "number" ? (m = "" + m, p !== null && p.tag === 6 ? (n(v, p.sibling), p = i(p, m), p.return = v, v = p) : (n(v, p), p = Ec(m, v.mode, S), p.return = v, v = p), o(v)) : n(v, p) } return E } var ji = nv(!0), rv = nv(!1), Fa = lr(null), Ua = null, hi = null, Gd = null; function Kd() { Gd = hi = Ua = null } function qd(t) { var e = Fa.current; we(Fa), t._currentValue = e } function _u(t, e, n) { for (; t !== null;) { var r = t.alternate; if ((t.childLanes & e) !== e ? (t.childLanes |= e, r !== null && (r.childLanes |= e)) : r !== null && (r.childLanes & e) !== e && (r.childLanes |= e), t === n) break; t = t.return } } function Si(t, e) { Ua = t, Gd = hi = null, t = t.dependencies, t !== null && t.firstContext !== null && (t.lanes & e && (it = !0), t.firstContext = null) } function _t(t) { var e = t._currentValue; if (Gd !== t) if (t = { context: t, memoizedValue: e, next: null }, hi === null) { if (Ua === null) throw Error(M(308)); hi = t, Ua.dependencies = { lanes: 0, firstContext: t } } else hi = hi.next = t; return e } var Cr = null; function Yd(t) { Cr === null ? Cr = [t] : Cr.push(t) } function iv(t, e, n, r) { var i = e.interleaved; return i === null ? (n.next = n, Yd(e)) : (n.next = i.next, i.next = n), e.interleaved = n, xn(t, r) } function xn(t, e) { t.lanes |= e; var n = t.alternate; for (n !== null && (n.lanes |= e), n = t, t = t.return; t !== null;)t.childLanes |= e, n = t.alternate, n !== null && (n.childLanes |= e), n = t, t = t.return; return n.tag === 3 ? n.stateNode : null } var Mn = !1; function Jd(t) { t.updateQueue = { baseState: t.memoizedState, firstBaseUpdate: null, lastBaseUpdate: null, shared: { pending: null, interleaved: null, lanes: 0 }, effects: null } } function sv(t, e) { t = t.updateQueue, e.updateQueue === t && (e.updateQueue = { baseState: t.baseState, firstBaseUpdate: t.firstBaseUpdate, lastBaseUpdate: t.lastBaseUpdate, shared: t.shared, effects: t.effects }) } function hn(t, e) { return { eventTime: t, lane: e, tag: 0, payload: null, callback: null, next: null } } function Zn(t, e, n) { var r = t.updateQueue; if (r === null) return null; if (r = r.shared, se & 2) { var i = r.pending; return i === null ? e.next = e : (e.next = i.next, i.next = e), r.pending = e, xn(t, n) } return i = r.interleaved, i === null ? (e.next = e, Yd(r)) : (e.next = i.next, i.next = e), r.interleaved = e, xn(t, n) } function ra(t, e, n) { if (e = e.updateQueue, e !== null && (e = e.shared, (n & 4194240) !== 0)) { var r = e.lanes; r &= t.pendingLanes, n |= r, e.lanes = n, Ld(t, n) } } function Hp(t, e) { var n = t.updateQueue, r = t.alternate; if (r !== null && (r = r.updateQueue, n === r)) { var i = null, s = null; if (n = n.firstBaseUpdate, n !== null) { do { var o = { eventTime: n.eventTime, lane: n.lane, tag: n.tag, payload: n.payload, callback: n.callback, next: null }; s === null ? i = s = o : s = s.next = o, n = n.next } while (n !== null); s === null ? i = s = e : s = s.next = e } else i = s = e; n = { baseState: r.baseState, firstBaseUpdate: i, lastBaseUpdate: s, shared: r.shared, effects: r.effects }, t.updateQueue = n; return } t = n.lastBaseUpdate, t === null ? n.firstBaseUpdate = e : t.next = e, n.lastBaseUpdate = e } function za(t, e, n, r) { var i = t.updateQueue; Mn = !1; var s = i.firstBaseUpdate, o = i.lastBaseUpdate, l = i.shared.pending; if (l !== null) { i.shared.pending = null; var a = l, c = a.next; a.next = null, o === null ? s = c : o.next = c, o = a; var u = t.alternate; u !== null && (u = u.updateQueue, l = u.lastBaseUpdate, l !== o && (l === null ? u.firstBaseUpdate = c : l.next = c, u.lastBaseUpdate = a)) } if (s !== null) { var f = i.baseState; o = 0, u = c = a = null, l = s; do { var h = l.lane, y = l.eventTime; if ((r & h) === h) { u !== null && (u = u.next = { eventTime: y, lane: 0, tag: l.tag, payload: l.payload, callback: l.callback, next: null }); e: { var g = t, w = l; switch (h = e, y = n, w.tag) { case 1: if (g = w.payload, typeof g == "function") { f = g.call(y, f, h); break e } f = g; break e; case 3: g.flags = g.flags & -65537 | 128; case 0: if (g = w.payload, h = typeof g == "function" ? g.call(y, f, h) : g, h == null) break e; f = Te({}, f, h); break e; case 2: Mn = !0 } } l.callback !== null && l.lane !== 0 && (t.flags |= 64, h = i.effects, h === null ? i.effects = [l] : h.push(l)) } else y = { eventTime: y, lane: h, tag: l.tag, payload: l.payload, callback: l.callback, next: null }, u === null ? (c = u = y, a = f) : u = u.next = y, o |= h; if (l = l.next, l === null) { if (l = i.shared.pending, l === null) break; h = l, l = h.next, h.next = null, i.lastBaseUpdate = h, i.shared.pending = null } } while (!0); if (u === null && (a = f), i.baseState = a, i.firstBaseUpdate = c, i.lastBaseUpdate = u, e = i.shared.interleaved, e !== null) { i = e; do o |= i.lane, i = i.next; while (i !== e) } else s === null && (i.shared.lanes = 0); Mr |= o, t.lanes = o, t.memoizedState = f } } function Vp(t, e, n) { if (t = e.effects, e.effects = null, t !== null) for (e = 0; e < t.length; e++) { var r = t[e], i = r.callback; if (i !== null) { if (r.callback = null, r = n, typeof i != "function") throw Error(M(191, i)); i.call(r) } } } var co = {}, Jt = lr(co), Ks = lr(co), qs = lr(co); function _r(t) { if (t === co) throw Error(M(174)); return t } function Xd(t, e) { switch (ve(qs, e), ve(Ks, t), ve(Jt, co), t = e.nodeType, t) { case 9: case 11: e = (e = e.documentElement) ? e.namespaceURI : ou(null, ""); break; default: t = t === 8 ? e.parentNode : e, e = t.namespaceURI || null, t = t.tagName, e = ou(e, t) }we(Jt), ve(Jt, e) } function Ai() { we(Jt), we(Ks), we(qs) } function ov(t) { _r(qs.current); var e = _r(Jt.current), n = ou(e, t.type); e !== n && (ve(Ks, t), ve(Jt, n)) } function Qd(t) { Ks.current === t && (we(Jt), we(Ks)) } var Ee = lr(0); function $a(t) { for (var e = t; e !== null;) { if (e.tag === 13) { var n = e.memoizedState; if (n !== null && (n = n.dehydrated, n === null || n.data === "$?" || n.data === "$!")) return e } else if (e.tag === 19 && e.memoizedProps.revealOrder !== void 0) { if (e.flags & 128) return e } else if (e.child !== null) { e.child.return = e, e = e.child; continue } if (e === t) break; for (; e.sibling === null;) { if (e.return === null || e.return === t) return null; e = e.return } e.sibling.return = e.return, e = e.sibling } return null } var gc = []; function Zd() { for (var t = 0; t < gc.length; t++)gc[t]._workInProgressVersionPrimary = null; gc.length = 0 } var ia = _n.ReactCurrentDispatcher, vc = _n.ReactCurrentBatchConfig, Dr = 0, be = null, Oe = null, Le = null, Ba = !1, Is = !1, Ys = 0, Px = 0; function He() { throw Error(M(321)) } function ef(t, e) { if (e === null) return !1; for (var n = 0; n < e.length && n < t.length; n++)if (!zt(t[n], e[n])) return !1; return !0 } function tf(t, e, n, r, i, s) { if (Dr = s, be = e, e.memoizedState = null, e.updateQueue = null, e.lanes = 0, ia.current = t === null || t.memoizedState === null ? Rx : Ox, t = n(r, i), Is) { s = 0; do { if (Is = !1, Ys = 0, 25 <= s) throw Error(M(301)); s += 1, Le = Oe = null, e.updateQueue = null, ia.current = jx, t = n(r, i) } while (Is) } if (ia.current = Ha, e = Oe !== null && Oe.next !== null, Dr = 0, Le = Oe = be = null, Ba = !1, e) throw Error(M(300)); return t } function nf() { var t = Ys !== 0; return Ys = 0, t } function Wt() { var t = { memoizedState: null, baseState: null, baseQueue: null, queue: null, next: null }; return Le === null ? be.memoizedState = Le = t : Le = Le.next = t, Le } function Pt() { if (Oe === null) { var t = be.alternate; t = t !== null ? t.memoizedState : null } else t = Oe.next; var e = Le === null ? be.memoizedState : Le.next; if (e !== null) Le = e, Oe = t; else { if (t === null) throw Error(M(310)); Oe = t, t = { memoizedState: Oe.memoizedState, baseState: Oe.baseState, baseQueue: Oe.baseQueue, queue: Oe.queue, next: null }, Le === null ? be.memoizedState = Le = t : Le = Le.next = t } return Le } function Js(t, e) { return typeof e == "function" ? e(t) : e } function yc(t) { var e = Pt(), n = e.queue; if (n === null) throw Error(M(311)); n.lastRenderedReducer = t; var r = Oe, i = r.baseQueue, s = n.pending; if (s !== null) { if (i !== null) { var o = i.next; i.next = s.next, s.next = o } r.baseQueue = i = s, n.pending = null } if (i !== null) { s = i.next, r = r.baseState; var l = o = null, a = null, c = s; do { var u = c.lane; if ((Dr & u) === u) a !== null && (a = a.next = { lane: 0, action: c.action, hasEagerState: c.hasEagerState, eagerState: c.eagerState, next: null }), r = c.hasEagerState ? c.eagerState : t(r, c.action); else { var f = { lane: u, action: c.action, hasEagerState: c.hasEagerState, eagerState: c.eagerState, next: null }; a === null ? (l = a = f, o = r) : a = a.next = f, be.lanes |= u, Mr |= u } c = c.next } while (c !== null && c !== s); a === null ? o = r : a.next = l, zt(r, e.memoizedState) || (it = !0), e.memoizedState = r, e.baseState = o, e.baseQueue = a, n.lastRenderedState = r } if (t = n.interleaved, t !== null) { i = t; do s = i.lane, be.lanes |= s, Mr |= s, i = i.next; while (i !== t) } else i === null && (n.lanes = 0); return [e.memoizedState, n.dispatch] } function wc(t) { var e = Pt(), n = e.queue; if (n === null) throw Error(M(311)); n.lastRenderedReducer = t; var r = n.dispatch, i = n.pending, s = e.memoizedState; if (i !== null) { n.pending = null; var o = i = i.next; do s = t(s, o.action), o = o.next; while (o !== i); zt(s, e.memoizedState) || (it = !0), e.memoizedState = s, e.baseQueue === null && (e.baseState = s), n.lastRenderedState = s } return [s, r] } function av() { } function lv(t, e) { var n = be, r = Pt(), i = e(), s = !zt(r.memoizedState, i); if (s && (r.memoizedState = i, it = !0), r = r.queue, rf(dv.bind(null, n, r, t), [t]), r.getSnapshot !== e || s || Le !== null && Le.memoizedState.tag & 1) { if (n.flags |= 2048, Xs(9, uv.bind(null, n, r, i, e), void 0, null), De === null) throw Error(M(349)); Dr & 30 || cv(n, e, i) } return i } function cv(t, e, n) { t.flags |= 16384, t = { getSnapshot: e, value: n }, e = be.updateQueue, e === null ? (e = { lastEffect: null, stores: null }, be.updateQueue = e, e.stores = [t]) : (n = e.stores, n === null ? e.stores = [t] : n.push(t)) } function uv(t, e, n, r) { e.value = n, e.getSnapshot = r, fv(e) && pv(t) } function dv(t, e, n) { return n(function () { fv(e) && pv(t) }) } function fv(t) { var e = t.getSnapshot; t = t.value; try { var n = e(); return !zt(t, n) } catch { return !0 } } function pv(t) { var e = xn(t, 1); e !== null && Ft(e, t, 1, -1) } function Wp(t) { var e = Wt(); return typeof t == "function" && (t = t()), e.memoizedState = e.baseState = t, t = { pending: null, interleaved: null, lanes: 0, dispatch: null, lastRenderedReducer: Js, lastRenderedState: t }, e.queue = t, t = t.dispatch = Nx.bind(null, be, t), [e.memoizedState, t] } function Xs(t, e, n, r) { return t = { tag: t, create: e, destroy: n, deps: r, next: null }, e = be.updateQueue, e === null ? (e = { lastEffect: null, stores: null }, be.updateQueue = e, e.lastEffect = t.next = t) : (n = e.lastEffect, n === null ? e.lastEffect = t.next = t : (r = n.next, n.next = t, t.next = r, e.lastEffect = t)), t } function hv() { return Pt().memoizedState } function sa(t, e, n, r) { var i = Wt(); be.flags |= t, i.memoizedState = Xs(1 | e, n, void 0, r === void 0 ? null : r) } function El(t, e, n, r) { var i = Pt(); r = r === void 0 ? null : r; var s = void 0; if (Oe !== null) { var o = Oe.memoizedState; if (s = o.destroy, r !== null && ef(r, o.deps)) { i.memoizedState = Xs(e, n, s, r); return } } be.flags |= t, i.memoizedState = Xs(1 | e, n, s, r) } function Gp(t, e) { return sa(8390656, 8, t, e) } function rf(t, e) { return El(2048, 8, t, e) } function mv(t, e) { return El(4, 2, t, e) } function gv(t, e) { return El(4, 4, t, e) } function vv(t, e) { if (typeof e == "function") return t = t(), e(t), function () { e(null) }; if (e != null) return t = t(), e.current = t, function () { e.current = null } } function yv(t, e, n) { return n = n != null ? n.concat([t]) : null, El(4, 4, vv.bind(null, e, t), n) } function sf() { } function wv(t, e) { var n = Pt(); e = e === void 0 ? null : e; var r = n.memoizedState; return r !== null && e !== null && ef(e, r[1]) ? r[0] : (n.memoizedState = [t, e], t) } function xv(t, e) { var n = Pt(); e = e === void 0 ? null : e; var r = n.memoizedState; return r !== null && e !== null && ef(e, r[1]) ? r[0] : (t = t(), n.memoizedState = [t, e], t) } function Sv(t, e, n) { return Dr & 21 ? (zt(n, e) || (n = _g(), be.lanes |= n, Mr |= n, t.baseState = !0), e) : (t.baseState && (t.baseState = !1, it = !0), t.memoizedState = n) } function Ix(t, e) { var n = ue; ue = n !== 0 && 4 > n ? n : 4, t(!0); var r = vc.transition; vc.transition = {}; try { t(!1), e() } finally { ue = n, vc.transition = r } } function Ev() { return Pt().memoizedState } function kx(t, e, n) { var r = tr(t); if (n = { lane: r, action: n, hasEagerState: !1, eagerState: null, next: null }, bv(t)) Tv(e, n); else if (n = iv(t, e, n, r), n !== null) { var i = Qe(); Ft(n, t, r, i), Cv(n, e, r) } } function Nx(t, e, n) { var r = tr(t), i = { lane: r, action: n, hasEagerState: !1, eagerState: null, next: null }; if (bv(t)) Tv(e, i); else { var s = t.alternate; if (t.lanes === 0 && (s === null || s.lanes === 0) && (s = e.lastRenderedReducer, s !== null)) try { var o = e.lastRenderedState, l = s(o, n); if (i.hasEagerState = !0, i.eagerState = l, zt(l, o)) { var a = e.interleaved; a === null ? (i.next = i, Yd(e)) : (i.next = a.next, a.next = i), e.interleaved = i; return } } catch { } finally { } n = iv(t, e, i, r), n !== null && (i = Qe(), Ft(n, t, r, i), Cv(n, e, r)) } } function bv(t) { var e = t.alternate; return t === be || e !== null && e === be } function Tv(t, e) { Is = Ba = !0; var n = t.pending; n === null ? e.next = e : (e.next = n.next, n.next = e), t.pending = e } function Cv(t, e, n) { if (n & 4194240) { var r = e.lanes; r &= t.pendingLanes, n |= r, e.lanes = n, Ld(t, n) } } var Ha = { readContext: _t, useCallback: He, useContext: He, useEffect: He, useImperativeHandle: He, useInsertionEffect: He, useLayoutEffect: He, useMemo: He, useReducer: He, useRef: He, useState: He, useDebugValue: He, useDeferredValue: He, useTransition: He, useMutableSource: He, useSyncExternalStore: He, useId: He, unstable_isNewReconciler: !1 }, Rx = { readContext: _t, useCallback: function (t, e) { return Wt().memoizedState = [t, e === void 0 ? null : e], t }, useContext: _t, useEffect: Gp, useImperativeHandle: function (t, e, n) { return n = n != null ? n.concat([t]) : null, sa(4194308, 4, vv.bind(null, e, t), n) }, useLayoutEffect: function (t, e) { return sa(4194308, 4, t, e) }, useInsertionEffect: function (t, e) { return sa(4, 2, t, e) }, useMemo: function (t, e) { var n = Wt(); return e = e === void 0 ? null : e, t = t(), n.memoizedState = [t, e], t }, useReducer: function (t, e, n) { var r = Wt(); return e = n !== void 0 ? n(e) : e, r.memoizedState = r.baseState = e, t = { pending: null, interleaved: null, lanes: 0, dispatch: null, lastRenderedReducer: t, lastRenderedState: e }, r.queue = t, t = t.dispatch = kx.bind(null, be, t), [r.memoizedState, t] }, useRef: function (t) { var e = Wt(); return t = { current: t }, e.memoizedState = t }, useState: Wp, useDebugValue: sf, useDeferredValue: function (t) { return Wt().memoizedState = t }, useTransition: function () { var t = Wp(!1), e = t[0]; return t = Ix.bind(null, t[1]), Wt().memoizedState = t, [e, t] }, useMutableSource: function () { }, useSyncExternalStore: function (t, e, n) { var r = be, i = Wt(); if (Se) { if (n === void 0) throw Error(M(407)); n = n() } else { if (n = e(), De === null) throw Error(M(349)); Dr & 30 || cv(r, e, n) } i.memoizedState = n; var s = { value: n, getSnapshot: e }; return i.queue = s, Gp(dv.bind(null, r, s, t), [t]), r.flags |= 2048, Xs(9, uv.bind(null, r, s, n, e), void 0, null), n }, useId: function () { var t = Wt(), e = De.identifierPrefix; if (Se) { var n = un, r = cn; n = (r & ~(1 << 32 - Mt(r) - 1)).toString(32) + n, e = ":" + e + "R" + n, n = Ys++, 0 < n && (e += "H" + n.toString(32)), e += ":" } else n = Px++, e = ":" + e + "r" + n.toString(32) + ":"; return t.memoizedState = e }, unstable_isNewReconciler: !1 }, Ox = { readContext: _t, useCallback: wv, useContext: _t, useEffect: rf, useImperativeHandle: yv, useInsertionEffect: mv, useLayoutEffect: gv, useMemo: xv, useReducer: yc, useRef: hv, useState: function () { return yc(Js) }, useDebugValue: sf, useDeferredValue: function (t) { var e = Pt(); return Sv(e, Oe.memoizedState, t) }, useTransition: function () { var t = yc(Js)[0], e = Pt().memoizedState; return [t, e] }, useMutableSource: av, useSyncExternalStore: lv, useId: Ev, unstable_isNewReconciler: !1 }, jx = { readContext: _t, useCallback: wv, useContext: _t, useEffect: rf, useImperativeHandle: yv, useInsertionEffect: mv, useLayoutEffect: gv, useMemo: xv, useReducer: wc, useRef: hv, useState: function () { return wc(Js) }, useDebugValue: sf, useDeferredValue: function (t) { var e = Pt(); return Oe === null ? e.memoizedState = t : Sv(e, Oe.memoizedState, t) }, useTransition: function () { var t = wc(Js)[0], e = Pt().memoizedState; return [t, e] }, useMutableSource: av, useSyncExternalStore: lv, useId: Ev, unstable_isNewReconciler: !1 }; function Rt(t, e) { if (t && t.defaultProps) { e = Te({}, e), t = t.defaultProps; for (var n in t) e[n] === void 0 && (e[n] = t[n]); return e } return e } function Pu(t, e, n, r) { e = t.memoizedState, n = n(r, e), n = n == null ? e : Te({}, e, n), t.memoizedState = n, t.lanes === 0 && (t.updateQueue.baseState = n) } var bl = { isMounted: function (t) { return (t = t._reactInternals) ? Gr(t) === t : !1 }, enqueueSetState: function (t, e, n) { t = t._reactInternals; var r = Qe(), i = tr(t), s = hn(r, i); s.payload = e, n != null && (s.callback = n), e = Zn(t, s, i), e !== null && (Ft(e, t, i, r), ra(e, t, i)) }, enqueueReplaceState: function (t, e, n) { t = t._reactInternals; var r = Qe(), i = tr(t), s = hn(r, i); s.tag = 1, s.payload = e, n != null && (s.callback = n), e = Zn(t, s, i), e !== null && (Ft(e, t, i, r), ra(e, t, i)) }, enqueueForceUpdate: function (t, e) { t = t._reactInternals; var n = Qe(), r = tr(t), i = hn(n, r); i.tag = 2, e != null && (i.callback = e), e = Zn(t, i, r), e !== null && (Ft(e, t, r, n), ra(e, t, r)) } }; function Kp(t, e, n, r, i, s, o) { return t = t.stateNode, typeof t.shouldComponentUpdate == "function" ? t.shouldComponentUpdate(r, s, o) : e.prototype && e.prototype.isPureReactComponent ? !Hs(n, r) || !Hs(i, s) : !0 } function _v(t, e, n) { var r = !1, i = or, s = e.contextType; return typeof s == "object" && s !== null ? s = _t(s) : (i = ot(e) ? Ar : Ge.current, r = e.contextTypes, s = (r = r != null) ? Ri(t, i) : or), e = new e(n, s), t.memoizedState = e.state !== null && e.state !== void 0 ? e.state : null, e.updater = bl, t.stateNode = e, e._reactInternals = t, r && (t = t.stateNode, t.__reactInternalMemoizedUnmaskedChildContext = i, t.__reactInternalMemoizedMaskedChildContext = s), e } function qp(t, e, n, r) { t = e.state, typeof e.componentWillReceiveProps == "function" && e.componentWillReceiveProps(n, r), typeof e.UNSAFE_componentWillReceiveProps == "function" && e.UNSAFE_componentWillReceiveProps(n, r), e.state !== t && bl.enqueueReplaceState(e, e.state, null) } function Iu(t, e, n, r) { var i = t.stateNode; i.props = n, i.state = t.memoizedState, i.refs = {}, Jd(t); var s = e.contextType; typeof s == "object" && s !== null ? i.context = _t(s) : (s = ot(e) ? Ar : Ge.current, i.context = Ri(t, s)), i.state = t.memoizedState, s = e.getDerivedStateFromProps, typeof s == "function" && (Pu(t, e, s, n), i.state = t.memoizedState), typeof e.getDerivedStateFromProps == "function" || typeof i.getSnapshotBeforeUpdate == "function" || typeof i.UNSAFE_componentWillMount != "function" && typeof i.componentWillMount != "function" || (e = i.state, typeof i.componentWillMount == "function" && i.componentWillMount(), typeof i.UNSAFE_componentWillMount == "function" && i.UNSAFE_componentWillMount(), e !== i.state && bl.enqueueReplaceState(i, i.state, null), za(t, n, i, r), i.state = t.memoizedState), typeof i.componentDidMount == "function" && (t.flags |= 4194308) } function Li(t, e) {
  try { var n = "", r = e; do n += a1(r), r = r.return; while (r); var i = n } catch (s) {
    i = `
Error generating stack: `+ s.message + `
`+ s.stack
  } return { value: t, source: e, stack: i, digest: null }
} function xc(t, e, n) { return { value: t, source: null, stack: n ?? null, digest: e ?? null } } function ku(t, e) { try { console.error(e.value) } catch (n) { setTimeout(function () { throw n }) } } var Ax = typeof WeakMap == "function" ? WeakMap : Map; function Pv(t, e, n) { n = hn(-1, n), n.tag = 3, n.payload = { element: null }; var r = e.value; return n.callback = function () { Wa || (Wa = !0, Uu = r), ku(t, e) }, n } function Iv(t, e, n) { n = hn(-1, n), n.tag = 3; var r = t.type.getDerivedStateFromError; if (typeof r == "function") { var i = e.value; n.payload = function () { return r(i) }, n.callback = function () { ku(t, e) } } var s = t.stateNode; return s !== null && typeof s.componentDidCatch == "function" && (n.callback = function () { ku(t, e), typeof r != "function" && (er === null ? er = new Set([this]) : er.add(this)); var o = e.stack; this.componentDidCatch(e.value, { componentStack: o !== null ? o : "" }) }), n } function Yp(t, e, n) { var r = t.pingCache; if (r === null) { r = t.pingCache = new Ax; var i = new Set; r.set(e, i) } else i = r.get(e), i === void 0 && (i = new Set, r.set(e, i)); i.has(n) || (i.add(n), t = qx.bind(null, t, e, n), e.then(t, t)) } function Jp(t) { do { var e; if ((e = t.tag === 13) && (e = t.memoizedState, e = e !== null ? e.dehydrated !== null : !0), e) return t; t = t.return } while (t !== null); return null } function Xp(t, e, n, r, i) { return t.mode & 1 ? (t.flags |= 65536, t.lanes = i, t) : (t === e ? t.flags |= 65536 : (t.flags |= 128, n.flags |= 131072, n.flags &= -52805, n.tag === 1 && (n.alternate === null ? n.tag = 17 : (e = hn(-1, 1), e.tag = 2, Zn(n, e, 1))), n.lanes |= 1), t) } var Lx = _n.ReactCurrentOwner, it = !1; function Xe(t, e, n, r) { e.child = t === null ? rv(e, null, n, r) : ji(e, t.child, n, r) } function Qp(t, e, n, r, i) { n = n.render; var s = e.ref; return Si(e, i), r = tf(t, e, n, r, s, i), n = nf(), t !== null && !it ? (e.updateQueue = t.updateQueue, e.flags &= -2053, t.lanes &= ~i, Sn(t, e, i)) : (Se && n && Hd(e), e.flags |= 1, Xe(t, e, r, i), e.child) } function Zp(t, e, n, r, i) { if (t === null) { var s = n.type; return typeof s == "function" && !pf(s) && s.defaultProps === void 0 && n.compare === null && n.defaultProps === void 0 ? (e.tag = 15, e.type = s, kv(t, e, s, r, i)) : (t = ca(n.type, null, r, e, e.mode, i), t.ref = e.ref, t.return = e, e.child = t) } if (s = t.child, !(t.lanes & i)) { var o = s.memoizedProps; if (n = n.compare, n = n !== null ? n : Hs, n(o, r) && t.ref === e.ref) return Sn(t, e, i) } return e.flags |= 1, t = nr(s, r), t.ref = e.ref, t.return = e, e.child = t } function kv(t, e, n, r, i) { if (t !== null) { var s = t.memoizedProps; if (Hs(s, r) && t.ref === e.ref) if (it = !1, e.pendingProps = r = s, (t.lanes & i) !== 0) t.flags & 131072 && (it = !0); else return e.lanes = t.lanes, Sn(t, e, i) } return Nu(t, e, n, r, i) } function Nv(t, e, n) { var r = e.pendingProps, i = r.children, s = t !== null ? t.memoizedState : null; if (r.mode === "hidden") if (!(e.mode & 1)) e.memoizedState = { baseLanes: 0, cachePool: null, transitions: null }, ve(gi, ut), ut |= n; else { if (!(n & 1073741824)) return t = s !== null ? s.baseLanes | n : n, e.lanes = e.childLanes = 1073741824, e.memoizedState = { baseLanes: t, cachePool: null, transitions: null }, e.updateQueue = null, ve(gi, ut), ut |= t, null; e.memoizedState = { baseLanes: 0, cachePool: null, transitions: null }, r = s !== null ? s.baseLanes : n, ve(gi, ut), ut |= r } else s !== null ? (r = s.baseLanes | n, e.memoizedState = null) : r = n, ve(gi, ut), ut |= r; return Xe(t, e, i, n), e.child } function Rv(t, e) { var n = e.ref; (t === null && n !== null || t !== null && t.ref !== n) && (e.flags |= 512, e.flags |= 2097152) } function Nu(t, e, n, r, i) { var s = ot(n) ? Ar : Ge.current; return s = Ri(e, s), Si(e, i), n = tf(t, e, n, r, s, i), r = nf(), t !== null && !it ? (e.updateQueue = t.updateQueue, e.flags &= -2053, t.lanes &= ~i, Sn(t, e, i)) : (Se && r && Hd(e), e.flags |= 1, Xe(t, e, n, i), e.child) } function eh(t, e, n, r, i) { if (ot(n)) { var s = !0; La(e) } else s = !1; if (Si(e, i), e.stateNode === null) oa(t, e), _v(e, n, r), Iu(e, n, r, i), r = !0; else if (t === null) { var o = e.stateNode, l = e.memoizedProps; o.props = l; var a = o.context, c = n.contextType; typeof c == "object" && c !== null ? c = _t(c) : (c = ot(n) ? Ar : Ge.current, c = Ri(e, c)); var u = n.getDerivedStateFromProps, f = typeof u == "function" || typeof o.getSnapshotBeforeUpdate == "function"; f || typeof o.UNSAFE_componentWillReceiveProps != "function" && typeof o.componentWillReceiveProps != "function" || (l !== r || a !== c) && qp(e, o, r, c), Mn = !1; var h = e.memoizedState; o.state = h, za(e, r, o, i), a = e.memoizedState, l !== r || h !== a || st.current || Mn ? (typeof u == "function" && (Pu(e, n, u, r), a = e.memoizedState), (l = Mn || Kp(e, n, l, r, h, a, c)) ? (f || typeof o.UNSAFE_componentWillMount != "function" && typeof o.componentWillMount != "function" || (typeof o.componentWillMount == "function" && o.componentWillMount(), typeof o.UNSAFE_componentWillMount == "function" && o.UNSAFE_componentWillMount()), typeof o.componentDidMount == "function" && (e.flags |= 4194308)) : (typeof o.componentDidMount == "function" && (e.flags |= 4194308), e.memoizedProps = r, e.memoizedState = a), o.props = r, o.state = a, o.context = c, r = l) : (typeof o.componentDidMount == "function" && (e.flags |= 4194308), r = !1) } else { o = e.stateNode, sv(t, e), l = e.memoizedProps, c = e.type === e.elementType ? l : Rt(e.type, l), o.props = c, f = e.pendingProps, h = o.context, a = n.contextType, typeof a == "object" && a !== null ? a = _t(a) : (a = ot(n) ? Ar : Ge.current, a = Ri(e, a)); var y = n.getDerivedStateFromProps; (u = typeof y == "function" || typeof o.getSnapshotBeforeUpdate == "function") || typeof o.UNSAFE_componentWillReceiveProps != "function" && typeof o.componentWillReceiveProps != "function" || (l !== f || h !== a) && qp(e, o, r, a), Mn = !1, h = e.memoizedState, o.state = h, za(e, r, o, i); var g = e.memoizedState; l !== f || h !== g || st.current || Mn ? (typeof y == "function" && (Pu(e, n, y, r), g = e.memoizedState), (c = Mn || Kp(e, n, c, r, h, g, a) || !1) ? (u || typeof o.UNSAFE_componentWillUpdate != "function" && typeof o.componentWillUpdate != "function" || (typeof o.componentWillUpdate == "function" && o.componentWillUpdate(r, g, a), typeof o.UNSAFE_componentWillUpdate == "function" && o.UNSAFE_componentWillUpdate(r, g, a)), typeof o.componentDidUpdate == "function" && (e.flags |= 4), typeof o.getSnapshotBeforeUpdate == "function" && (e.flags |= 1024)) : (typeof o.componentDidUpdate != "function" || l === t.memoizedProps && h === t.memoizedState || (e.flags |= 4), typeof o.getSnapshotBeforeUpdate != "function" || l === t.memoizedProps && h === t.memoizedState || (e.flags |= 1024), e.memoizedProps = r, e.memoizedState = g), o.props = r, o.state = g, o.context = a, r = c) : (typeof o.componentDidUpdate != "function" || l === t.memoizedProps && h === t.memoizedState || (e.flags |= 4), typeof o.getSnapshotBeforeUpdate != "function" || l === t.memoizedProps && h === t.memoizedState || (e.flags |= 1024), r = !1) } return Ru(t, e, n, r, s, i) } function Ru(t, e, n, r, i, s) { Rv(t, e); var o = (e.flags & 128) !== 0; if (!r && !o) return i && Up(e, n, !1), Sn(t, e, s); r = e.stateNode, Lx.current = e; var l = o && typeof n.getDerivedStateFromError != "function" ? null : r.render(); return e.flags |= 1, t !== null && o ? (e.child = ji(e, t.child, null, s), e.child = ji(e, null, l, s)) : Xe(t, e, l, s), e.memoizedState = r.state, i && Up(e, n, !0), e.child } function Ov(t) { var e = t.stateNode; e.pendingContext ? Fp(t, e.pendingContext, e.pendingContext !== e.context) : e.context && Fp(t, e.context, !1), Xd(t, e.containerInfo) } function th(t, e, n, r, i) { return Oi(), Wd(i), e.flags |= 256, Xe(t, e, n, r), e.child } var Ou = { dehydrated: null, treeContext: null, retryLane: 0 }; function ju(t) { return { baseLanes: t, cachePool: null, transitions: null } } function jv(t, e, n) { var r = e.pendingProps, i = Ee.current, s = !1, o = (e.flags & 128) !== 0, l; if ((l = o) || (l = t !== null && t.memoizedState === null ? !1 : (i & 2) !== 0), l ? (s = !0, e.flags &= -129) : (t === null || t.memoizedState !== null) && (i |= 1), ve(Ee, i & 1), t === null) return Cu(e), t = e.memoizedState, t !== null && (t = t.dehydrated, t !== null) ? (e.mode & 1 ? t.data === "$!" ? e.lanes = 8 : e.lanes = 1073741824 : e.lanes = 1, null) : (o = r.children, t = r.fallback, s ? (r = e.mode, s = e.child, o = { mode: "hidden", children: o }, !(r & 1) && s !== null ? (s.childLanes = 0, s.pendingProps = o) : s = _l(o, r, 0, null), t = Or(t, r, n, null), s.return = e, t.return = e, s.sibling = t, e.child = s, e.child.memoizedState = ju(n), e.memoizedState = Ou, t) : of(e, o)); if (i = t.memoizedState, i !== null && (l = i.dehydrated, l !== null)) return Dx(t, e, o, r, l, i, n); if (s) { s = r.fallback, o = e.mode, i = t.child, l = i.sibling; var a = { mode: "hidden", children: r.children }; return !(o & 1) && e.child !== i ? (r = e.child, r.childLanes = 0, r.pendingProps = a, e.deletions = null) : (r = nr(i, a), r.subtreeFlags = i.subtreeFlags & 14680064), l !== null ? s = nr(l, s) : (s = Or(s, o, n, null), s.flags |= 2), s.return = e, r.return = e, r.sibling = s, e.child = r, r = s, s = e.child, o = t.child.memoizedState, o = o === null ? ju(n) : { baseLanes: o.baseLanes | n, cachePool: null, transitions: o.transitions }, s.memoizedState = o, s.childLanes = t.childLanes & ~n, e.memoizedState = Ou, r } return s = t.child, t = s.sibling, r = nr(s, { mode: "visible", children: r.children }), !(e.mode & 1) && (r.lanes = n), r.return = e, r.sibling = null, t !== null && (n = e.deletions, n === null ? (e.deletions = [t], e.flags |= 16) : n.push(t)), e.child = r, e.memoizedState = null, r } function of(t, e) { return e = _l({ mode: "visible", children: e }, t.mode, 0, null), e.return = t, t.child = e } function $o(t, e, n, r) { return r !== null && Wd(r), ji(e, t.child, null, n), t = of(e, e.pendingProps.children), t.flags |= 2, e.memoizedState = null, t } function Dx(t, e, n, r, i, s, o) { if (n) return e.flags & 256 ? (e.flags &= -257, r = xc(Error(M(422))), $o(t, e, o, r)) : e.memoizedState !== null ? (e.child = t.child, e.flags |= 128, null) : (s = r.fallback, i = e.mode, r = _l({ mode: "visible", children: r.children }, i, 0, null), s = Or(s, i, o, null), s.flags |= 2, r.return = e, s.return = e, r.sibling = s, e.child = r, e.mode & 1 && ji(e, t.child, null, o), e.child.memoizedState = ju(o), e.memoizedState = Ou, s); if (!(e.mode & 1)) return $o(t, e, o, null); if (i.data === "$!") { if (r = i.nextSibling && i.nextSibling.dataset, r) var l = r.dgst; return r = l, s = Error(M(419)), r = xc(s, r, void 0), $o(t, e, o, r) } if (l = (o & t.childLanes) !== 0, it || l) { if (r = De, r !== null) { switch (o & -o) { case 4: i = 2; break; case 16: i = 8; break; case 64: case 128: case 256: case 512: case 1024: case 2048: case 4096: case 8192: case 16384: case 32768: case 65536: case 131072: case 262144: case 524288: case 1048576: case 2097152: case 4194304: case 8388608: case 16777216: case 33554432: case 67108864: i = 32; break; case 536870912: i = 268435456; break; default: i = 0 }i = i & (r.suspendedLanes | o) ? 0 : i, i !== 0 && i !== s.retryLane && (s.retryLane = i, xn(t, i), Ft(r, t, i, -1)) } return ff(), r = xc(Error(M(421))), $o(t, e, o, r) } return i.data === "$?" ? (e.flags |= 128, e.child = t.child, e = Yx.bind(null, t), i._reactRetry = e, null) : (t = s.treeContext, pt = Qn(i.nextSibling), ht = e, Se = !0, At = null, t !== null && (Et[bt++] = cn, Et[bt++] = un, Et[bt++] = Lr, cn = t.id, un = t.overflow, Lr = e), e = of(e, r.children), e.flags |= 4096, e) } function nh(t, e, n) { t.lanes |= e; var r = t.alternate; r !== null && (r.lanes |= e), _u(t.return, e, n) } function Sc(t, e, n, r, i) { var s = t.memoizedState; s === null ? t.memoizedState = { isBackwards: e, rendering: null, renderingStartTime: 0, last: r, tail: n, tailMode: i } : (s.isBackwards = e, s.rendering = null, s.renderingStartTime = 0, s.last = r, s.tail = n, s.tailMode = i) } function Av(t, e, n) { var r = e.pendingProps, i = r.revealOrder, s = r.tail; if (Xe(t, e, r.children, n), r = Ee.current, r & 2) r = r & 1 | 2, e.flags |= 128; else { if (t !== null && t.flags & 128) e: for (t = e.child; t !== null;) { if (t.tag === 13) t.memoizedState !== null && nh(t, n, e); else if (t.tag === 19) nh(t, n, e); else if (t.child !== null) { t.child.return = t, t = t.child; continue } if (t === e) break e; for (; t.sibling === null;) { if (t.return === null || t.return === e) break e; t = t.return } t.sibling.return = t.return, t = t.sibling } r &= 1 } if (ve(Ee, r), !(e.mode & 1)) e.memoizedState = null; else switch (i) { case "forwards": for (n = e.child, i = null; n !== null;)t = n.alternate, t !== null && $a(t) === null && (i = n), n = n.sibling; n = i, n === null ? (i = e.child, e.child = null) : (i = n.sibling, n.sibling = null), Sc(e, !1, i, n, s); break; case "backwards": for (n = null, i = e.child, e.child = null; i !== null;) { if (t = i.alternate, t !== null && $a(t) === null) { e.child = i; break } t = i.sibling, i.sibling = n, n = i, i = t } Sc(e, !0, n, null, s); break; case "together": Sc(e, !1, null, null, void 0); break; default: e.memoizedState = null }return e.child } function oa(t, e) { !(e.mode & 1) && t !== null && (t.alternate = null, e.alternate = null, e.flags |= 2) } function Sn(t, e, n) { if (t !== null && (e.dependencies = t.dependencies), Mr |= e.lanes, !(n & e.childLanes)) return null; if (t !== null && e.child !== t.child) throw Error(M(153)); if (e.child !== null) { for (t = e.child, n = nr(t, t.pendingProps), e.child = n, n.return = e; t.sibling !== null;)t = t.sibling, n = n.sibling = nr(t, t.pendingProps), n.return = e; n.sibling = null } return e.child } function Mx(t, e, n) { switch (e.tag) { case 3: Ov(e), Oi(); break; case 5: ov(e); break; case 1: ot(e.type) && La(e); break; case 4: Xd(e, e.stateNode.containerInfo); break; case 10: var r = e.type._context, i = e.memoizedProps.value; ve(Fa, r._currentValue), r._currentValue = i; break; case 13: if (r = e.memoizedState, r !== null) return r.dehydrated !== null ? (ve(Ee, Ee.current & 1), e.flags |= 128, null) : n & e.child.childLanes ? jv(t, e, n) : (ve(Ee, Ee.current & 1), t = Sn(t, e, n), t !== null ? t.sibling : null); ve(Ee, Ee.current & 1); break; case 19: if (r = (n & e.childLanes) !== 0, t.flags & 128) { if (r) return Av(t, e, n); e.flags |= 128 } if (i = e.memoizedState, i !== null && (i.rendering = null, i.tail = null, i.lastEffect = null), ve(Ee, Ee.current), r) break; return null; case 22: case 23: return e.lanes = 0, Nv(t, e, n) }return Sn(t, e, n) } var Lv, Au, Dv, Mv; Lv = function (t, e) { for (var n = e.child; n !== null;) { if (n.tag === 5 || n.tag === 6) t.appendChild(n.stateNode); else if (n.tag !== 4 && n.child !== null) { n.child.return = n, n = n.child; continue } if (n === e) break; for (; n.sibling === null;) { if (n.return === null || n.return === e) return; n = n.return } n.sibling.return = n.return, n = n.sibling } }; Au = function () { }; Dv = function (t, e, n, r) { var i = t.memoizedProps; if (i !== r) { t = e.stateNode, _r(Jt.current); var s = null; switch (n) { case "input": i = nu(t, i), r = nu(t, r), s = []; break; case "select": i = Te({}, i, { value: void 0 }), r = Te({}, r, { value: void 0 }), s = []; break; case "textarea": i = su(t, i), r = su(t, r), s = []; break; default: typeof i.onClick != "function" && typeof r.onClick == "function" && (t.onclick = ja) }au(n, r); var o; n = null; for (c in i) if (!r.hasOwnProperty(c) && i.hasOwnProperty(c) && i[c] != null) if (c === "style") { var l = i[c]; for (o in l) l.hasOwnProperty(o) && (n || (n = {}), n[o] = "") } else c !== "dangerouslySetInnerHTML" && c !== "children" && c !== "suppressContentEditableWarning" && c !== "suppressHydrationWarning" && c !== "autoFocus" && (Ds.hasOwnProperty(c) ? s || (s = []) : (s = s || []).push(c, null)); for (c in r) { var a = r[c]; if (l = i != null ? i[c] : void 0, r.hasOwnProperty(c) && a !== l && (a != null || l != null)) if (c === "style") if (l) { for (o in l) !l.hasOwnProperty(o) || a && a.hasOwnProperty(o) || (n || (n = {}), n[o] = ""); for (o in a) a.hasOwnProperty(o) && l[o] !== a[o] && (n || (n = {}), n[o] = a[o]) } else n || (s || (s = []), s.push(c, n)), n = a; else c === "dangerouslySetInnerHTML" ? (a = a ? a.__html : void 0, l = l ? l.__html : void 0, a != null && l !== a && (s = s || []).push(c, a)) : c === "children" ? typeof a != "string" && typeof a != "number" || (s = s || []).push(c, "" + a) : c !== "suppressContentEditableWarning" && c !== "suppressHydrationWarning" && (Ds.hasOwnProperty(c) ? (a != null && c === "onScroll" && ye("scroll", t), s || l === a || (s = [])) : (s = s || []).push(c, a)) } n && (s = s || []).push("style", n); var c = s; (e.updateQueue = c) && (e.flags |= 4) } }; Mv = function (t, e, n, r) { n !== r && (e.flags |= 4) }; function ss(t, e) { if (!Se) switch (t.tailMode) { case "hidden": e = t.tail; for (var n = null; e !== null;)e.alternate !== null && (n = e), e = e.sibling; n === null ? t.tail = null : n.sibling = null; break; case "collapsed": n = t.tail; for (var r = null; n !== null;)n.alternate !== null && (r = n), n = n.sibling; r === null ? e || t.tail === null ? t.tail = null : t.tail.sibling = null : r.sibling = null } } function Ve(t) { var e = t.alternate !== null && t.alternate.child === t.child, n = 0, r = 0; if (e) for (var i = t.child; i !== null;)n |= i.lanes | i.childLanes, r |= i.subtreeFlags & 14680064, r |= i.flags & 14680064, i.return = t, i = i.sibling; else for (i = t.child; i !== null;)n |= i.lanes | i.childLanes, r |= i.subtreeFlags, r |= i.flags, i.return = t, i = i.sibling; return t.subtreeFlags |= r, t.childLanes = n, e } function Fx(t, e, n) { var r = e.pendingProps; switch (Vd(e), e.tag) { case 2: case 16: case 15: case 0: case 11: case 7: case 8: case 12: case 9: case 14: return Ve(e), null; case 1: return ot(e.type) && Aa(), Ve(e), null; case 3: return r = e.stateNode, Ai(), we(st), we(Ge), Zd(), r.pendingContext && (r.context = r.pendingContext, r.pendingContext = null), (t === null || t.child === null) && (Uo(e) ? e.flags |= 4 : t === null || t.memoizedState.isDehydrated && !(e.flags & 256) || (e.flags |= 1024, At !== null && (Bu(At), At = null))), Au(t, e), Ve(e), null; case 5: Qd(e); var i = _r(qs.current); if (n = e.type, t !== null && e.stateNode != null) Dv(t, e, n, r, i), t.ref !== e.ref && (e.flags |= 512, e.flags |= 2097152); else { if (!r) { if (e.stateNode === null) throw Error(M(166)); return Ve(e), null } if (t = _r(Jt.current), Uo(e)) { r = e.stateNode, n = e.type; var s = e.memoizedProps; switch (r[Gt] = e, r[Gs] = s, t = (e.mode & 1) !== 0, n) { case "dialog": ye("cancel", r), ye("close", r); break; case "iframe": case "object": case "embed": ye("load", r); break; case "video": case "audio": for (i = 0; i < ys.length; i++)ye(ys[i], r); break; case "source": ye("error", r); break; case "img": case "image": case "link": ye("error", r), ye("load", r); break; case "details": ye("toggle", r); break; case "input": dp(r, s), ye("invalid", r); break; case "select": r._wrapperState = { wasMultiple: !!s.multiple }, ye("invalid", r); break; case "textarea": pp(r, s), ye("invalid", r) }au(n, s), i = null; for (var o in s) if (s.hasOwnProperty(o)) { var l = s[o]; o === "children" ? typeof l == "string" ? r.textContent !== l && (s.suppressHydrationWarning !== !0 && Fo(r.textContent, l, t), i = ["children", l]) : typeof l == "number" && r.textContent !== "" + l && (s.suppressHydrationWarning !== !0 && Fo(r.textContent, l, t), i = ["children", "" + l]) : Ds.hasOwnProperty(o) && l != null && o === "onScroll" && ye("scroll", r) } switch (n) { case "input": No(r), fp(r, s, !0); break; case "textarea": No(r), hp(r); break; case "select": case "option": break; default: typeof s.onClick == "function" && (r.onclick = ja) }r = i, e.updateQueue = r, r !== null && (e.flags |= 4) } else { o = i.nodeType === 9 ? i : i.ownerDocument, t === "http://www.w3.org/1999/xhtml" && (t = dg(n)), t === "http://www.w3.org/1999/xhtml" ? n === "script" ? (t = o.createElement("div"), t.innerHTML = "<script><\/script>", t = t.removeChild(t.firstChild)) : typeof r.is == "string" ? t = o.createElement(n, { is: r.is }) : (t = o.createElement(n), n === "select" && (o = t, r.multiple ? o.multiple = !0 : r.size && (o.size = r.size))) : t = o.createElementNS(t, n), t[Gt] = e, t[Gs] = r, Lv(t, e, !1, !1), e.stateNode = t; e: { switch (o = lu(n, r), n) { case "dialog": ye("cancel", t), ye("close", t), i = r; break; case "iframe": case "object": case "embed": ye("load", t), i = r; break; case "video": case "audio": for (i = 0; i < ys.length; i++)ye(ys[i], t); i = r; break; case "source": ye("error", t), i = r; break; case "img": case "image": case "link": ye("error", t), ye("load", t), i = r; break; case "details": ye("toggle", t), i = r; break; case "input": dp(t, r), i = nu(t, r), ye("invalid", t); break; case "option": i = r; break; case "select": t._wrapperState = { wasMultiple: !!r.multiple }, i = Te({}, r, { value: void 0 }), ye("invalid", t); break; case "textarea": pp(t, r), i = su(t, r), ye("invalid", t); break; default: i = r }au(n, i), l = i; for (s in l) if (l.hasOwnProperty(s)) { var a = l[s]; s === "style" ? hg(t, a) : s === "dangerouslySetInnerHTML" ? (a = a ? a.__html : void 0, a != null && fg(t, a)) : s === "children" ? typeof a == "string" ? (n !== "textarea" || a !== "") && Ms(t, a) : typeof a == "number" && Ms(t, "" + a) : s !== "suppressContentEditableWarning" && s !== "suppressHydrationWarning" && s !== "autoFocus" && (Ds.hasOwnProperty(s) ? a != null && s === "onScroll" && ye("scroll", t) : a != null && kd(t, s, a, o)) } switch (n) { case "input": No(t), fp(t, r, !1); break; case "textarea": No(t), hp(t); break; case "option": r.value != null && t.setAttribute("value", "" + sr(r.value)); break; case "select": t.multiple = !!r.multiple, s = r.value, s != null ? vi(t, !!r.multiple, s, !1) : r.defaultValue != null && vi(t, !!r.multiple, r.defaultValue, !0); break; default: typeof i.onClick == "function" && (t.onclick = ja) }switch (n) { case "button": case "input": case "select": case "textarea": r = !!r.autoFocus; break e; case "img": r = !0; break e; default: r = !1 } } r && (e.flags |= 4) } e.ref !== null && (e.flags |= 512, e.flags |= 2097152) } return Ve(e), null; case 6: if (t && e.stateNode != null) Mv(t, e, t.memoizedProps, r); else { if (typeof r != "string" && e.stateNode === null) throw Error(M(166)); if (n = _r(qs.current), _r(Jt.current), Uo(e)) { if (r = e.stateNode, n = e.memoizedProps, r[Gt] = e, (s = r.nodeValue !== n) && (t = ht, t !== null)) switch (t.tag) { case 3: Fo(r.nodeValue, n, (t.mode & 1) !== 0); break; case 5: t.memoizedProps.suppressHydrationWarning !== !0 && Fo(r.nodeValue, n, (t.mode & 1) !== 0) }s && (e.flags |= 4) } else r = (n.nodeType === 9 ? n : n.ownerDocument).createTextNode(r), r[Gt] = e, e.stateNode = r } return Ve(e), null; case 13: if (we(Ee), r = e.memoizedState, t === null || t.memoizedState !== null && t.memoizedState.dehydrated !== null) { if (Se && pt !== null && e.mode & 1 && !(e.flags & 128)) tv(), Oi(), e.flags |= 98560, s = !1; else if (s = Uo(e), r !== null && r.dehydrated !== null) { if (t === null) { if (!s) throw Error(M(318)); if (s = e.memoizedState, s = s !== null ? s.dehydrated : null, !s) throw Error(M(317)); s[Gt] = e } else Oi(), !(e.flags & 128) && (e.memoizedState = null), e.flags |= 4; Ve(e), s = !1 } else At !== null && (Bu(At), At = null), s = !0; if (!s) return e.flags & 65536 ? e : null } return e.flags & 128 ? (e.lanes = n, e) : (r = r !== null, r !== (t !== null && t.memoizedState !== null) && r && (e.child.flags |= 8192, e.mode & 1 && (t === null || Ee.current & 1 ? je === 0 && (je = 3) : ff())), e.updateQueue !== null && (e.flags |= 4), Ve(e), null); case 4: return Ai(), Au(t, e), t === null && Vs(e.stateNode.containerInfo), Ve(e), null; case 10: return qd(e.type._context), Ve(e), null; case 17: return ot(e.type) && Aa(), Ve(e), null; case 19: if (we(Ee), s = e.memoizedState, s === null) return Ve(e), null; if (r = (e.flags & 128) !== 0, o = s.rendering, o === null) if (r) ss(s, !1); else { if (je !== 0 || t !== null && t.flags & 128) for (t = e.child; t !== null;) { if (o = $a(t), o !== null) { for (e.flags |= 128, ss(s, !1), r = o.updateQueue, r !== null && (e.updateQueue = r, e.flags |= 4), e.subtreeFlags = 0, r = n, n = e.child; n !== null;)s = n, t = r, s.flags &= 14680066, o = s.alternate, o === null ? (s.childLanes = 0, s.lanes = t, s.child = null, s.subtreeFlags = 0, s.memoizedProps = null, s.memoizedState = null, s.updateQueue = null, s.dependencies = null, s.stateNode = null) : (s.childLanes = o.childLanes, s.lanes = o.lanes, s.child = o.child, s.subtreeFlags = 0, s.deletions = null, s.memoizedProps = o.memoizedProps, s.memoizedState = o.memoizedState, s.updateQueue = o.updateQueue, s.type = o.type, t = o.dependencies, s.dependencies = t === null ? null : { lanes: t.lanes, firstContext: t.firstContext }), n = n.sibling; return ve(Ee, Ee.current & 1 | 2), e.child } t = t.sibling } s.tail !== null && Ie() > Di && (e.flags |= 128, r = !0, ss(s, !1), e.lanes = 4194304) } else { if (!r) if (t = $a(o), t !== null) { if (e.flags |= 128, r = !0, n = t.updateQueue, n !== null && (e.updateQueue = n, e.flags |= 4), ss(s, !0), s.tail === null && s.tailMode === "hidden" && !o.alternate && !Se) return Ve(e), null } else 2 * Ie() - s.renderingStartTime > Di && n !== 1073741824 && (e.flags |= 128, r = !0, ss(s, !1), e.lanes = 4194304); s.isBackwards ? (o.sibling = e.child, e.child = o) : (n = s.last, n !== null ? n.sibling = o : e.child = o, s.last = o) } return s.tail !== null ? (e = s.tail, s.rendering = e, s.tail = e.sibling, s.renderingStartTime = Ie(), e.sibling = null, n = Ee.current, ve(Ee, r ? n & 1 | 2 : n & 1), e) : (Ve(e), null); case 22: case 23: return df(), r = e.memoizedState !== null, t !== null && t.memoizedState !== null !== r && (e.flags |= 8192), r && e.mode & 1 ? ut & 1073741824 && (Ve(e), e.subtreeFlags & 6 && (e.flags |= 8192)) : Ve(e), null; case 24: return null; case 25: return null }throw Error(M(156, e.tag)) } function Ux(t, e) { switch (Vd(e), e.tag) { case 1: return ot(e.type) && Aa(), t = e.flags, t & 65536 ? (e.flags = t & -65537 | 128, e) : null; case 3: return Ai(), we(st), we(Ge), Zd(), t = e.flags, t & 65536 && !(t & 128) ? (e.flags = t & -65537 | 128, e) : null; case 5: return Qd(e), null; case 13: if (we(Ee), t = e.memoizedState, t !== null && t.dehydrated !== null) { if (e.alternate === null) throw Error(M(340)); Oi() } return t = e.flags, t & 65536 ? (e.flags = t & -65537 | 128, e) : null; case 19: return we(Ee), null; case 4: return Ai(), null; case 10: return qd(e.type._context), null; case 22: case 23: return df(), null; case 24: return null; default: return null } } var Bo = !1, We = !1, zx = typeof WeakSet == "function" ? WeakSet : Set, $ = null; function mi(t, e) { var n = t.ref; if (n !== null) if (typeof n == "function") try { n(null) } catch (r) { Pe(t, e, r) } else n.current = null } function Lu(t, e, n) { try { n() } catch (r) { Pe(t, e, r) } } var rh = !1; function $x(t, e) { if (yu = Na, t = Bg(), Bd(t)) { if ("selectionStart" in t) var n = { start: t.selectionStart, end: t.selectionEnd }; else e: { n = (n = t.ownerDocument) && n.defaultView || window; var r = n.getSelection && n.getSelection(); if (r && r.rangeCount !== 0) { n = r.anchorNode; var i = r.anchorOffset, s = r.focusNode; r = r.focusOffset; try { n.nodeType, s.nodeType } catch { n = null; break e } var o = 0, l = -1, a = -1, c = 0, u = 0, f = t, h = null; t: for (; ;) { for (var y; f !== n || i !== 0 && f.nodeType !== 3 || (l = o + i), f !== s || r !== 0 && f.nodeType !== 3 || (a = o + r), f.nodeType === 3 && (o += f.nodeValue.length), (y = f.firstChild) !== null;)h = f, f = y; for (; ;) { if (f === t) break t; if (h === n && ++c === i && (l = o), h === s && ++u === r && (a = o), (y = f.nextSibling) !== null) break; f = h, h = f.parentNode } f = y } n = l === -1 || a === -1 ? null : { start: l, end: a } } else n = null } n = n || { start: 0, end: 0 } } else n = null; for (wu = { focusedElem: t, selectionRange: n }, Na = !1, $ = e; $ !== null;)if (e = $, t = e.child, (e.subtreeFlags & 1028) !== 0 && t !== null) t.return = e, $ = t; else for (; $ !== null;) { e = $; try { var g = e.alternate; if (e.flags & 1024) switch (e.tag) { case 0: case 11: case 15: break; case 1: if (g !== null) { var w = g.memoizedProps, E = g.memoizedState, v = e.stateNode, p = v.getSnapshotBeforeUpdate(e.elementType === e.type ? w : Rt(e.type, w), E); v.__reactInternalSnapshotBeforeUpdate = p } break; case 3: var m = e.stateNode.containerInfo; m.nodeType === 1 ? m.textContent = "" : m.nodeType === 9 && m.documentElement && m.removeChild(m.documentElement); break; case 5: case 6: case 4: case 17: break; default: throw Error(M(163)) } } catch (S) { Pe(e, e.return, S) } if (t = e.sibling, t !== null) { t.return = e.return, $ = t; break } $ = e.return } return g = rh, rh = !1, g } function ks(t, e, n) { var r = e.updateQueue; if (r = r !== null ? r.lastEffect : null, r !== null) { var i = r = r.next; do { if ((i.tag & t) === t) { var s = i.destroy; i.destroy = void 0, s !== void 0 && Lu(e, n, s) } i = i.next } while (i !== r) } } function Tl(t, e) { if (e = e.updateQueue, e = e !== null ? e.lastEffect : null, e !== null) { var n = e = e.next; do { if ((n.tag & t) === t) { var r = n.create; n.destroy = r() } n = n.next } while (n !== e) } } function Du(t) { var e = t.ref; if (e !== null) { var n = t.stateNode; switch (t.tag) { case 5: t = n; break; default: t = n }typeof e == "function" ? e(t) : e.current = t } } function Fv(t) { var e = t.alternate; e !== null && (t.alternate = null, Fv(e)), t.child = null, t.deletions = null, t.sibling = null, t.tag === 5 && (e = t.stateNode, e !== null && (delete e[Gt], delete e[Gs], delete e[Eu], delete e[bx], delete e[Tx])), t.stateNode = null, t.return = null, t.dependencies = null, t.memoizedProps = null, t.memoizedState = null, t.pendingProps = null, t.stateNode = null, t.updateQueue = null } function Uv(t) { return t.tag === 5 || t.tag === 3 || t.tag === 4 } function ih(t) { e: for (; ;) { for (; t.sibling === null;) { if (t.return === null || Uv(t.return)) return null; t = t.return } for (t.sibling.return = t.return, t = t.sibling; t.tag !== 5 && t.tag !== 6 && t.tag !== 18;) { if (t.flags & 2 || t.child === null || t.tag === 4) continue e; t.child.return = t, t = t.child } if (!(t.flags & 2)) return t.stateNode } } function Mu(t, e, n) { var r = t.tag; if (r === 5 || r === 6) t = t.stateNode, e ? n.nodeType === 8 ? n.parentNode.insertBefore(t, e) : n.insertBefore(t, e) : (n.nodeType === 8 ? (e = n.parentNode, e.insertBefore(t, n)) : (e = n, e.appendChild(t)), n = n._reactRootContainer, n != null || e.onclick !== null || (e.onclick = ja)); else if (r !== 4 && (t = t.child, t !== null)) for (Mu(t, e, n), t = t.sibling; t !== null;)Mu(t, e, n), t = t.sibling } function Fu(t, e, n) { var r = t.tag; if (r === 5 || r === 6) t = t.stateNode, e ? n.insertBefore(t, e) : n.appendChild(t); else if (r !== 4 && (t = t.child, t !== null)) for (Fu(t, e, n), t = t.sibling; t !== null;)Fu(t, e, n), t = t.sibling } var Ue = null, Ot = !1; function On(t, e, n) { for (n = n.child; n !== null;)zv(t, e, n), n = n.sibling } function zv(t, e, n) { if (Yt && typeof Yt.onCommitFiberUnmount == "function") try { Yt.onCommitFiberUnmount(gl, n) } catch { } switch (n.tag) { case 5: We || mi(n, e); case 6: var r = Ue, i = Ot; Ue = null, On(t, e, n), Ue = r, Ot = i, Ue !== null && (Ot ? (t = Ue, n = n.stateNode, t.nodeType === 8 ? t.parentNode.removeChild(n) : t.removeChild(n)) : Ue.removeChild(n.stateNode)); break; case 18: Ue !== null && (Ot ? (t = Ue, n = n.stateNode, t.nodeType === 8 ? hc(t.parentNode, n) : t.nodeType === 1 && hc(t, n), $s(t)) : hc(Ue, n.stateNode)); break; case 4: r = Ue, i = Ot, Ue = n.stateNode.containerInfo, Ot = !0, On(t, e, n), Ue = r, Ot = i; break; case 0: case 11: case 14: case 15: if (!We && (r = n.updateQueue, r !== null && (r = r.lastEffect, r !== null))) { i = r = r.next; do { var s = i, o = s.destroy; s = s.tag, o !== void 0 && (s & 2 || s & 4) && Lu(n, e, o), i = i.next } while (i !== r) } On(t, e, n); break; case 1: if (!We && (mi(n, e), r = n.stateNode, typeof r.componentWillUnmount == "function")) try { r.props = n.memoizedProps, r.state = n.memoizedState, r.componentWillUnmount() } catch (l) { Pe(n, e, l) } On(t, e, n); break; case 21: On(t, e, n); break; case 22: n.mode & 1 ? (We = (r = We) || n.memoizedState !== null, On(t, e, n), We = r) : On(t, e, n); break; default: On(t, e, n) } } function sh(t) { var e = t.updateQueue; if (e !== null) { t.updateQueue = null; var n = t.stateNode; n === null && (n = t.stateNode = new zx), e.forEach(function (r) { var i = Jx.bind(null, t, r); n.has(r) || (n.add(r), r.then(i, i)) }) } } function Nt(t, e) { var n = e.deletions; if (n !== null) for (var r = 0; r < n.length; r++) { var i = n[r]; try { var s = t, o = e, l = o; e: for (; l !== null;) { switch (l.tag) { case 5: Ue = l.stateNode, Ot = !1; break e; case 3: Ue = l.stateNode.containerInfo, Ot = !0; break e; case 4: Ue = l.stateNode.containerInfo, Ot = !0; break e }l = l.return } if (Ue === null) throw Error(M(160)); zv(s, o, i), Ue = null, Ot = !1; var a = i.alternate; a !== null && (a.return = null), i.return = null } catch (c) { Pe(i, e, c) } } if (e.subtreeFlags & 12854) for (e = e.child; e !== null;)$v(e, t), e = e.sibling } function $v(t, e) { var n = t.alternate, r = t.flags; switch (t.tag) { case 0: case 11: case 14: case 15: if (Nt(e, t), Vt(t), r & 4) { try { ks(3, t, t.return), Tl(3, t) } catch (w) { Pe(t, t.return, w) } try { ks(5, t, t.return) } catch (w) { Pe(t, t.return, w) } } break; case 1: Nt(e, t), Vt(t), r & 512 && n !== null && mi(n, n.return); break; case 5: if (Nt(e, t), Vt(t), r & 512 && n !== null && mi(n, n.return), t.flags & 32) { var i = t.stateNode; try { Ms(i, "") } catch (w) { Pe(t, t.return, w) } } if (r & 4 && (i = t.stateNode, i != null)) { var s = t.memoizedProps, o = n !== null ? n.memoizedProps : s, l = t.type, a = t.updateQueue; if (t.updateQueue = null, a !== null) try { l === "input" && s.type === "radio" && s.name != null && cg(i, s), lu(l, o); var c = lu(l, s); for (o = 0; o < a.length; o += 2) { var u = a[o], f = a[o + 1]; u === "style" ? hg(i, f) : u === "dangerouslySetInnerHTML" ? fg(i, f) : u === "children" ? Ms(i, f) : kd(i, u, f, c) } switch (l) { case "input": ru(i, s); break; case "textarea": ug(i, s); break; case "select": var h = i._wrapperState.wasMultiple; i._wrapperState.wasMultiple = !!s.multiple; var y = s.value; y != null ? vi(i, !!s.multiple, y, !1) : h !== !!s.multiple && (s.defaultValue != null ? vi(i, !!s.multiple, s.defaultValue, !0) : vi(i, !!s.multiple, s.multiple ? [] : "", !1)) }i[Gs] = s } catch (w) { Pe(t, t.return, w) } } break; case 6: if (Nt(e, t), Vt(t), r & 4) { if (t.stateNode === null) throw Error(M(162)); i = t.stateNode, s = t.memoizedProps; try { i.nodeValue = s } catch (w) { Pe(t, t.return, w) } } break; case 3: if (Nt(e, t), Vt(t), r & 4 && n !== null && n.memoizedState.isDehydrated) try { $s(e.containerInfo) } catch (w) { Pe(t, t.return, w) } break; case 4: Nt(e, t), Vt(t); break; case 13: Nt(e, t), Vt(t), i = t.child, i.flags & 8192 && (s = i.memoizedState !== null, i.stateNode.isHidden = s, !s || i.alternate !== null && i.alternate.memoizedState !== null || (cf = Ie())), r & 4 && sh(t); break; case 22: if (u = n !== null && n.memoizedState !== null, t.mode & 1 ? (We = (c = We) || u, Nt(e, t), We = c) : Nt(e, t), Vt(t), r & 8192) { if (c = t.memoizedState !== null, (t.stateNode.isHidden = c) && !u && t.mode & 1) for ($ = t, u = t.child; u !== null;) { for (f = $ = u; $ !== null;) { switch (h = $, y = h.child, h.tag) { case 0: case 11: case 14: case 15: ks(4, h, h.return); break; case 1: mi(h, h.return); var g = h.stateNode; if (typeof g.componentWillUnmount == "function") { r = h, n = h.return; try { e = r, g.props = e.memoizedProps, g.state = e.memoizedState, g.componentWillUnmount() } catch (w) { Pe(r, n, w) } } break; case 5: mi(h, h.return); break; case 22: if (h.memoizedState !== null) { ah(f); continue } }y !== null ? (y.return = h, $ = y) : ah(f) } u = u.sibling } e: for (u = null, f = t; ;) { if (f.tag === 5) { if (u === null) { u = f; try { i = f.stateNode, c ? (s = i.style, typeof s.setProperty == "function" ? s.setProperty("display", "none", "important") : s.display = "none") : (l = f.stateNode, a = f.memoizedProps.style, o = a != null && a.hasOwnProperty("display") ? a.display : null, l.style.display = pg("display", o)) } catch (w) { Pe(t, t.return, w) } } } else if (f.tag === 6) { if (u === null) try { f.stateNode.nodeValue = c ? "" : f.memoizedProps } catch (w) { Pe(t, t.return, w) } } else if ((f.tag !== 22 && f.tag !== 23 || f.memoizedState === null || f === t) && f.child !== null) { f.child.return = f, f = f.child; continue } if (f === t) break e; for (; f.sibling === null;) { if (f.return === null || f.return === t) break e; u === f && (u = null), f = f.return } u === f && (u = null), f.sibling.return = f.return, f = f.sibling } } break; case 19: Nt(e, t), Vt(t), r & 4 && sh(t); break; case 21: break; default: Nt(e, t), Vt(t) } } function Vt(t) { var e = t.flags; if (e & 2) { try { e: { for (var n = t.return; n !== null;) { if (Uv(n)) { var r = n; break e } n = n.return } throw Error(M(160)) } switch (r.tag) { case 5: var i = r.stateNode; r.flags & 32 && (Ms(i, ""), r.flags &= -33); var s = ih(t); Fu(t, s, i); break; case 3: case 4: var o = r.stateNode.containerInfo, l = ih(t); Mu(t, l, o); break; default: throw Error(M(161)) } } catch (a) { Pe(t, t.return, a) } t.flags &= -3 } e & 4096 && (t.flags &= -4097) } function Bx(t, e, n) { $ = t, Bv(t) } function Bv(t, e, n) { for (var r = (t.mode & 1) !== 0; $ !== null;) { var i = $, s = i.child; if (i.tag === 22 && r) { var o = i.memoizedState !== null || Bo; if (!o) { var l = i.alternate, a = l !== null && l.memoizedState !== null || We; l = Bo; var c = We; if (Bo = o, (We = a) && !c) for ($ = i; $ !== null;)o = $, a = o.child, o.tag === 22 && o.memoizedState !== null ? lh(i) : a !== null ? (a.return = o, $ = a) : lh(i); for (; s !== null;)$ = s, Bv(s), s = s.sibling; $ = i, Bo = l, We = c } oh(t) } else i.subtreeFlags & 8772 && s !== null ? (s.return = i, $ = s) : oh(t) } } function oh(t) { for (; $ !== null;) { var e = $; if (e.flags & 8772) { var n = e.alternate; try { if (e.flags & 8772) switch (e.tag) { case 0: case 11: case 15: We || Tl(5, e); break; case 1: var r = e.stateNode; if (e.flags & 4 && !We) if (n === null) r.componentDidMount(); else { var i = e.elementType === e.type ? n.memoizedProps : Rt(e.type, n.memoizedProps); r.componentDidUpdate(i, n.memoizedState, r.__reactInternalSnapshotBeforeUpdate) } var s = e.updateQueue; s !== null && Vp(e, s, r); break; case 3: var o = e.updateQueue; if (o !== null) { if (n = null, e.child !== null) switch (e.child.tag) { case 5: n = e.child.stateNode; break; case 1: n = e.child.stateNode }Vp(e, o, n) } break; case 5: var l = e.stateNode; if (n === null && e.flags & 4) { n = l; var a = e.memoizedProps; switch (e.type) { case "button": case "input": case "select": case "textarea": a.autoFocus && n.focus(); break; case "img": a.src && (n.src = a.src) } } break; case 6: break; case 4: break; case 12: break; case 13: if (e.memoizedState === null) { var c = e.alternate; if (c !== null) { var u = c.memoizedState; if (u !== null) { var f = u.dehydrated; f !== null && $s(f) } } } break; case 19: case 17: case 21: case 22: case 23: case 25: break; default: throw Error(M(163)) }We || e.flags & 512 && Du(e) } catch (h) { Pe(e, e.return, h) } } if (e === t) { $ = null; break } if (n = e.sibling, n !== null) { n.return = e.return, $ = n; break } $ = e.return } } function ah(t) { for (; $ !== null;) { var e = $; if (e === t) { $ = null; break } var n = e.sibling; if (n !== null) { n.return = e.return, $ = n; break } $ = e.return } } function lh(t) { for (; $ !== null;) { var e = $; try { switch (e.tag) { case 0: case 11: case 15: var n = e.return; try { Tl(4, e) } catch (a) { Pe(e, n, a) } break; case 1: var r = e.stateNode; if (typeof r.componentDidMount == "function") { var i = e.return; try { r.componentDidMount() } catch (a) { Pe(e, i, a) } } var s = e.return; try { Du(e) } catch (a) { Pe(e, s, a) } break; case 5: var o = e.return; try { Du(e) } catch (a) { Pe(e, o, a) } } } catch (a) { Pe(e, e.return, a) } if (e === t) { $ = null; break } var l = e.sibling; if (l !== null) { l.return = e.return, $ = l; break } $ = e.return } } var Hx = Math.ceil, Va = _n.ReactCurrentDispatcher, af = _n.ReactCurrentOwner, Ct = _n.ReactCurrentBatchConfig, se = 0, De = null, Re = null, $e = 0, ut = 0, gi = lr(0), je = 0, Qs = null, Mr = 0, Cl = 0, lf = 0, Ns = null, rt = null, cf = 0, Di = 1 / 0, on = null, Wa = !1, Uu = null, er = null, Ho = !1, Gn = null, Ga = 0, Rs = 0, zu = null, aa = -1, la = 0; function Qe() { return se & 6 ? Ie() : aa !== -1 ? aa : aa = Ie() } function tr(t) { return t.mode & 1 ? se & 2 && $e !== 0 ? $e & -$e : _x.transition !== null ? (la === 0 && (la = _g()), la) : (t = ue, t !== 0 || (t = window.event, t = t === void 0 ? 16 : jg(t.type)), t) : 1 } function Ft(t, e, n, r) { if (50 < Rs) throw Rs = 0, zu = null, Error(M(185)); oo(t, n, r), (!(se & 2) || t !== De) && (t === De && (!(se & 2) && (Cl |= n), je === 4 && zn(t, $e)), at(t, r), n === 1 && se === 0 && !(e.mode & 1) && (Di = Ie() + 500, Sl && cr())) } function at(t, e) { var n = t.callbackNode; _1(t, e); var r = ka(t, t === De ? $e : 0); if (r === 0) n !== null && vp(n), t.callbackNode = null, t.callbackPriority = 0; else if (e = r & -r, t.callbackPriority !== e) { if (n != null && vp(n), e === 1) t.tag === 0 ? Cx(ch.bind(null, t)) : Qg(ch.bind(null, t)), Sx(function () { !(se & 6) && cr() }), n = null; else { switch (Pg(r)) { case 1: n = Ad; break; case 4: n = Tg; break; case 16: n = Ia; break; case 536870912: n = Cg; break; default: n = Ia }n = Jv(n, Hv.bind(null, t)) } t.callbackPriority = e, t.callbackNode = n } } function Hv(t, e) { if (aa = -1, la = 0, se & 6) throw Error(M(327)); var n = t.callbackNode; if (Ei() && t.callbackNode !== n) return null; var r = ka(t, t === De ? $e : 0); if (r === 0) return null; if (r & 30 || r & t.expiredLanes || e) e = Ka(t, r); else { e = r; var i = se; se |= 2; var s = Wv(); (De !== t || $e !== e) && (on = null, Di = Ie() + 500, Rr(t, e)); do try { Gx(); break } catch (l) { Vv(t, l) } while (!0); Kd(), Va.current = s, se = i, Re !== null ? e = 0 : (De = null, $e = 0, e = je) } if (e !== 0) { if (e === 2 && (i = pu(t), i !== 0 && (r = i, e = $u(t, i))), e === 1) throw n = Qs, Rr(t, 0), zn(t, r), at(t, Ie()), n; if (e === 6) zn(t, r); else { if (i = t.current.alternate, !(r & 30) && !Vx(i) && (e = Ka(t, r), e === 2 && (s = pu(t), s !== 0 && (r = s, e = $u(t, s))), e === 1)) throw n = Qs, Rr(t, 0), zn(t, r), at(t, Ie()), n; switch (t.finishedWork = i, t.finishedLanes = r, e) { case 0: case 1: throw Error(M(345)); case 2: xr(t, rt, on); break; case 3: if (zn(t, r), (r & 130023424) === r && (e = cf + 500 - Ie(), 10 < e)) { if (ka(t, 0) !== 0) break; if (i = t.suspendedLanes, (i & r) !== r) { Qe(), t.pingedLanes |= t.suspendedLanes & i; break } t.timeoutHandle = Su(xr.bind(null, t, rt, on), e); break } xr(t, rt, on); break; case 4: if (zn(t, r), (r & 4194240) === r) break; for (e = t.eventTimes, i = -1; 0 < r;) { var o = 31 - Mt(r); s = 1 << o, o = e[o], o > i && (i = o), r &= ~s } if (r = i, r = Ie() - r, r = (120 > r ? 120 : 480 > r ? 480 : 1080 > r ? 1080 : 1920 > r ? 1920 : 3e3 > r ? 3e3 : 4320 > r ? 4320 : 1960 * Hx(r / 1960)) - r, 10 < r) { t.timeoutHandle = Su(xr.bind(null, t, rt, on), r); break } xr(t, rt, on); break; case 5: xr(t, rt, on); break; default: throw Error(M(329)) } } } return at(t, Ie()), t.callbackNode === n ? Hv.bind(null, t) : null } function $u(t, e) { var n = Ns; return t.current.memoizedState.isDehydrated && (Rr(t, e).flags |= 256), t = Ka(t, e), t !== 2 && (e = rt, rt = n, e !== null && Bu(e)), t } function Bu(t) { rt === null ? rt = t : rt.push.apply(rt, t) } function Vx(t) { for (var e = t; ;) { if (e.flags & 16384) { var n = e.updateQueue; if (n !== null && (n = n.stores, n !== null)) for (var r = 0; r < n.length; r++) { var i = n[r], s = i.getSnapshot; i = i.value; try { if (!zt(s(), i)) return !1 } catch { return !1 } } } if (n = e.child, e.subtreeFlags & 16384 && n !== null) n.return = e, e = n; else { if (e === t) break; for (; e.sibling === null;) { if (e.return === null || e.return === t) return !0; e = e.return } e.sibling.return = e.return, e = e.sibling } } return !0 } function zn(t, e) { for (e &= ~lf, e &= ~Cl, t.suspendedLanes |= e, t.pingedLanes &= ~e, t = t.expirationTimes; 0 < e;) { var n = 31 - Mt(e), r = 1 << n; t[n] = -1, e &= ~r } } function ch(t) { if (se & 6) throw Error(M(327)); Ei(); var e = ka(t, 0); if (!(e & 1)) return at(t, Ie()), null; var n = Ka(t, e); if (t.tag !== 0 && n === 2) { var r = pu(t); r !== 0 && (e = r, n = $u(t, r)) } if (n === 1) throw n = Qs, Rr(t, 0), zn(t, e), at(t, Ie()), n; if (n === 6) throw Error(M(345)); return t.finishedWork = t.current.alternate, t.finishedLanes = e, xr(t, rt, on), at(t, Ie()), null } function uf(t, e) { var n = se; se |= 1; try { return t(e) } finally { se = n, se === 0 && (Di = Ie() + 500, Sl && cr()) } } function Fr(t) { Gn !== null && Gn.tag === 0 && !(se & 6) && Ei(); var e = se; se |= 1; var n = Ct.transition, r = ue; try { if (Ct.transition = null, ue = 1, t) return t() } finally { ue = r, Ct.transition = n, se = e, !(se & 6) && cr() } } function df() { ut = gi.current, we(gi) } function Rr(t, e) { t.finishedWork = null, t.finishedLanes = 0; var n = t.timeoutHandle; if (n !== -1 && (t.timeoutHandle = -1, xx(n)), Re !== null) for (n = Re.return; n !== null;) { var r = n; switch (Vd(r), r.tag) { case 1: r = r.type.childContextTypes, r != null && Aa(); break; case 3: Ai(), we(st), we(Ge), Zd(); break; case 5: Qd(r); break; case 4: Ai(); break; case 13: we(Ee); break; case 19: we(Ee); break; case 10: qd(r.type._context); break; case 22: case 23: df() }n = n.return } if (De = t, Re = t = nr(t.current, null), $e = ut = e, je = 0, Qs = null, lf = Cl = Mr = 0, rt = Ns = null, Cr !== null) { for (e = 0; e < Cr.length; e++)if (n = Cr[e], r = n.interleaved, r !== null) { n.interleaved = null; var i = r.next, s = n.pending; if (s !== null) { var o = s.next; s.next = i, r.next = o } n.pending = r } Cr = null } return t } function Vv(t, e) { do { var n = Re; try { if (Kd(), ia.current = Ha, Ba) { for (var r = be.memoizedState; r !== null;) { var i = r.queue; i !== null && (i.pending = null), r = r.next } Ba = !1 } if (Dr = 0, Le = Oe = be = null, Is = !1, Ys = 0, af.current = null, n === null || n.return === null) { je = 1, Qs = e, Re = null; break } e: { var s = t, o = n.return, l = n, a = e; if (e = $e, l.flags |= 32768, a !== null && typeof a == "object" && typeof a.then == "function") { var c = a, u = l, f = u.tag; if (!(u.mode & 1) && (f === 0 || f === 11 || f === 15)) { var h = u.alternate; h ? (u.updateQueue = h.updateQueue, u.memoizedState = h.memoizedState, u.lanes = h.lanes) : (u.updateQueue = null, u.memoizedState = null) } var y = Jp(o); if (y !== null) { y.flags &= -257, Xp(y, o, l, s, e), y.mode & 1 && Yp(s, c, e), e = y, a = c; var g = e.updateQueue; if (g === null) { var w = new Set; w.add(a), e.updateQueue = w } else g.add(a); break e } else { if (!(e & 1)) { Yp(s, c, e), ff(); break e } a = Error(M(426)) } } else if (Se && l.mode & 1) { var E = Jp(o); if (E !== null) { !(E.flags & 65536) && (E.flags |= 256), Xp(E, o, l, s, e), Wd(Li(a, l)); break e } } s = a = Li(a, l), je !== 4 && (je = 2), Ns === null ? Ns = [s] : Ns.push(s), s = o; do { switch (s.tag) { case 3: s.flags |= 65536, e &= -e, s.lanes |= e; var v = Pv(s, a, e); Hp(s, v); break e; case 1: l = a; var p = s.type, m = s.stateNode; if (!(s.flags & 128) && (typeof p.getDerivedStateFromError == "function" || m !== null && typeof m.componentDidCatch == "function" && (er === null || !er.has(m)))) { s.flags |= 65536, e &= -e, s.lanes |= e; var S = Iv(s, l, e); Hp(s, S); break e } }s = s.return } while (s !== null) } Kv(n) } catch (T) { e = T, Re === n && n !== null && (Re = n = n.return); continue } break } while (!0) } function Wv() { var t = Va.current; return Va.current = Ha, t === null ? Ha : t } function ff() { (je === 0 || je === 3 || je === 2) && (je = 4), De === null || !(Mr & 268435455) && !(Cl & 268435455) || zn(De, $e) } function Ka(t, e) { var n = se; se |= 2; var r = Wv(); (De !== t || $e !== e) && (on = null, Rr(t, e)); do try { Wx(); break } catch (i) { Vv(t, i) } while (!0); if (Kd(), se = n, Va.current = r, Re !== null) throw Error(M(261)); return De = null, $e = 0, je } function Wx() { for (; Re !== null;)Gv(Re) } function Gx() { for (; Re !== null && !v1();)Gv(Re) } function Gv(t) { var e = Yv(t.alternate, t, ut); t.memoizedProps = t.pendingProps, e === null ? Kv(t) : Re = e, af.current = null } function Kv(t) { var e = t; do { var n = e.alternate; if (t = e.return, e.flags & 32768) { if (n = Ux(n, e), n !== null) { n.flags &= 32767, Re = n; return } if (t !== null) t.flags |= 32768, t.subtreeFlags = 0, t.deletions = null; else { je = 6, Re = null; return } } else if (n = Fx(n, e, ut), n !== null) { Re = n; return } if (e = e.sibling, e !== null) { Re = e; return } Re = e = t } while (e !== null); je === 0 && (je = 5) } function xr(t, e, n) { var r = ue, i = Ct.transition; try { Ct.transition = null, ue = 1, Kx(t, e, n, r) } finally { Ct.transition = i, ue = r } return null } function Kx(t, e, n, r) { do Ei(); while (Gn !== null); if (se & 6) throw Error(M(327)); n = t.finishedWork; var i = t.finishedLanes; if (n === null) return null; if (t.finishedWork = null, t.finishedLanes = 0, n === t.current) throw Error(M(177)); t.callbackNode = null, t.callbackPriority = 0; var s = n.lanes | n.childLanes; if (P1(t, s), t === De && (Re = De = null, $e = 0), !(n.subtreeFlags & 2064) && !(n.flags & 2064) || Ho || (Ho = !0, Jv(Ia, function () { return Ei(), null })), s = (n.flags & 15990) !== 0, n.subtreeFlags & 15990 || s) { s = Ct.transition, Ct.transition = null; var o = ue; ue = 1; var l = se; se |= 4, af.current = null, $x(t, n), $v(n, t), px(wu), Na = !!yu, wu = yu = null, t.current = n, Bx(n), y1(), se = l, ue = o, Ct.transition = s } else t.current = n; if (Ho && (Ho = !1, Gn = t, Ga = i), s = t.pendingLanes, s === 0 && (er = null), S1(n.stateNode), at(t, Ie()), e !== null) for (r = t.onRecoverableError, n = 0; n < e.length; n++)i = e[n], r(i.value, { componentStack: i.stack, digest: i.digest }); if (Wa) throw Wa = !1, t = Uu, Uu = null, t; return Ga & 1 && t.tag !== 0 && Ei(), s = t.pendingLanes, s & 1 ? t === zu ? Rs++ : (Rs = 0, zu = t) : Rs = 0, cr(), null } function Ei() { if (Gn !== null) { var t = Pg(Ga), e = Ct.transition, n = ue; try { if (Ct.transition = null, ue = 16 > t ? 16 : t, Gn === null) var r = !1; else { if (t = Gn, Gn = null, Ga = 0, se & 6) throw Error(M(331)); var i = se; for (se |= 4, $ = t.current; $ !== null;) { var s = $, o = s.child; if ($.flags & 16) { var l = s.deletions; if (l !== null) { for (var a = 0; a < l.length; a++) { var c = l[a]; for ($ = c; $ !== null;) { var u = $; switch (u.tag) { case 0: case 11: case 15: ks(8, u, s) }var f = u.child; if (f !== null) f.return = u, $ = f; else for (; $ !== null;) { u = $; var h = u.sibling, y = u.return; if (Fv(u), u === c) { $ = null; break } if (h !== null) { h.return = y, $ = h; break } $ = y } } } var g = s.alternate; if (g !== null) { var w = g.child; if (w !== null) { g.child = null; do { var E = w.sibling; w.sibling = null, w = E } while (w !== null) } } $ = s } } if (s.subtreeFlags & 2064 && o !== null) o.return = s, $ = o; else e: for (; $ !== null;) { if (s = $, s.flags & 2048) switch (s.tag) { case 0: case 11: case 15: ks(9, s, s.return) }var v = s.sibling; if (v !== null) { v.return = s.return, $ = v; break e } $ = s.return } } var p = t.current; for ($ = p; $ !== null;) { o = $; var m = o.child; if (o.subtreeFlags & 2064 && m !== null) m.return = o, $ = m; else e: for (o = p; $ !== null;) { if (l = $, l.flags & 2048) try { switch (l.tag) { case 0: case 11: case 15: Tl(9, l) } } catch (T) { Pe(l, l.return, T) } if (l === o) { $ = null; break e } var S = l.sibling; if (S !== null) { S.return = l.return, $ = S; break e } $ = l.return } } if (se = i, cr(), Yt && typeof Yt.onPostCommitFiberRoot == "function") try { Yt.onPostCommitFiberRoot(gl, t) } catch { } r = !0 } return r } finally { ue = n, Ct.transition = e } } return !1 } function uh(t, e, n) { e = Li(n, e), e = Pv(t, e, 1), t = Zn(t, e, 1), e = Qe(), t !== null && (oo(t, 1, e), at(t, e)) } function Pe(t, e, n) { if (t.tag === 3) uh(t, t, n); else for (; e !== null;) { if (e.tag === 3) { uh(e, t, n); break } else if (e.tag === 1) { var r = e.stateNode; if (typeof e.type.getDerivedStateFromError == "function" || typeof r.componentDidCatch == "function" && (er === null || !er.has(r))) { t = Li(n, t), t = Iv(e, t, 1), e = Zn(e, t, 1), t = Qe(), e !== null && (oo(e, 1, t), at(e, t)); break } } e = e.return } } function qx(t, e, n) { var r = t.pingCache; r !== null && r.delete(e), e = Qe(), t.pingedLanes |= t.suspendedLanes & n, De === t && ($e & n) === n && (je === 4 || je === 3 && ($e & 130023424) === $e && 500 > Ie() - cf ? Rr(t, 0) : lf |= n), at(t, e) } function qv(t, e) { e === 0 && (t.mode & 1 ? (e = jo, jo <<= 1, !(jo & 130023424) && (jo = 4194304)) : e = 1); var n = Qe(); t = xn(t, e), t !== null && (oo(t, e, n), at(t, n)) } function Yx(t) { var e = t.memoizedState, n = 0; e !== null && (n = e.retryLane), qv(t, n) } function Jx(t, e) { var n = 0; switch (t.tag) { case 13: var r = t.stateNode, i = t.memoizedState; i !== null && (n = i.retryLane); break; case 19: r = t.stateNode; break; default: throw Error(M(314)) }r !== null && r.delete(e), qv(t, n) } var Yv; Yv = function (t, e, n) { if (t !== null) if (t.memoizedProps !== e.pendingProps || st.current) it = !0; else { if (!(t.lanes & n) && !(e.flags & 128)) return it = !1, Mx(t, e, n); it = !!(t.flags & 131072) } else it = !1, Se && e.flags & 1048576 && Zg(e, Ma, e.index); switch (e.lanes = 0, e.tag) { case 2: var r = e.type; oa(t, e), t = e.pendingProps; var i = Ri(e, Ge.current); Si(e, n), i = tf(null, e, r, t, i, n); var s = nf(); return e.flags |= 1, typeof i == "object" && i !== null && typeof i.render == "function" && i.$$typeof === void 0 ? (e.tag = 1, e.memoizedState = null, e.updateQueue = null, ot(r) ? (s = !0, La(e)) : s = !1, e.memoizedState = i.state !== null && i.state !== void 0 ? i.state : null, Jd(e), i.updater = bl, e.stateNode = i, i._reactInternals = e, Iu(e, r, t, n), e = Ru(null, e, r, !0, s, n)) : (e.tag = 0, Se && s && Hd(e), Xe(null, e, i, n), e = e.child), e; case 16: r = e.elementType; e: { switch (oa(t, e), t = e.pendingProps, i = r._init, r = i(r._payload), e.type = r, i = e.tag = Qx(r), t = Rt(r, t), i) { case 0: e = Nu(null, e, r, t, n); break e; case 1: e = eh(null, e, r, t, n); break e; case 11: e = Qp(null, e, r, t, n); break e; case 14: e = Zp(null, e, r, Rt(r.type, t), n); break e }throw Error(M(306, r, "")) } return e; case 0: return r = e.type, i = e.pendingProps, i = e.elementType === r ? i : Rt(r, i), Nu(t, e, r, i, n); case 1: return r = e.type, i = e.pendingProps, i = e.elementType === r ? i : Rt(r, i), eh(t, e, r, i, n); case 3: e: { if (Ov(e), t === null) throw Error(M(387)); r = e.pendingProps, s = e.memoizedState, i = s.element, sv(t, e), za(e, r, null, n); var o = e.memoizedState; if (r = o.element, s.isDehydrated) if (s = { element: r, isDehydrated: !1, cache: o.cache, pendingSuspenseBoundaries: o.pendingSuspenseBoundaries, transitions: o.transitions }, e.updateQueue.baseState = s, e.memoizedState = s, e.flags & 256) { i = Li(Error(M(423)), e), e = th(t, e, r, n, i); break e } else if (r !== i) { i = Li(Error(M(424)), e), e = th(t, e, r, n, i); break e } else for (pt = Qn(e.stateNode.containerInfo.firstChild), ht = e, Se = !0, At = null, n = rv(e, null, r, n), e.child = n; n;)n.flags = n.flags & -3 | 4096, n = n.sibling; else { if (Oi(), r === i) { e = Sn(t, e, n); break e } Xe(t, e, r, n) } e = e.child } return e; case 5: return ov(e), t === null && Cu(e), r = e.type, i = e.pendingProps, s = t !== null ? t.memoizedProps : null, o = i.children, xu(r, i) ? o = null : s !== null && xu(r, s) && (e.flags |= 32), Rv(t, e), Xe(t, e, o, n), e.child; case 6: return t === null && Cu(e), null; case 13: return jv(t, e, n); case 4: return Xd(e, e.stateNode.containerInfo), r = e.pendingProps, t === null ? e.child = ji(e, null, r, n) : Xe(t, e, r, n), e.child; case 11: return r = e.type, i = e.pendingProps, i = e.elementType === r ? i : Rt(r, i), Qp(t, e, r, i, n); case 7: return Xe(t, e, e.pendingProps, n), e.child; case 8: return Xe(t, e, e.pendingProps.children, n), e.child; case 12: return Xe(t, e, e.pendingProps.children, n), e.child; case 10: e: { if (r = e.type._context, i = e.pendingProps, s = e.memoizedProps, o = i.value, ve(Fa, r._currentValue), r._currentValue = o, s !== null) if (zt(s.value, o)) { if (s.children === i.children && !st.current) { e = Sn(t, e, n); break e } } else for (s = e.child, s !== null && (s.return = e); s !== null;) { var l = s.dependencies; if (l !== null) { o = s.child; for (var a = l.firstContext; a !== null;) { if (a.context === r) { if (s.tag === 1) { a = hn(-1, n & -n), a.tag = 2; var c = s.updateQueue; if (c !== null) { c = c.shared; var u = c.pending; u === null ? a.next = a : (a.next = u.next, u.next = a), c.pending = a } } s.lanes |= n, a = s.alternate, a !== null && (a.lanes |= n), _u(s.return, n, e), l.lanes |= n; break } a = a.next } } else if (s.tag === 10) o = s.type === e.type ? null : s.child; else if (s.tag === 18) { if (o = s.return, o === null) throw Error(M(341)); o.lanes |= n, l = o.alternate, l !== null && (l.lanes |= n), _u(o, n, e), o = s.sibling } else o = s.child; if (o !== null) o.return = s; else for (o = s; o !== null;) { if (o === e) { o = null; break } if (s = o.sibling, s !== null) { s.return = o.return, o = s; break } o = o.return } s = o } Xe(t, e, i.children, n), e = e.child } return e; case 9: return i = e.type, r = e.pendingProps.children, Si(e, n), i = _t(i), r = r(i), e.flags |= 1, Xe(t, e, r, n), e.child; case 14: return r = e.type, i = Rt(r, e.pendingProps), i = Rt(r.type, i), Zp(t, e, r, i, n); case 15: return kv(t, e, e.type, e.pendingProps, n); case 17: return r = e.type, i = e.pendingProps, i = e.elementType === r ? i : Rt(r, i), oa(t, e), e.tag = 1, ot(r) ? (t = !0, La(e)) : t = !1, Si(e, n), _v(e, r, i), Iu(e, r, i, n), Ru(null, e, r, !0, t, n); case 19: return Av(t, e, n); case 22: return Nv(t, e, n) }throw Error(M(156, e.tag)) }; function Jv(t, e) { return bg(t, e) } function Xx(t, e, n, r) { this.tag = t, this.key = n, this.sibling = this.child = this.return = this.stateNode = this.type = this.elementType = null, this.index = 0, this.ref = null, this.pendingProps = e, this.dependencies = this.memoizedState = this.updateQueue = this.memoizedProps = null, this.mode = r, this.subtreeFlags = this.flags = 0, this.deletions = null, this.childLanes = this.lanes = 0, this.alternate = null } function Tt(t, e, n, r) { return new Xx(t, e, n, r) } function pf(t) { return t = t.prototype, !(!t || !t.isReactComponent) } function Qx(t) { if (typeof t == "function") return pf(t) ? 1 : 0; if (t != null) { if (t = t.$$typeof, t === Rd) return 11; if (t === Od) return 14 } return 2 } function nr(t, e) { var n = t.alternate; return n === null ? (n = Tt(t.tag, e, t.key, t.mode), n.elementType = t.elementType, n.type = t.type, n.stateNode = t.stateNode, n.alternate = t, t.alternate = n) : (n.pendingProps = e, n.type = t.type, n.flags = 0, n.subtreeFlags = 0, n.deletions = null), n.flags = t.flags & 14680064, n.childLanes = t.childLanes, n.lanes = t.lanes, n.child = t.child, n.memoizedProps = t.memoizedProps, n.memoizedState = t.memoizedState, n.updateQueue = t.updateQueue, e = t.dependencies, n.dependencies = e === null ? null : { lanes: e.lanes, firstContext: e.firstContext }, n.sibling = t.sibling, n.index = t.index, n.ref = t.ref, n } function ca(t, e, n, r, i, s) { var o = 2; if (r = t, typeof t == "function") pf(t) && (o = 1); else if (typeof t == "string") o = 5; else e: switch (t) { case oi: return Or(n.children, i, s, e); case Nd: o = 8, i |= 8; break; case Qc: return t = Tt(12, n, e, i | 2), t.elementType = Qc, t.lanes = s, t; case Zc: return t = Tt(13, n, e, i), t.elementType = Zc, t.lanes = s, t; case eu: return t = Tt(19, n, e, i), t.elementType = eu, t.lanes = s, t; case og: return _l(n, i, s, e); default: if (typeof t == "object" && t !== null) switch (t.$$typeof) { case ig: o = 10; break e; case sg: o = 9; break e; case Rd: o = 11; break e; case Od: o = 14; break e; case Dn: o = 16, r = null; break e }throw Error(M(130, t == null ? t : typeof t, "")) }return e = Tt(o, n, e, i), e.elementType = t, e.type = r, e.lanes = s, e } function Or(t, e, n, r) { return t = Tt(7, t, r, e), t.lanes = n, t } function _l(t, e, n, r) { return t = Tt(22, t, r, e), t.elementType = og, t.lanes = n, t.stateNode = { isHidden: !1 }, t } function Ec(t, e, n) { return t = Tt(6, t, null, e), t.lanes = n, t } function bc(t, e, n) { return e = Tt(4, t.children !== null ? t.children : [], t.key, e), e.lanes = n, e.stateNode = { containerInfo: t.containerInfo, pendingChildren: null, implementation: t.implementation }, e } function Zx(t, e, n, r, i) { this.tag = e, this.containerInfo = t, this.finishedWork = this.pingCache = this.current = this.pendingChildren = null, this.timeoutHandle = -1, this.callbackNode = this.pendingContext = this.context = null, this.callbackPriority = 0, this.eventTimes = rc(0), this.expirationTimes = rc(-1), this.entangledLanes = this.finishedLanes = this.mutableReadLanes = this.expiredLanes = this.pingedLanes = this.suspendedLanes = this.pendingLanes = 0, this.entanglements = rc(0), this.identifierPrefix = r, this.onRecoverableError = i, this.mutableSourceEagerHydrationData = null } function hf(t, e, n, r, i, s, o, l, a) { return t = new Zx(t, e, n, l, a), e === 1 ? (e = 1, s === !0 && (e |= 8)) : e = 0, s = Tt(3, null, null, e), t.current = s, s.stateNode = t, s.memoizedState = { element: r, isDehydrated: n, cache: null, transitions: null, pendingSuspenseBoundaries: null }, Jd(s), t } function eS(t, e, n) { var r = 3 < arguments.length && arguments[3] !== void 0 ? arguments[3] : null; return { $$typeof: si, key: r == null ? null : "" + r, children: t, containerInfo: e, implementation: n } } function Xv(t) { if (!t) return or; t = t._reactInternals; e: { if (Gr(t) !== t || t.tag !== 1) throw Error(M(170)); var e = t; do { switch (e.tag) { case 3: e = e.stateNode.context; break e; case 1: if (ot(e.type)) { e = e.stateNode.__reactInternalMemoizedMergedChildContext; break e } }e = e.return } while (e !== null); throw Error(M(171)) } if (t.tag === 1) { var n = t.type; if (ot(n)) return Xg(t, n, e) } return e } function Qv(t, e, n, r, i, s, o, l, a) { return t = hf(n, r, !0, t, i, s, o, l, a), t.context = Xv(null), n = t.current, r = Qe(), i = tr(n), s = hn(r, i), s.callback = e ?? null, Zn(n, s, i), t.current.lanes = i, oo(t, i, r), at(t, r), t } function Pl(t, e, n, r) { var i = e.current, s = Qe(), o = tr(i); return n = Xv(n), e.context === null ? e.context = n : e.pendingContext = n, e = hn(s, o), e.payload = { element: t }, r = r === void 0 ? null : r, r !== null && (e.callback = r), t = Zn(i, e, o), t !== null && (Ft(t, i, o, s), ra(t, i, o)), o } function qa(t) { if (t = t.current, !t.child) return null; switch (t.child.tag) { case 5: return t.child.stateNode; default: return t.child.stateNode } } function dh(t, e) { if (t = t.memoizedState, t !== null && t.dehydrated !== null) { var n = t.retryLane; t.retryLane = n !== 0 && n < e ? n : e } } function mf(t, e) { dh(t, e), (t = t.alternate) && dh(t, e) } function tS() { return null } var Zv = typeof reportError == "function" ? reportError : function (t) { console.error(t) }; function gf(t) { this._internalRoot = t } Il.prototype.render = gf.prototype.render = function (t) { var e = this._internalRoot; if (e === null) throw Error(M(409)); Pl(t, e, null, null) }; Il.prototype.unmount = gf.prototype.unmount = function () { var t = this._internalRoot; if (t !== null) { this._internalRoot = null; var e = t.containerInfo; Fr(function () { Pl(null, t, null, null) }), e[wn] = null } }; function Il(t) { this._internalRoot = t } Il.prototype.unstable_scheduleHydration = function (t) { if (t) { var e = Ng(); t = { blockedOn: null, target: t, priority: e }; for (var n = 0; n < Un.length && e !== 0 && e < Un[n].priority; n++); Un.splice(n, 0, t), n === 0 && Og(t) } }; function vf(t) { return !(!t || t.nodeType !== 1 && t.nodeType !== 9 && t.nodeType !== 11) } function kl(t) { return !(!t || t.nodeType !== 1 && t.nodeType !== 9 && t.nodeType !== 11 && (t.nodeType !== 8 || t.nodeValue !== " react-mount-point-unstable ")) } function fh() { } function nS(t, e, n, r, i) { if (i) { if (typeof r == "function") { var s = r; r = function () { var c = qa(o); s.call(c) } } var o = Qv(e, r, t, 0, null, !1, !1, "", fh); return t._reactRootContainer = o, t[wn] = o.current, Vs(t.nodeType === 8 ? t.parentNode : t), Fr(), o } for (; i = t.lastChild;)t.removeChild(i); if (typeof r == "function") { var l = r; r = function () { var c = qa(a); l.call(c) } } var a = hf(t, 0, !1, null, null, !1, !1, "", fh); return t._reactRootContainer = a, t[wn] = a.current, Vs(t.nodeType === 8 ? t.parentNode : t), Fr(function () { Pl(e, a, n, r) }), a } function Nl(t, e, n, r, i) { var s = n._reactRootContainer; if (s) { var o = s; if (typeof i == "function") { var l = i; i = function () { var a = qa(o); l.call(a) } } Pl(e, o, t, i) } else o = nS(n, e, t, i, r); return qa(o) } Ig = function (t) { switch (t.tag) { case 3: var e = t.stateNode; if (e.current.memoizedState.isDehydrated) { var n = vs(e.pendingLanes); n !== 0 && (Ld(e, n | 1), at(e, Ie()), !(se & 6) && (Di = Ie() + 500, cr())) } break; case 13: Fr(function () { var r = xn(t, 1); if (r !== null) { var i = Qe(); Ft(r, t, 1, i) } }), mf(t, 1) } }; Dd = function (t) { if (t.tag === 13) { var e = xn(t, 134217728); if (e !== null) { var n = Qe(); Ft(e, t, 134217728, n) } mf(t, 134217728) } }; kg = function (t) { if (t.tag === 13) { var e = tr(t), n = xn(t, e); if (n !== null) { var r = Qe(); Ft(n, t, e, r) } mf(t, e) } }; Ng = function () { return ue }; Rg = function (t, e) { var n = ue; try { return ue = t, e() } finally { ue = n } }; uu = function (t, e, n) { switch (e) { case "input": if (ru(t, n), e = n.name, n.type === "radio" && e != null) { for (n = t; n.parentNode;)n = n.parentNode; for (n = n.querySelectorAll("input[name=" + JSON.stringify("" + e) + '][type="radio"]'), e = 0; e < n.length; e++) { var r = n[e]; if (r !== t && r.form === t.form) { var i = xl(r); if (!i) throw Error(M(90)); lg(r), ru(r, i) } } } break; case "textarea": ug(t, n); break; case "select": e = n.value, e != null && vi(t, !!n.multiple, e, !1) } }; vg = uf; yg = Fr; var rS = { usingClientEntryPoint: !1, Events: [lo, ui, xl, mg, gg, uf] }, os = { findFiberByHostInstance: Tr, bundleType: 0, version: "18.3.1", rendererPackageName: "react-dom" }, iS = { bundleType: os.bundleType, version: os.version, rendererPackageName: os.rendererPackageName, rendererConfig: os.rendererConfig, overrideHookState: null, overrideHookStateDeletePath: null, overrideHookStateRenamePath: null, overrideProps: null, overridePropsDeletePath: null, overridePropsRenamePath: null, setErrorHandler: null, setSuspenseHandler: null, scheduleUpdate: null, currentDispatcherRef: _n.ReactCurrentDispatcher, findHostInstanceByFiber: function (t) { return t = Sg(t), t === null ? null : t.stateNode }, findFiberByHostInstance: os.findFiberByHostInstance || tS, findHostInstancesForRefresh: null, scheduleRefresh: null, scheduleRoot: null, setRefreshHandler: null, getCurrentFiber: null, reconcilerVersion: "18.3.1-next-f1338f8080-20240426" }; if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u") { var Vo = __REACT_DEVTOOLS_GLOBAL_HOOK__; if (!Vo.isDisabled && Vo.supportsFiber) try { gl = Vo.inject(iS), Yt = Vo } catch { } } vt.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = rS; vt.createPortal = function (t, e) { var n = 2 < arguments.length && arguments[2] !== void 0 ? arguments[2] : null; if (!vf(e)) throw Error(M(200)); return eS(t, e, null, n) }; vt.createRoot = function (t, e) { if (!vf(t)) throw Error(M(299)); var n = !1, r = "", i = Zv; return e != null && (e.unstable_strictMode === !0 && (n = !0), e.identifierPrefix !== void 0 && (r = e.identifierPrefix), e.onRecoverableError !== void 0 && (i = e.onRecoverableError)), e = hf(t, 1, !1, null, null, n, !1, r, i), t[wn] = e.current, Vs(t.nodeType === 8 ? t.parentNode : t), new gf(e) }; vt.findDOMNode = function (t) { if (t == null) return null; if (t.nodeType === 1) return t; var e = t._reactInternals; if (e === void 0) throw typeof t.render == "function" ? Error(M(188)) : (t = Object.keys(t).join(","), Error(M(268, t))); return t = Sg(e), t = t === null ? null : t.stateNode, t }; vt.flushSync = function (t) { return Fr(t) }; vt.hydrate = function (t, e, n) { if (!kl(e)) throw Error(M(200)); return Nl(null, t, e, !0, n) }; vt.hydrateRoot = function (t, e, n) { if (!vf(t)) throw Error(M(405)); var r = n != null && n.hydratedSources || null, i = !1, s = "", o = Zv; if (n != null && (n.unstable_strictMode === !0 && (i = !0), n.identifierPrefix !== void 0 && (s = n.identifierPrefix), n.onRecoverableError !== void 0 && (o = n.onRecoverableError)), e = Qv(e, null, t, 1, n ?? null, i, !1, s, o), t[wn] = e.current, Vs(t), r) for (t = 0; t < r.length; t++)n = r[t], i = n._getVersion, i = i(n._source), e.mutableSourceEagerHydrationData == null ? e.mutableSourceEagerHydrationData = [n, i] : e.mutableSourceEagerHydrationData.push(n, i); return new Il(e) }; vt.render = function (t, e, n) { if (!kl(e)) throw Error(M(200)); return Nl(null, t, e, !1, n) }; vt.unmountComponentAtNode = function (t) { if (!kl(t)) throw Error(M(40)); return t._reactRootContainer ? (Fr(function () { Nl(null, null, t, !1, function () { t._reactRootContainer = null, t[wn] = null }) }), !0) : !1 }; vt.unstable_batchedUpdates = uf; vt.unstable_renderSubtreeIntoContainer = function (t, e, n, r) { if (!kl(n)) throw Error(M(200)); if (t == null || t._reactInternals === void 0) throw Error(M(38)); return Nl(t, e, n, !1, r) }; vt.version = "18.3.1-next-f1338f8080-20240426"; function ey() { if (!(typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ > "u" || typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE != "function")) try { __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(ey) } catch (t) { console.error(t) } } ey(), eg.exports = vt; var yf = eg.exports; const sS = io(yf), oS = Bm({ __proto__: null, default: sS }, [yf]); var ph = yf; Ta.createRoot = ph.createRoot, Ta.hydrateRoot = ph.hydrateRoot;/**
 * @remix-run/router v1.21.0
 *
 * Copyright (c) Remix Software Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.md file in the root directory of this source tree.
 *
 * @license MIT
 */function xe() { return xe = Object.assign ? Object.assign.bind() : function (t) { for (var e = 1; e < arguments.length; e++) { var n = arguments[e]; for (var r in n) Object.prototype.hasOwnProperty.call(n, r) && (t[r] = n[r]) } return t }, xe.apply(this, arguments) } var Ne; (function (t) { t.Pop = "POP", t.Push = "PUSH", t.Replace = "REPLACE" })(Ne || (Ne = {})); const hh = "popstate"; function aS(t) { t === void 0 && (t = {}); function e(r, i) { let { pathname: s, search: o, hash: l } = r.location; return Zs("", { pathname: s, search: o, hash: l }, i.state && i.state.usr || null, i.state && i.state.key || "default") } function n(r, i) { return typeof i == "string" ? i : Ur(i) } return cS(e, n, null, t) } function ee(t, e) { if (t === !1 || t === null || typeof t > "u") throw new Error(e) } function Mi(t, e) { if (!t) { typeof console < "u" && console.warn(e); try { throw new Error(e) } catch { } } } function lS() { return Math.random().toString(36).substr(2, 8) } function mh(t, e) { return { usr: t.state, key: t.key, idx: e } } function Zs(t, e, n, r) { return n === void 0 && (n = null), xe({ pathname: typeof t == "string" ? t : t.pathname, search: "", hash: "" }, typeof e == "string" ? ur(e) : e, { state: n, key: e && e.key || r || lS() }) } function Ur(t) { let { pathname: e = "/", search: n = "", hash: r = "" } = t; return n && n !== "?" && (e += n.charAt(0) === "?" ? n : "?" + n), r && r !== "#" && (e += r.charAt(0) === "#" ? r : "#" + r), e } function ur(t) { let e = {}; if (t) { let n = t.indexOf("#"); n >= 0 && (e.hash = t.substr(n), t = t.substr(0, n)); let r = t.indexOf("?"); r >= 0 && (e.search = t.substr(r), t = t.substr(0, r)), t && (e.pathname = t) } return e } function cS(t, e, n, r) { r === void 0 && (r = {}); let { window: i = document.defaultView, v5Compat: s = !1 } = r, o = i.history, l = Ne.Pop, a = null, c = u(); c == null && (c = 0, o.replaceState(xe({}, o.state, { idx: c }), "")); function u() { return (o.state || { idx: null }).idx } function f() { l = Ne.Pop; let E = u(), v = E == null ? null : E - c; c = E, a && a({ action: l, location: w.location, delta: v }) } function h(E, v) { l = Ne.Push; let p = Zs(w.location, E, v); c = u() + 1; let m = mh(p, c), S = w.createHref(p); try { o.pushState(m, "", S) } catch (T) { if (T instanceof DOMException && T.name === "DataCloneError") throw T; i.location.assign(S) } s && a && a({ action: l, location: w.location, delta: 1 }) } function y(E, v) { l = Ne.Replace; let p = Zs(w.location, E, v); c = u(); let m = mh(p, c), S = w.createHref(p); o.replaceState(m, "", S), s && a && a({ action: l, location: w.location, delta: 0 }) } function g(E) { let v = i.location.origin !== "null" ? i.location.origin : i.location.href, p = typeof E == "string" ? E : Ur(E); return p = p.replace(/ $/, "%20"), ee(v, "No window.location.(origin|href) available to create URL for href: " + p), new URL(p, v) } let w = { get action() { return l }, get location() { return t(i, o) }, listen(E) { if (a) throw new Error("A history only accepts one active listener"); return i.addEventListener(hh, f), a = E, () => { i.removeEventListener(hh, f), a = null } }, createHref(E) { return e(i, E) }, createURL: g, encodeLocation(E) { let v = g(E); return { pathname: v.pathname, search: v.search, hash: v.hash } }, push: h, replace: y, go(E) { return o.go(E) } }; return w } var fe; (function (t) { t.data = "data", t.deferred = "deferred", t.redirect = "redirect", t.error = "error" })(fe || (fe = {})); const uS = new Set(["lazy", "caseSensitive", "path", "id", "index", "children"]); function dS(t) { return t.index === !0 } function Ya(t, e, n, r) { return n === void 0 && (n = []), r === void 0 && (r = {}), t.map((i, s) => { let o = [...n, String(s)], l = typeof i.id == "string" ? i.id : o.join("-"); if (ee(i.index !== !0 || !i.children, "Cannot specify children on an index route"), ee(!r[l], 'Found a route id collision on id "' + l + `".  Route id's must be globally unique within Data Router usages`), dS(i)) { let a = xe({}, i, e(i), { id: l }); return r[l] = a, a } else { let a = xe({}, i, e(i), { id: l, children: void 0 }); return r[l] = a, i.children && (a.children = Ya(i.children, e, o, r)), a } }) } function Er(t, e, n) { return n === void 0 && (n = "/"), ua(t, e, n, !1) } function ua(t, e, n, r) { let i = typeof e == "string" ? ur(e) : e, s = En(i.pathname || "/", n); if (s == null) return null; let o = ty(t); pS(o); let l = null; for (let a = 0; l == null && a < o.length; ++a) { let c = TS(s); l = ES(o[a], c, r) } return l } function fS(t, e) { let { route: n, pathname: r, params: i } = t; return { id: n.id, pathname: r, params: i, data: e[n.id], handle: n.handle } } function ty(t, e, n, r) { e === void 0 && (e = []), n === void 0 && (n = []), r === void 0 && (r = ""); let i = (s, o, l) => { let a = { relativePath: l === void 0 ? s.path || "" : l, caseSensitive: s.caseSensitive === !0, childrenIndex: o, route: s }; a.relativePath.startsWith("/") && (ee(a.relativePath.startsWith(r), 'Absolute route path "' + a.relativePath + '" nested under path ' + ('"' + r + '" is not valid. An absolute child route path ') + "must start with the combined path of all its parent routes."), a.relativePath = a.relativePath.slice(r.length)); let c = mn([r, a.relativePath]), u = n.concat(a); s.children && s.children.length > 0 && (ee(s.index !== !0, "Index routes must not have child routes. Please remove " + ('all child routes from route path "' + c + '".')), ty(s.children, e, u, c)), !(s.path == null && !s.index) && e.push({ path: c, score: xS(c, s.index), routesMeta: u }) }; return t.forEach((s, o) => { var l; if (s.path === "" || !((l = s.path) != null && l.includes("?"))) i(s, o); else for (let a of ny(s.path)) i(s, o, a) }), e } function ny(t) { let e = t.split("/"); if (e.length === 0) return []; let [n, ...r] = e, i = n.endsWith("?"), s = n.replace(/\?$/, ""); if (r.length === 0) return i ? [s, ""] : [s]; let o = ny(r.join("/")), l = []; return l.push(...o.map(a => a === "" ? s : [s, a].join("/"))), i && l.push(...o), l.map(a => t.startsWith("/") && a === "" ? "/" : a) } function pS(t) { t.sort((e, n) => e.score !== n.score ? n.score - e.score : SS(e.routesMeta.map(r => r.childrenIndex), n.routesMeta.map(r => r.childrenIndex))) } const hS = /^:[\w-]+$/, mS = 3, gS = 2, vS = 1, yS = 10, wS = -2, gh = t => t === "*"; function xS(t, e) { let n = t.split("/"), r = n.length; return n.some(gh) && (r += wS), e && (r += gS), n.filter(i => !gh(i)).reduce((i, s) => i + (hS.test(s) ? mS : s === "" ? vS : yS), r) } function SS(t, e) { return t.length === e.length && t.slice(0, -1).every((r, i) => r === e[i]) ? t[t.length - 1] - e[e.length - 1] : 0 } function ES(t, e, n) { n === void 0 && (n = !1); let { routesMeta: r } = t, i = {}, s = "/", o = []; for (let l = 0; l < r.length; ++l) { let a = r[l], c = l === r.length - 1, u = s === "/" ? e : e.slice(s.length) || "/", f = Ja({ path: a.relativePath, caseSensitive: a.caseSensitive, end: c }, u), h = a.route; if (!f && c && n && !r[r.length - 1].route.index && (f = Ja({ path: a.relativePath, caseSensitive: a.caseSensitive, end: !1 }, u)), !f) return null; Object.assign(i, f.params), o.push({ params: i, pathname: mn([s, f.pathname]), pathnameBase: PS(mn([s, f.pathnameBase])), route: h }), f.pathnameBase !== "/" && (s = mn([s, f.pathnameBase])) } return o } function Ja(t, e) { typeof t == "string" && (t = { path: t, caseSensitive: !1, end: !0 }); let [n, r] = bS(t.path, t.caseSensitive, t.end), i = e.match(n); if (!i) return null; let s = i[0], o = s.replace(/(.)\/+$/, "$1"), l = i.slice(1); return { params: r.reduce((c, u, f) => { let { paramName: h, isOptional: y } = u; if (h === "*") { let w = l[f] || ""; o = s.slice(0, s.length - w.length).replace(/(.)\/+$/, "$1") } const g = l[f]; return y && !g ? c[h] = void 0 : c[h] = (g || "").replace(/%2F/g, "/"), c }, {}), pathname: s, pathnameBase: o, pattern: t } } function bS(t, e, n) { e === void 0 && (e = !1), n === void 0 && (n = !0), Mi(t === "*" || !t.endsWith("*") || t.endsWith("/*"), 'Route path "' + t + '" will be treated as if it were ' + ('"' + t.replace(/\*$/, "/*") + '" because the `*` character must ') + "always follow a `/` in the pattern. To get rid of this warning, " + ('please change the route path to "' + t.replace(/\*$/, "/*") + '".')); let r = [], i = "^" + t.replace(/\/*\*?$/, "").replace(/^\/*/, "/").replace(/[\\.*+^${}|()[\]]/g, "\\$&").replace(/\/:([\w-]+)(\?)?/g, (o, l, a) => (r.push({ paramName: l, isOptional: a != null }), a ? "/?([^\\/]+)?" : "/([^\\/]+)")); return t.endsWith("*") ? (r.push({ paramName: "*" }), i += t === "*" || t === "/*" ? "(.*)$" : "(?:\\/(.+)|\\/*)$") : n ? i += "\\/*$" : t !== "" && t !== "/" && (i += "(?:(?=\\/|$))"), [new RegExp(i, e ? void 0 : "i"), r] } function TS(t) { try { return t.split("/").map(e => decodeURIComponent(e).replace(/\//g, "%2F")).join("/") } catch (e) { return Mi(!1, 'The URL path "' + t + '" could not be decoded because it is is a malformed URL segment. This is probably due to a bad percent ' + ("encoding (" + e + ").")), t } } function En(t, e) { if (e === "/") return t; if (!t.toLowerCase().startsWith(e.toLowerCase())) return null; let n = e.endsWith("/") ? e.length - 1 : e.length, r = t.charAt(n); return r && r !== "/" ? null : t.slice(n) || "/" } function CS(t, e) { e === void 0 && (e = "/"); let { pathname: n, search: r = "", hash: i = "" } = typeof t == "string" ? ur(t) : t; return { pathname: n ? n.startsWith("/") ? n : _S(n, e) : e, search: IS(r), hash: kS(i) } } function _S(t, e) { let n = e.replace(/\/+$/, "").split("/"); return t.split("/").forEach(i => { i === ".." ? n.length > 1 && n.pop() : i !== "." && n.push(i) }), n.length > 1 ? n.join("/") : "/" } function Tc(t, e, n, r) { return "Cannot include a '" + t + "' character in a manually specified " + ("`to." + e + "` field [" + JSON.stringify(r) + "].  Please separate it out to the ") + ("`to." + n + "` field. Alternatively you may provide the full path as ") + 'a string in <Link to="..."> and the router will parse it for you.' } function ry(t) { return t.filter((e, n) => n === 0 || e.route.path && e.route.path.length > 0) } function Rl(t, e) { let n = ry(t); return e ? n.map((r, i) => i === n.length - 1 ? r.pathname : r.pathnameBase) : n.map(r => r.pathnameBase) } function Ol(t, e, n, r) { r === void 0 && (r = !1); let i; typeof t == "string" ? i = ur(t) : (i = xe({}, t), ee(!i.pathname || !i.pathname.includes("?"), Tc("?", "pathname", "search", i)), ee(!i.pathname || !i.pathname.includes("#"), Tc("#", "pathname", "hash", i)), ee(!i.search || !i.search.includes("#"), Tc("#", "search", "hash", i))); let s = t === "" || i.pathname === "", o = s ? "/" : i.pathname, l; if (o == null) l = n; else { let f = e.length - 1; if (!r && o.startsWith("..")) { let h = o.split("/"); for (; h[0] === "..";)h.shift(), f -= 1; i.pathname = h.join("/") } l = f >= 0 ? e[f] : "/" } let a = CS(i, l), c = o && o !== "/" && o.endsWith("/"), u = (s || o === ".") && n.endsWith("/"); return !a.pathname.endsWith("/") && (c || u) && (a.pathname += "/"), a } const mn = t => t.join("/").replace(/\/\/+/g, "/"), PS = t => t.replace(/\/+$/, "").replace(/^\/*/, "/"), IS = t => !t || t === "?" ? "" : t.startsWith("?") ? t : "?" + t, kS = t => !t || t === "#" ? "" : t.startsWith("#") ? t : "#" + t; class Xa { constructor(e, n, r, i) { i === void 0 && (i = !1), this.status = e, this.statusText = n || "", this.internal = i, r instanceof Error ? (this.data = r.toString(), this.error = r) : this.data = r } } function jl(t) { return t != null && typeof t.status == "number" && typeof t.statusText == "string" && typeof t.internal == "boolean" && "data" in t } const iy = ["post", "put", "patch", "delete"], NS = new Set(iy), RS = ["get", ...iy], OS = new Set(RS), jS = new Set([301, 302, 303, 307, 308]), AS = new Set([307, 308]), Cc = { state: "idle", location: void 0, formMethod: void 0, formAction: void 0, formEncType: void 0, formData: void 0, json: void 0, text: void 0 }, LS = { state: "idle", data: void 0, formMethod: void 0, formAction: void 0, formEncType: void 0, formData: void 0, json: void 0, text: void 0 }, as = { state: "unblocked", proceed: void 0, reset: void 0, location: void 0 }, wf = /^(?:[a-z][a-z0-9+.-]*:|\/\/)/i, DS = t => ({ hasErrorBoundary: !!t.hasErrorBoundary }), sy = "remix-router-transitions"; function MS(t) { const e = t.window ? t.window : typeof window < "u" ? window : void 0, n = typeof e < "u" && typeof e.document < "u" && typeof e.document.createElement < "u", r = !n; ee(t.routes.length > 0, "You must provide a non-empty routes array to createRouter"); let i; if (t.mapRouteProperties) i = t.mapRouteProperties; else if (t.detectErrorBoundary) { let C = t.detectErrorBoundary; i = _ => ({ hasErrorBoundary: C(_) }) } else i = DS; let s = {}, o = Ya(t.routes, i, void 0, s), l, a = t.basename || "/", c = t.dataStrategy || $S, u = t.patchRoutesOnNavigation, f = xe({ v7_fetcherPersist: !1, v7_normalizeFormMethod: !1, v7_partialHydration: !1, v7_prependBasename: !1, v7_relativeSplatPath: !1, v7_skipActionErrorRevalidation: !1 }, t.future), h = null, y = new Set, g = null, w = null, E = null, v = t.hydrationData != null, p = Er(o, t.history.location, a), m = null; if (p == null && !u) { let C = nt(404, { pathname: t.history.location.pathname }), { matches: _, route: R } = Ph(o); p = _, m = { [R.id]: C } } p && !t.hydrationData && To(p, o, t.history.location.pathname).active && (p = null); let S; if (p) if (p.some(C => C.route.lazy)) S = !1; else if (!p.some(C => C.route.loader)) S = !0; else if (f.v7_partialHydration) { let C = t.hydrationData ? t.hydrationData.loaderData : null, _ = t.hydrationData ? t.hydrationData.errors : null; if (_) { let R = p.findIndex(L => _[L.route.id] !== void 0); S = p.slice(0, R + 1).every(L => !Vu(L.route, C, _)) } else S = p.every(R => !Vu(R.route, C, _)) } else S = t.hydrationData != null; else if (S = !1, p = [], f.v7_partialHydration) { let C = To(null, o, t.history.location.pathname); C.active && C.matches && (p = C.matches) } let T, x = { historyAction: t.history.action, location: t.history.location, matches: p, initialized: S, navigation: Cc, restoreScrollPosition: t.hydrationData != null ? !1 : null, preventScrollReset: !1, revalidation: "idle", loaderData: t.hydrationData && t.hydrationData.loaderData || {}, actionData: t.hydrationData && t.hydrationData.actionData || null, errors: t.hydrationData && t.hydrationData.errors || m, fetchers: new Map, blockers: new Map }, P = Ne.Pop, I = !1, N, k = !1, j = new Map, F = null, D = !1, B = !1, J = [], de = new Set, pe = new Map, A = 0, U = -1, z = new Map, Z = new Set, le = new Map, Bt = new Map, Me = new Set, kt = new Map, qe = new Map, Zt; function hw() { if (h = t.history.listen(C => { let { action: _, location: R, delta: L } = C; if (Zt) { Zt(), Zt = void 0; return } Mi(qe.size === 0 || L != null, "You are trying to use a blocker on a POP navigation to a location that was not created by @remix-run/router. This will fail silently in production. This can happen if you are navigating outside the router via `window.history.pushState`/`window.location.hash` instead of using router navigation APIs.  This can also happen if you are using createHashRouter and the user manually changes the URL."); let H = tp({ currentLocation: x.location, nextLocation: R, historyAction: _ }); if (H && L != null) { let K = new Promise(X => { Zt = X }); t.history.go(L * -1), bo(H, { state: "blocked", location: R, proceed() { bo(H, { state: "proceeding", proceed: void 0, reset: void 0, location: R }), K.then(() => t.history.go(L)) }, reset() { let X = new Map(x.blockers); X.set(H, as), Ye({ blockers: X }) } }); return } return gr(_, R) }), n) { tE(e, j); let C = () => nE(e, j); e.addEventListener("pagehide", C), F = () => e.removeEventListener("pagehide", C) } return x.initialized || gr(Ne.Pop, x.location, { initialHydration: !0 }), T } function mw() { h && h(), F && F(), y.clear(), N && N.abort(), x.fetchers.forEach((C, _) => Eo(_)), x.blockers.forEach((C, _) => ep(_)) } function gw(C) { return y.add(C), () => y.delete(C) } function Ye(C, _) { _ === void 0 && (_ = {}), x = xe({}, x, C); let R = [], L = []; f.v7_fetcherPersist && x.fetchers.forEach((H, K) => { H.state === "idle" && (Me.has(K) ? L.push(K) : R.push(K)) }), [...y].forEach(H => H(x, { deletedFetchers: L, viewTransitionOpts: _.viewTransitionOpts, flushSync: _.flushSync === !0 })), f.v7_fetcherPersist && (R.forEach(H => x.fetchers.delete(H)), L.forEach(H => Eo(H))) } function Jr(C, _, R) { var L, H; let { flushSync: K } = R === void 0 ? {} : R, X = x.actionData != null && x.navigation.formMethod != null && jt(x.navigation.formMethod) && x.navigation.state === "loading" && ((L = C.state) == null ? void 0 : L._isRedirect) !== !0, W; _.actionData ? Object.keys(_.actionData).length > 0 ? W = _.actionData : W = null : X ? W = x.actionData : W = null; let G = _.loaderData ? Ch(x.loaderData, _.loaderData, _.matches || [], _.errors) : x.loaderData, V = x.blockers; V.size > 0 && (V = new Map(V), V.forEach((ie, Fe) => V.set(Fe, as))); let q = I === !0 || x.navigation.formMethod != null && jt(x.navigation.formMethod) && ((H = C.state) == null ? void 0 : H._isRedirect) !== !0; l && (o = l, l = void 0), D || P === Ne.Pop || (P === Ne.Push ? t.history.push(C, C.state) : P === Ne.Replace && t.history.replace(C, C.state)); let ne; if (P === Ne.Pop) { let ie = j.get(x.location.pathname); ie && ie.has(C.pathname) ? ne = { currentLocation: x.location, nextLocation: C } : j.has(C.pathname) && (ne = { currentLocation: C, nextLocation: x.location }) } else if (k) { let ie = j.get(x.location.pathname); ie ? ie.add(C.pathname) : (ie = new Set([C.pathname]), j.set(x.location.pathname, ie)), ne = { currentLocation: x.location, nextLocation: C } } Ye(xe({}, _, { actionData: W, loaderData: G, historyAction: P, location: C, initialized: !0, navigation: Cc, revalidation: "idle", restoreScrollPosition: rp(C, _.matches || x.matches), preventScrollReset: q, blockers: V }), { viewTransitionOpts: ne, flushSync: K === !0 }), P = Ne.Pop, I = !1, k = !1, D = !1, B = !1, J = [] } async function Kf(C, _) { if (typeof C == "number") { t.history.go(C); return } let R = Hu(x.location, x.matches, a, f.v7_prependBasename, C, f.v7_relativeSplatPath, _ == null ? void 0 : _.fromRouteId, _ == null ? void 0 : _.relative), { path: L, submission: H, error: K } = vh(f.v7_normalizeFormMethod, !1, R, _), X = x.location, W = Zs(x.location, L, _ && _.state); W = xe({}, W, t.history.encodeLocation(W)); let G = _ && _.replace != null ? _.replace : void 0, V = Ne.Push; G === !0 ? V = Ne.Replace : G === !1 || H != null && jt(H.formMethod) && H.formAction === x.location.pathname + x.location.search && (V = Ne.Replace); let q = _ && "preventScrollReset" in _ ? _.preventScrollReset === !0 : void 0, ne = (_ && _.flushSync) === !0, ie = tp({ currentLocation: X, nextLocation: W, historyAction: V }); if (ie) { bo(ie, { state: "blocked", location: W, proceed() { bo(ie, { state: "proceeding", proceed: void 0, reset: void 0, location: W }), Kf(C, _) }, reset() { let Fe = new Map(x.blockers); Fe.set(ie, as), Ye({ blockers: Fe }) } }); return } return await gr(V, W, { submission: H, pendingError: K, preventScrollReset: q, replace: _ && _.replace, enableViewTransition: _ && _.viewTransition, flushSync: ne }) } function vw() { if (ql(), Ye({ revalidation: "loading" }), x.navigation.state !== "submitting") { if (x.navigation.state === "idle") { gr(x.historyAction, x.location, { startUninterruptedRevalidation: !0 }); return } gr(P || x.historyAction, x.navigation.location, { overrideNavigation: x.navigation, enableViewTransition: k === !0 }) } } async function gr(C, _, R) { N && N.abort(), N = null, P = C, D = (R && R.startUninterruptedRevalidation) === !0, Pw(x.location, x.matches), I = (R && R.preventScrollReset) === !0, k = (R && R.enableViewTransition) === !0; let L = l || o, H = R && R.overrideNavigation, K = Er(L, _, a), X = (R && R.flushSync) === !0, W = To(K, L, _.pathname); if (W.active && W.matches && (K = W.matches), !K) { let { error: me, notFoundMatches: ae, route: Ce } = Yl(_.pathname); Jr(_, { matches: ae, loaderData: {}, errors: { [Ce.id]: me } }, { flushSync: X }); return } if (x.initialized && !B && KS(x.location, _) && !(R && R.submission && jt(R.submission.formMethod))) { Jr(_, { matches: K }, { flushSync: X }); return } N = new AbortController; let G = ti(t.history, _, N.signal, R && R.submission), V; if (R && R.pendingError) V = [br(K).route.id, { type: fe.error, error: R.pendingError }]; else if (R && R.submission && jt(R.submission.formMethod)) { let me = await yw(G, _, R.submission, K, W.active, { replace: R.replace, flushSync: X }); if (me.shortCircuited) return; if (me.pendingActionResult) { let [ae, Ce] = me.pendingActionResult; if (dt(Ce) && jl(Ce.error) && Ce.error.status === 404) { N = null, Jr(_, { matches: me.matches, loaderData: {}, errors: { [ae]: Ce.error } }); return } } K = me.matches || K, V = me.pendingActionResult, H = _c(_, R.submission), X = !1, W.active = !1, G = ti(t.history, G.url, G.signal) } let { shortCircuited: q, matches: ne, loaderData: ie, errors: Fe } = await ww(G, _, K, W.active, H, R && R.submission, R && R.fetcherSubmission, R && R.replace, R && R.initialHydration === !0, X, V); q || (N = null, Jr(_, xe({ matches: ne || K }, _h(V), { loaderData: ie, errors: Fe }))) } async function yw(C, _, R, L, H, K) { K === void 0 && (K = {}), ql(); let X = ZS(_, R); if (Ye({ navigation: X }, { flushSync: K.flushSync === !0 }), H) { let V = await Co(L, _.pathname, C.signal); if (V.type === "aborted") return { shortCircuited: !0 }; if (V.type === "error") { let q = br(V.partialMatches).route.id; return { matches: V.partialMatches, pendingActionResult: [q, { type: fe.error, error: V.error }] } } else if (V.matches) L = V.matches; else { let { notFoundMatches: q, error: ne, route: ie } = Yl(_.pathname); return { matches: q, pendingActionResult: [ie.id, { type: fe.error, error: ne }] } } } let W, G = ws(L, _); if (!G.route.action && !G.route.lazy) W = { type: fe.error, error: nt(405, { method: C.method, pathname: _.pathname, routeId: G.route.id }) }; else if (W = (await Yi("action", x, C, [G], L, null))[G.route.id], C.signal.aborted) return { shortCircuited: !0 }; if (Pr(W)) { let V; return K && K.replace != null ? V = K.replace : V = Eh(W.response.headers.get("Location"), new URL(C.url), a) === x.location.pathname + x.location.search, await vr(C, W, !0, { submission: R, replace: V }), { shortCircuited: !0 } } if (Kn(W)) throw nt(400, { type: "defer-action" }); if (dt(W)) { let V = br(L, G.route.id); return (K && K.replace) !== !0 && (P = Ne.Push), { matches: L, pendingActionResult: [V.route.id, W] } } return { matches: L, pendingActionResult: [G.route.id, W] } } async function ww(C, _, R, L, H, K, X, W, G, V, q) { let ne = H || _c(_, K), ie = K || X || kh(ne), Fe = !D && (!f.v7_partialHydration || !G); if (L) { if (Fe) { let _e = qf(q); Ye(xe({ navigation: ne }, _e !== void 0 ? { actionData: _e } : {}), { flushSync: V }) } let oe = await Co(R, _.pathname, C.signal); if (oe.type === "aborted") return { shortCircuited: !0 }; if (oe.type === "error") { let _e = br(oe.partialMatches).route.id; return { matches: oe.partialMatches, loaderData: {}, errors: { [_e]: oe.error } } } else if (oe.matches) R = oe.matches; else { let { error: _e, notFoundMatches: Qr, route: Qi } = Yl(_.pathname); return { matches: Qr, loaderData: {}, errors: { [Qi.id]: _e } } } } let me = l || o, [ae, Ce] = wh(t.history, x, R, ie, _, f.v7_partialHydration && G === !0, f.v7_skipActionErrorRevalidation, B, J, de, Me, le, Z, me, a, q); if (Jl(oe => !(R && R.some(_e => _e.route.id === oe)) || ae && ae.some(_e => _e.route.id === oe)), U = ++A, ae.length === 0 && Ce.length === 0) { let oe = Qf(); return Jr(_, xe({ matches: R, loaderData: {}, errors: q && dt(q[1]) ? { [q[0]]: q[1].error } : null }, _h(q), oe ? { fetchers: new Map(x.fetchers) } : {}), { flushSync: V }), { shortCircuited: !0 } } if (Fe) { let oe = {}; if (!L) { oe.navigation = ne; let _e = qf(q); _e !== void 0 && (oe.actionData = _e) } Ce.length > 0 && (oe.fetchers = xw(Ce)), Ye(oe, { flushSync: V }) } Ce.forEach(oe => { Rn(oe.key), oe.controller && pe.set(oe.key, oe.controller) }); let Xr = () => Ce.forEach(oe => Rn(oe.key)); N && N.signal.addEventListener("abort", Xr); let { loaderResults: Ji, fetcherResults: tn } = await Yf(x, R, ae, Ce, C); if (C.signal.aborted) return { shortCircuited: !0 }; N && N.signal.removeEventListener("abort", Xr), Ce.forEach(oe => pe.delete(oe.key)); let Ht = Wo(Ji); if (Ht) return await vr(C, Ht.result, !0, { replace: W }), { shortCircuited: !0 }; if (Ht = Wo(tn), Ht) return Z.add(Ht.key), await vr(C, Ht.result, !0, { replace: W }), { shortCircuited: !0 }; let { loaderData: Xl, errors: Xi } = Th(x, R, Ji, q, Ce, tn, kt); kt.forEach((oe, _e) => { oe.subscribe(Qr => { (Qr || oe.done) && kt.delete(_e) }) }), f.v7_partialHydration && G && x.errors && (Xi = xe({}, x.errors, Xi)); let yr = Qf(), _o = Zf(U), Po = yr || _o || Ce.length > 0; return xe({ matches: R, loaderData: Xl, errors: Xi }, Po ? { fetchers: new Map(x.fetchers) } : {}) } function qf(C) { if (C && !dt(C[1])) return { [C[0]]: C[1].data }; if (x.actionData) return Object.keys(x.actionData).length === 0 ? null : x.actionData } function xw(C) { return C.forEach(_ => { let R = x.fetchers.get(_.key), L = ls(void 0, R ? R.data : void 0); x.fetchers.set(_.key, L) }), new Map(x.fetchers) } function Sw(C, _, R, L) { if (r) throw new Error("router.fetch() was called during the server render, but it shouldn't be. You are likely calling a useFetcher() method in the body of your component. Try moving it to a useEffect or a callback."); Rn(C); let H = (L && L.flushSync) === !0, K = l || o, X = Hu(x.location, x.matches, a, f.v7_prependBasename, R, f.v7_relativeSplatPath, _, L == null ? void 0 : L.relative), W = Er(K, X, a), G = To(W, K, X); if (G.active && G.matches && (W = G.matches), !W) { en(C, _, nt(404, { pathname: X }), { flushSync: H }); return } let { path: V, submission: q, error: ne } = vh(f.v7_normalizeFormMethod, !0, X, L); if (ne) { en(C, _, ne, { flushSync: H }); return } let ie = ws(W, V), Fe = (L && L.preventScrollReset) === !0; if (q && jt(q.formMethod)) { Ew(C, _, V, ie, W, G.active, H, Fe, q); return } le.set(C, { routeId: _, path: V }), bw(C, _, V, ie, W, G.active, H, Fe, q) } async function Ew(C, _, R, L, H, K, X, W, G) { ql(), le.delete(C); function V(ke) { if (!ke.route.action && !ke.route.lazy) { let Zr = nt(405, { method: G.formMethod, pathname: R, routeId: _ }); return en(C, _, Zr, { flushSync: X }), !0 } return !1 } if (!K && V(L)) return; let q = x.fetchers.get(C); Nn(C, eE(G, q), { flushSync: X }); let ne = new AbortController, ie = ti(t.history, R, ne.signal, G); if (K) { let ke = await Co(H, R, ie.signal); if (ke.type === "aborted") return; if (ke.type === "error") { en(C, _, ke.error, { flushSync: X }); return } else if (ke.matches) { if (H = ke.matches, L = ws(H, R), V(L)) return } else { en(C, _, nt(404, { pathname: R }), { flushSync: X }); return } } pe.set(C, ne); let Fe = A, ae = (await Yi("action", x, ie, [L], H, C))[L.route.id]; if (ie.signal.aborted) { pe.get(C) === ne && pe.delete(C); return } if (f.v7_fetcherPersist && Me.has(C)) { if (Pr(ae) || dt(ae)) { Nn(C, Ln(void 0)); return } } else { if (Pr(ae)) if (pe.delete(C), U > Fe) { Nn(C, Ln(void 0)); return } else return Z.add(C), Nn(C, ls(G)), vr(ie, ae, !1, { fetcherSubmission: G, preventScrollReset: W }); if (dt(ae)) { en(C, _, ae.error); return } } if (Kn(ae)) throw nt(400, { type: "defer-action" }); let Ce = x.navigation.location || x.location, Xr = ti(t.history, Ce, ne.signal), Ji = l || o, tn = x.navigation.state !== "idle" ? Er(Ji, x.navigation.location, a) : x.matches; ee(tn, "Didn't find any matches after fetcher action"); let Ht = ++A; z.set(C, Ht); let Xl = ls(G, ae.data); x.fetchers.set(C, Xl); let [Xi, yr] = wh(t.history, x, tn, G, Ce, !1, f.v7_skipActionErrorRevalidation, B, J, de, Me, le, Z, Ji, a, [L.route.id, ae]); yr.filter(ke => ke.key !== C).forEach(ke => { let Zr = ke.key, ip = x.fetchers.get(Zr), Nw = ls(void 0, ip ? ip.data : void 0); x.fetchers.set(Zr, Nw), Rn(Zr), ke.controller && pe.set(Zr, ke.controller) }), Ye({ fetchers: new Map(x.fetchers) }); let _o = () => yr.forEach(ke => Rn(ke.key)); ne.signal.addEventListener("abort", _o); let { loaderResults: Po, fetcherResults: oe } = await Yf(x, tn, Xi, yr, Xr); if (ne.signal.aborted) return; ne.signal.removeEventListener("abort", _o), z.delete(C), pe.delete(C), yr.forEach(ke => pe.delete(ke.key)); let _e = Wo(Po); if (_e) return vr(Xr, _e.result, !1, { preventScrollReset: W }); if (_e = Wo(oe), _e) return Z.add(_e.key), vr(Xr, _e.result, !1, { preventScrollReset: W }); let { loaderData: Qr, errors: Qi } = Th(x, tn, Po, void 0, yr, oe, kt); if (x.fetchers.has(C)) { let ke = Ln(ae.data); x.fetchers.set(C, ke) } Zf(Ht), x.navigation.state === "loading" && Ht > U ? (ee(P, "Expected pending action"), N && N.abort(), Jr(x.navigation.location, { matches: tn, loaderData: Qr, errors: Qi, fetchers: new Map(x.fetchers) })) : (Ye({ errors: Qi, loaderData: Ch(x.loaderData, Qr, tn, Qi), fetchers: new Map(x.fetchers) }), B = !1) } async function bw(C, _, R, L, H, K, X, W, G) { let V = x.fetchers.get(C); Nn(C, ls(G, V ? V.data : void 0), { flushSync: X }); let q = new AbortController, ne = ti(t.history, R, q.signal); if (K) { let ae = await Co(H, R, ne.signal); if (ae.type === "aborted") return; if (ae.type === "error") { en(C, _, ae.error, { flushSync: X }); return } else if (ae.matches) H = ae.matches, L = ws(H, R); else { en(C, _, nt(404, { pathname: R }), { flushSync: X }); return } } pe.set(C, q); let ie = A, me = (await Yi("loader", x, ne, [L], H, C))[L.route.id]; if (Kn(me) && (me = await xf(me, ne.signal, !0) || me), pe.get(C) === q && pe.delete(C), !ne.signal.aborted) { if (Me.has(C)) { Nn(C, Ln(void 0)); return } if (Pr(me)) if (U > ie) { Nn(C, Ln(void 0)); return } else { Z.add(C), await vr(ne, me, !1, { preventScrollReset: W }); return } if (dt(me)) { en(C, _, me.error); return } ee(!Kn(me), "Unhandled fetcher deferred data"), Nn(C, Ln(me.data)) } } async function vr(C, _, R, L) { let { submission: H, fetcherSubmission: K, preventScrollReset: X, replace: W } = L === void 0 ? {} : L; _.response.headers.has("X-Remix-Revalidate") && (B = !0); let G = _.response.headers.get("Location"); ee(G, "Expected a Location header on the redirect Response"), G = Eh(G, new URL(C.url), a); let V = Zs(x.location, G, { _isRedirect: !0 }); if (n) { let ae = !1; if (_.response.headers.has("X-Remix-Reload-Document")) ae = !0; else if (wf.test(G)) { const Ce = t.history.createURL(G); ae = Ce.origin !== e.location.origin || En(Ce.pathname, a) == null } if (ae) { W ? e.location.replace(G) : e.location.assign(G); return } } N = null; let q = W === !0 || _.response.headers.has("X-Remix-Replace") ? Ne.Replace : Ne.Push, { formMethod: ne, formAction: ie, formEncType: Fe } = x.navigation; !H && !K && ne && ie && Fe && (H = kh(x.navigation)); let me = H || K; if (AS.has(_.response.status) && me && jt(me.formMethod)) await gr(q, V, { submission: xe({}, me, { formAction: G }), preventScrollReset: X || I, enableViewTransition: R ? k : void 0 }); else { let ae = _c(V, H); await gr(q, V, { overrideNavigation: ae, fetcherSubmission: K, preventScrollReset: X || I, enableViewTransition: R ? k : void 0 }) } } async function Yi(C, _, R, L, H, K) { let X, W = {}; try { X = await BS(c, C, _, R, L, H, K, s, i) } catch (G) { return L.forEach(V => { W[V.route.id] = { type: fe.error, error: G } }), W } for (let [G, V] of Object.entries(X)) if (qS(V)) { let q = V.result; W[G] = { type: fe.redirect, response: WS(q, R, G, H, a, f.v7_relativeSplatPath) } } else W[G] = await VS(V); return W } async function Yf(C, _, R, L, H) { let K = C.matches, X = Yi("loader", C, H, R, _, null), W = Promise.all(L.map(async q => { if (q.matches && q.match && q.controller) { let ie = (await Yi("loader", C, ti(t.history, q.path, q.controller.signal), [q.match], q.matches, q.key))[q.match.route.id]; return { [q.key]: ie } } else return Promise.resolve({ [q.key]: { type: fe.error, error: nt(404, { pathname: q.path }) } }) })), G = await X, V = (await W).reduce((q, ne) => Object.assign(q, ne), {}); return await Promise.all([XS(_, G, H.signal, K, C.loaderData), QS(_, V, L)]), { loaderResults: G, fetcherResults: V } } function ql() { B = !0, J.push(...Jl()), le.forEach((C, _) => { pe.has(_) && de.add(_), Rn(_) }) } function Nn(C, _, R) { R === void 0 && (R = {}), x.fetchers.set(C, _), Ye({ fetchers: new Map(x.fetchers) }, { flushSync: (R && R.flushSync) === !0 }) } function en(C, _, R, L) { L === void 0 && (L = {}); let H = br(x.matches, _); Eo(C), Ye({ errors: { [H.route.id]: R }, fetchers: new Map(x.fetchers) }, { flushSync: (L && L.flushSync) === !0 }) } function Jf(C) { return f.v7_fetcherPersist && (Bt.set(C, (Bt.get(C) || 0) + 1), Me.has(C) && Me.delete(C)), x.fetchers.get(C) || LS } function Eo(C) { let _ = x.fetchers.get(C); pe.has(C) && !(_ && _.state === "loading" && z.has(C)) && Rn(C), le.delete(C), z.delete(C), Z.delete(C), Me.delete(C), de.delete(C), x.fetchers.delete(C) } function Tw(C) { if (f.v7_fetcherPersist) { let _ = (Bt.get(C) || 0) - 1; _ <= 0 ? (Bt.delete(C), Me.add(C)) : Bt.set(C, _) } else Eo(C); Ye({ fetchers: new Map(x.fetchers) }) } function Rn(C) { let _ = pe.get(C); _ && (_.abort(), pe.delete(C)) } function Xf(C) { for (let _ of C) { let R = Jf(_), L = Ln(R.data); x.fetchers.set(_, L) } } function Qf() { let C = [], _ = !1; for (let R of Z) { let L = x.fetchers.get(R); ee(L, "Expected fetcher: " + R), L.state === "loading" && (Z.delete(R), C.push(R), _ = !0) } return Xf(C), _ } function Zf(C) { let _ = []; for (let [R, L] of z) if (L < C) { let H = x.fetchers.get(R); ee(H, "Expected fetcher: " + R), H.state === "loading" && (Rn(R), z.delete(R), _.push(R)) } return Xf(_), _.length > 0 } function Cw(C, _) { let R = x.blockers.get(C) || as; return qe.get(C) !== _ && qe.set(C, _), R } function ep(C) { x.blockers.delete(C), qe.delete(C) } function bo(C, _) { let R = x.blockers.get(C) || as; ee(R.state === "unblocked" && _.state === "blocked" || R.state === "blocked" && _.state === "blocked" || R.state === "blocked" && _.state === "proceeding" || R.state === "blocked" && _.state === "unblocked" || R.state === "proceeding" && _.state === "unblocked", "Invalid blocker state transition: " + R.state + " -> " + _.state); let L = new Map(x.blockers); L.set(C, _), Ye({ blockers: L }) } function tp(C) { let { currentLocation: _, nextLocation: R, historyAction: L } = C; if (qe.size === 0) return; qe.size > 1 && Mi(!1, "A router only supports one blocker at a time"); let H = Array.from(qe.entries()), [K, X] = H[H.length - 1], W = x.blockers.get(K); if (!(W && W.state === "proceeding") && X({ currentLocation: _, nextLocation: R, historyAction: L })) return K } function Yl(C) { let _ = nt(404, { pathname: C }), R = l || o, { matches: L, route: H } = Ph(R); return Jl(), { notFoundMatches: L, route: H, error: _ } } function Jl(C) { let _ = []; return kt.forEach((R, L) => { (!C || C(L)) && (R.cancel(), _.push(L), kt.delete(L)) }), _ } function _w(C, _, R) { if (g = C, E = _, w = R || null, !v && x.navigation === Cc) { v = !0; let L = rp(x.location, x.matches); L != null && Ye({ restoreScrollPosition: L }) } return () => { g = null, E = null, w = null } } function np(C, _) { return w && w(C, _.map(L => fS(L, x.loaderData))) || C.key } function Pw(C, _) { if (g && E) { let R = np(C, _); g[R] = E() } } function rp(C, _) { if (g) { let R = np(C, _), L = g[R]; if (typeof L == "number") return L } return null } function To(C, _, R) { if (u) if (C) { if (Object.keys(C[0].params).length > 0) return { active: !0, matches: ua(_, R, a, !0) } } else return { active: !0, matches: ua(_, R, a, !0) || [] }; return { active: !1, matches: null } } async function Co(C, _, R) { if (!u) return { type: "success", matches: C }; let L = C; for (; ;) { let H = l == null, K = l || o, X = s; try { await u({ path: _, matches: L, patch: (V, q) => { R.aborted || Sh(V, q, K, X, i) } }) } catch (V) { return { type: "error", error: V, partialMatches: L } } finally { H && !R.aborted && (o = [...o]) } if (R.aborted) return { type: "aborted" }; let W = Er(K, _, a); if (W) return { type: "success", matches: W }; let G = ua(K, _, a, !0); if (!G || L.length === G.length && L.every((V, q) => V.route.id === G[q].route.id)) return { type: "success", matches: null }; L = G } } function Iw(C) { s = {}, l = Ya(C, i, void 0, s) } function kw(C, _) { let R = l == null; Sh(C, _, l || o, s, i), R && (o = [...o], Ye({})) } return T = { get basename() { return a }, get future() { return f }, get state() { return x }, get routes() { return o }, get window() { return e }, initialize: hw, subscribe: gw, enableScrollRestoration: _w, navigate: Kf, fetch: Sw, revalidate: vw, createHref: C => t.history.createHref(C), encodeLocation: C => t.history.encodeLocation(C), getFetcher: Jf, deleteFetcher: Tw, dispose: mw, getBlocker: Cw, deleteBlocker: ep, patchRoutes: kw, _internalFetchControllers: pe, _internalActiveDeferreds: kt, _internalSetRoutes: Iw }, T } function FS(t) { return t != null && ("formData" in t && t.formData != null || "body" in t && t.body !== void 0) } function Hu(t, e, n, r, i, s, o, l) { let a, c; if (o) { a = []; for (let f of e) if (a.push(f), f.route.id === o) { c = f; break } } else a = e, c = e[e.length - 1]; let u = Ol(i || ".", Rl(a, s), En(t.pathname, n) || t.pathname, l === "path"); if (i == null && (u.search = t.search, u.hash = t.hash), (i == null || i === "" || i === ".") && c) { let f = Sf(u.search); if (c.route.index && !f) u.search = u.search ? u.search.replace(/^\?/, "?index&") : "?index"; else if (!c.route.index && f) { let h = new URLSearchParams(u.search), y = h.getAll("index"); h.delete("index"), y.filter(w => w).forEach(w => h.append("index", w)); let g = h.toString(); u.search = g ? "?" + g : "" } } return r && n !== "/" && (u.pathname = u.pathname === "/" ? n : mn([n, u.pathname])), Ur(u) } function vh(t, e, n, r) {
  if (!r || !FS(r)) return { path: n }; if (r.formMethod && !JS(r.formMethod)) return { path: n, error: nt(405, { method: r.formMethod }) }; let i = () => ({ path: n, error: nt(400, { type: "invalid-body" }) }), s = r.formMethod || "get", o = t ? s.toUpperCase() : s.toLowerCase(), l = ly(n); if (r.body !== void 0) {
    if (r.formEncType === "text/plain") {
      if (!jt(o)) return i(); let h = typeof r.body == "string" ? r.body : r.body instanceof FormData || r.body instanceof URLSearchParams ? Array.from(r.body.entries()).reduce((y, g) => {
        let [w, E] = g; return "" + y + w + "=" + E + `
`}, "") : String(r.body); return { path: n, submission: { formMethod: o, formAction: l, formEncType: r.formEncType, formData: void 0, json: void 0, text: h } }
    } else if (r.formEncType === "application/json") { if (!jt(o)) return i(); try { let h = typeof r.body == "string" ? JSON.parse(r.body) : r.body; return { path: n, submission: { formMethod: o, formAction: l, formEncType: r.formEncType, formData: void 0, json: h, text: void 0 } } } catch { return i() } }
  } ee(typeof FormData == "function", "FormData is not available in this environment"); let a, c; if (r.formData) a = Wu(r.formData), c = r.formData; else if (r.body instanceof FormData) a = Wu(r.body), c = r.body; else if (r.body instanceof URLSearchParams) a = r.body, c = bh(a); else if (r.body == null) a = new URLSearchParams, c = new FormData; else try { a = new URLSearchParams(r.body), c = bh(a) } catch { return i() } let u = { formMethod: o, formAction: l, formEncType: r && r.formEncType || "application/x-www-form-urlencoded", formData: c, json: void 0, text: void 0 }; if (jt(u.formMethod)) return { path: n, submission: u }; let f = ur(n); return e && f.search && Sf(f.search) && a.append("index", ""), f.search = "?" + a, { path: Ur(f), submission: u }
} function yh(t, e, n) { n === void 0 && (n = !1); let r = t.findIndex(i => i.route.id === e); return r >= 0 ? t.slice(0, n ? r + 1 : r) : t } function wh(t, e, n, r, i, s, o, l, a, c, u, f, h, y, g, w) { let E = w ? dt(w[1]) ? w[1].error : w[1].data : void 0, v = t.createURL(e.location), p = t.createURL(i), m = n; s && e.errors ? m = yh(n, Object.keys(e.errors)[0], !0) : w && dt(w[1]) && (m = yh(n, w[0])); let S = w ? w[1].statusCode : void 0, T = o && S && S >= 400, x = m.filter((I, N) => { let { route: k } = I; if (k.lazy) return !0; if (k.loader == null) return !1; if (s) return Vu(k, e.loaderData, e.errors); if (US(e.loaderData, e.matches[N], I) || a.some(D => D === I.route.id)) return !0; let j = e.matches[N], F = I; return xh(I, xe({ currentUrl: v, currentParams: j.params, nextUrl: p, nextParams: F.params }, r, { actionResult: E, actionStatus: S, defaultShouldRevalidate: T ? !1 : l || v.pathname + v.search === p.pathname + p.search || v.search !== p.search || oy(j, F) })) }), P = []; return f.forEach((I, N) => { if (s || !n.some(B => B.route.id === I.routeId) || u.has(N)) return; let k = Er(y, I.path, g); if (!k) { P.push({ key: N, routeId: I.routeId, path: I.path, matches: null, match: null, controller: null }); return } let j = e.fetchers.get(N), F = ws(k, I.path), D = !1; h.has(N) ? D = !1 : c.has(N) ? (c.delete(N), D = !0) : j && j.state !== "idle" && j.data === void 0 ? D = l : D = xh(F, xe({ currentUrl: v, currentParams: e.matches[e.matches.length - 1].params, nextUrl: p, nextParams: n[n.length - 1].params }, r, { actionResult: E, actionStatus: S, defaultShouldRevalidate: T ? !1 : l })), D && P.push({ key: N, routeId: I.routeId, path: I.path, matches: k, match: F, controller: new AbortController }) }), [x, P] } function Vu(t, e, n) { if (t.lazy) return !0; if (!t.loader) return !1; let r = e != null && e[t.id] !== void 0, i = n != null && n[t.id] !== void 0; return !r && i ? !1 : typeof t.loader == "function" && t.loader.hydrate === !0 ? !0 : !r && !i } function US(t, e, n) { let r = !e || n.route.id !== e.route.id, i = t[n.route.id] === void 0; return r || i } function oy(t, e) { let n = t.route.path; return t.pathname !== e.pathname || n != null && n.endsWith("*") && t.params["*"] !== e.params["*"] } function xh(t, e) { if (t.route.shouldRevalidate) { let n = t.route.shouldRevalidate(e); if (typeof n == "boolean") return n } return e.defaultShouldRevalidate } function Sh(t, e, n, r, i) { var s; let o; if (t) { let c = r[t]; ee(c, "No route found to patch children into: routeId = " + t), c.children || (c.children = []), o = c.children } else o = n; let l = e.filter(c => !o.some(u => ay(c, u))), a = Ya(l, i, [t || "_", "patch", String(((s = o) == null ? void 0 : s.length) || "0")], r); o.push(...a) } function ay(t, e) { return "id" in t && "id" in e && t.id === e.id ? !0 : t.index === e.index && t.path === e.path && t.caseSensitive === e.caseSensitive ? (!t.children || t.children.length === 0) && (!e.children || e.children.length === 0) ? !0 : t.children.every((n, r) => { var i; return (i = e.children) == null ? void 0 : i.some(s => ay(n, s)) }) : !1 } async function zS(t, e, n) { if (!t.lazy) return; let r = await t.lazy(); if (!t.lazy) return; let i = n[t.id]; ee(i, "No route found in manifest"); let s = {}; for (let o in r) { let a = i[o] !== void 0 && o !== "hasErrorBoundary"; Mi(!a, 'Route "' + i.id + '" has a static property "' + o + '" defined but its lazy function is also returning a value for this property. ' + ('The lazy route property "' + o + '" will be ignored.')), !a && !uS.has(o) && (s[o] = r[o]) } Object.assign(i, s), Object.assign(i, xe({}, e(i), { lazy: void 0 })) } async function $S(t) { let { matches: e } = t, n = e.filter(i => i.shouldLoad); return (await Promise.all(n.map(i => i.resolve()))).reduce((i, s, o) => Object.assign(i, { [n[o].route.id]: s }), {}) } async function BS(t, e, n, r, i, s, o, l, a, c) { let u = s.map(y => y.route.lazy ? zS(y.route, a, l) : void 0), f = s.map((y, g) => { let w = u[g], E = i.some(p => p.route.id === y.route.id); return xe({}, y, { shouldLoad: E, resolve: async p => (p && r.method === "GET" && (y.route.lazy || y.route.loader) && (E = !0), E ? HS(e, r, y, w, p, c) : Promise.resolve({ type: fe.data, result: void 0 })) }) }), h = await t({ matches: f, request: r, params: s[0].params, fetcherKey: o, context: c }); try { await Promise.all(u) } catch { } return h } async function HS(t, e, n, r, i, s) { let o, l, a = c => { let u, f = new Promise((g, w) => u = w); l = () => u(), e.signal.addEventListener("abort", l); let h = g => typeof c != "function" ? Promise.reject(new Error("You cannot call the handler for a route which defines a boolean " + ('"' + t + '" [routeId: ' + n.route.id + "]"))) : c({ request: e, params: n.params, context: s }, ...g !== void 0 ? [g] : []), y = (async () => { try { return { type: "data", result: await (i ? i(w => h(w)) : h()) } } catch (g) { return { type: "error", result: g } } })(); return Promise.race([y, f]) }; try { let c = n.route[t]; if (r) if (c) { let u, [f] = await Promise.all([a(c).catch(h => { u = h }), r]); if (u !== void 0) throw u; o = f } else if (await r, c = n.route[t], c) o = await a(c); else if (t === "action") { let u = new URL(e.url), f = u.pathname + u.search; throw nt(405, { method: e.method, pathname: f, routeId: n.route.id }) } else return { type: fe.data, result: void 0 }; else if (c) o = await a(c); else { let u = new URL(e.url), f = u.pathname + u.search; throw nt(404, { pathname: f }) } ee(o.result !== void 0, "You defined " + (t === "action" ? "an action" : "a loader") + " for route " + ('"' + n.route.id + "\" but didn't return anything from your `" + t + "` ") + "function. Please return a value or `null`.") } catch (c) { return { type: fe.error, result: c } } finally { l && e.signal.removeEventListener("abort", l) } return o } async function VS(t) { let { result: e, type: n } = t; if (cy(e)) { let c; try { let u = e.headers.get("Content-Type"); u && /\bapplication\/json\b/.test(u) ? e.body == null ? c = null : c = await e.json() : c = await e.text() } catch (u) { return { type: fe.error, error: u } } return n === fe.error ? { type: fe.error, error: new Xa(e.status, e.statusText, c), statusCode: e.status, headers: e.headers } : { type: fe.data, data: c, statusCode: e.status, headers: e.headers } } if (n === fe.error) { if (Ih(e)) { var r; if (e.data instanceof Error) { var i; return { type: fe.error, error: e.data, statusCode: (i = e.init) == null ? void 0 : i.status } } e = new Xa(((r = e.init) == null ? void 0 : r.status) || 500, void 0, e.data) } return { type: fe.error, error: e, statusCode: jl(e) ? e.status : void 0 } } if (YS(e)) { var s, o; return { type: fe.deferred, deferredData: e, statusCode: (s = e.init) == null ? void 0 : s.status, headers: ((o = e.init) == null ? void 0 : o.headers) && new Headers(e.init.headers) } } if (Ih(e)) { var l, a; return { type: fe.data, data: e.data, statusCode: (l = e.init) == null ? void 0 : l.status, headers: (a = e.init) != null && a.headers ? new Headers(e.init.headers) : void 0 } } return { type: fe.data, data: e } } function WS(t, e, n, r, i, s) { let o = t.headers.get("Location"); if (ee(o, "Redirects returned/thrown from loaders/actions must have a Location header"), !wf.test(o)) { let l = r.slice(0, r.findIndex(a => a.route.id === n) + 1); o = Hu(new URL(e.url), l, i, !0, o, s), t.headers.set("Location", o) } return t } function Eh(t, e, n) { if (wf.test(t)) { let r = t, i = r.startsWith("//") ? new URL(e.protocol + r) : new URL(r), s = En(i.pathname, n) != null; if (i.origin === e.origin && s) return i.pathname + i.search + i.hash } return t } function ti(t, e, n, r) { let i = t.createURL(ly(e)).toString(), s = { signal: n }; if (r && jt(r.formMethod)) { let { formMethod: o, formEncType: l } = r; s.method = o.toUpperCase(), l === "application/json" ? (s.headers = new Headers({ "Content-Type": l }), s.body = JSON.stringify(r.json)) : l === "text/plain" ? s.body = r.text : l === "application/x-www-form-urlencoded" && r.formData ? s.body = Wu(r.formData) : s.body = r.formData } return new Request(i, s) } function Wu(t) { let e = new URLSearchParams; for (let [n, r] of t.entries()) e.append(n, typeof r == "string" ? r : r.name); return e } function bh(t) { let e = new FormData; for (let [n, r] of t.entries()) e.append(n, r); return e } function GS(t, e, n, r, i) { let s = {}, o = null, l, a = !1, c = {}, u = n && dt(n[1]) ? n[1].error : void 0; return t.forEach(f => { if (!(f.route.id in e)) return; let h = f.route.id, y = e[h]; if (ee(!Pr(y), "Cannot handle redirect results in processLoaderData"), dt(y)) { let g = y.error; u !== void 0 && (g = u, u = void 0), o = o || {}; { let w = br(t, h); o[w.route.id] == null && (o[w.route.id] = g) } s[h] = void 0, a || (a = !0, l = jl(y.error) ? y.error.status : 500), y.headers && (c[h] = y.headers) } else Kn(y) ? (r.set(h, y.deferredData), s[h] = y.deferredData.data, y.statusCode != null && y.statusCode !== 200 && !a && (l = y.statusCode), y.headers && (c[h] = y.headers)) : (s[h] = y.data, y.statusCode && y.statusCode !== 200 && !a && (l = y.statusCode), y.headers && (c[h] = y.headers)) }), u !== void 0 && n && (o = { [n[0]]: u }, s[n[0]] = void 0), { loaderData: s, errors: o, statusCode: l || 200, loaderHeaders: c } } function Th(t, e, n, r, i, s, o) { let { loaderData: l, errors: a } = GS(e, n, r, o); return i.forEach(c => { let { key: u, match: f, controller: h } = c, y = s[u]; if (ee(y, "Did not find corresponding fetcher result"), !(h && h.signal.aborted)) if (dt(y)) { let g = br(t.matches, f == null ? void 0 : f.route.id); a && a[g.route.id] || (a = xe({}, a, { [g.route.id]: y.error })), t.fetchers.delete(u) } else if (Pr(y)) ee(!1, "Unhandled fetcher revalidation redirect"); else if (Kn(y)) ee(!1, "Unhandled fetcher deferred data"); else { let g = Ln(y.data); t.fetchers.set(u, g) } }), { loaderData: l, errors: a } } function Ch(t, e, n, r) { let i = xe({}, e); for (let s of n) { let o = s.route.id; if (e.hasOwnProperty(o) ? e[o] !== void 0 && (i[o] = e[o]) : t[o] !== void 0 && s.route.loader && (i[o] = t[o]), r && r.hasOwnProperty(o)) break } return i } function _h(t) { return t ? dt(t[1]) ? { actionData: {} } : { actionData: { [t[0]]: t[1].data } } : {} } function br(t, e) { return (e ? t.slice(0, t.findIndex(r => r.route.id === e) + 1) : [...t]).reverse().find(r => r.route.hasErrorBoundary === !0) || t[0] } function Ph(t) { let e = t.length === 1 ? t[0] : t.find(n => n.index || !n.path || n.path === "/") || { id: "__shim-error-route__" }; return { matches: [{ params: {}, pathname: "", pathnameBase: "", route: e }], route: e } } function nt(t, e) { let { pathname: n, routeId: r, method: i, type: s, message: o } = e === void 0 ? {} : e, l = "Unknown Server Error", a = "Unknown @remix-run/router error"; return t === 400 ? (l = "Bad Request", i && n && r ? a = "You made a " + i + ' request to "' + n + '" but ' + ('did not provide a `loader` for route "' + r + '", ') + "so there is no way to handle the request." : s === "defer-action" ? a = "defer() is not supported in actions" : s === "invalid-body" && (a = "Unable to encode submission body")) : t === 403 ? (l = "Forbidden", a = 'Route "' + r + '" does not match URL "' + n + '"') : t === 404 ? (l = "Not Found", a = 'No route matches URL "' + n + '"') : t === 405 && (l = "Method Not Allowed", i && n && r ? a = "You made a " + i.toUpperCase() + ' request to "' + n + '" but ' + ('did not provide an `action` for route "' + r + '", ') + "so there is no way to handle the request." : i && (a = 'Invalid request method "' + i.toUpperCase() + '"')), new Xa(t || 500, l, new Error(a), !0) } function Wo(t) { let e = Object.entries(t); for (let n = e.length - 1; n >= 0; n--) { let [r, i] = e[n]; if (Pr(i)) return { key: r, result: i } } } function ly(t) { let e = typeof t == "string" ? ur(t) : t; return Ur(xe({}, e, { hash: "" })) } function KS(t, e) { return t.pathname !== e.pathname || t.search !== e.search ? !1 : t.hash === "" ? e.hash !== "" : t.hash === e.hash ? !0 : e.hash !== "" } function qS(t) { return cy(t.result) && jS.has(t.result.status) } function Kn(t) { return t.type === fe.deferred } function dt(t) { return t.type === fe.error } function Pr(t) { return (t && t.type) === fe.redirect } function Ih(t) { return typeof t == "object" && t != null && "type" in t && "data" in t && "init" in t && t.type === "DataWithResponseInit" } function YS(t) { let e = t; return e && typeof e == "object" && typeof e.data == "object" && typeof e.subscribe == "function" && typeof e.cancel == "function" && typeof e.resolveData == "function" } function cy(t) { return t != null && typeof t.status == "number" && typeof t.statusText == "string" && typeof t.headers == "object" && typeof t.body < "u" } function JS(t) { return OS.has(t.toLowerCase()) } function jt(t) { return NS.has(t.toLowerCase()) } async function XS(t, e, n, r, i) { let s = Object.entries(e); for (let o = 0; o < s.length; o++) { let [l, a] = s[o], c = t.find(h => (h == null ? void 0 : h.route.id) === l); if (!c) continue; let u = r.find(h => h.route.id === c.route.id), f = u != null && !oy(u, c) && (i && i[c.route.id]) !== void 0; Kn(a) && f && await xf(a, n, !1).then(h => { h && (e[l] = h) }) } } async function QS(t, e, n) { for (let r = 0; r < n.length; r++) { let { key: i, routeId: s, controller: o } = n[r], l = e[i]; t.find(c => (c == null ? void 0 : c.route.id) === s) && Kn(l) && (ee(o, "Expected an AbortController for revalidating fetcher deferred result"), await xf(l, o.signal, !0).then(c => { c && (e[i] = c) })) } } async function xf(t, e, n) { if (n === void 0 && (n = !1), !await t.deferredData.resolveData(e)) { if (n) try { return { type: fe.data, data: t.deferredData.unwrappedData } } catch (i) { return { type: fe.error, error: i } } return { type: fe.data, data: t.deferredData.data } } } function Sf(t) { return new URLSearchParams(t).getAll("index").some(e => e === "") } function ws(t, e) { let n = typeof e == "string" ? ur(e).search : e.search; if (t[t.length - 1].route.index && Sf(n || "")) return t[t.length - 1]; let r = ry(t); return r[r.length - 1] } function kh(t) { let { formMethod: e, formAction: n, formEncType: r, text: i, formData: s, json: o } = t; if (!(!e || !n || !r)) { if (i != null) return { formMethod: e, formAction: n, formEncType: r, formData: void 0, json: void 0, text: i }; if (s != null) return { formMethod: e, formAction: n, formEncType: r, formData: s, json: void 0, text: void 0 }; if (o !== void 0) return { formMethod: e, formAction: n, formEncType: r, formData: void 0, json: o, text: void 0 } } } function _c(t, e) { return e ? { state: "loading", location: t, formMethod: e.formMethod, formAction: e.formAction, formEncType: e.formEncType, formData: e.formData, json: e.json, text: e.text } : { state: "loading", location: t, formMethod: void 0, formAction: void 0, formEncType: void 0, formData: void 0, json: void 0, text: void 0 } } function ZS(t, e) { return { state: "submitting", location: t, formMethod: e.formMethod, formAction: e.formAction, formEncType: e.formEncType, formData: e.formData, json: e.json, text: e.text } } function ls(t, e) { return t ? { state: "loading", formMethod: t.formMethod, formAction: t.formAction, formEncType: t.formEncType, formData: t.formData, json: t.json, text: t.text, data: e } : { state: "loading", formMethod: void 0, formAction: void 0, formEncType: void 0, formData: void 0, json: void 0, text: void 0, data: e } } function eE(t, e) { return { state: "submitting", formMethod: t.formMethod, formAction: t.formAction, formEncType: t.formEncType, formData: t.formData, json: t.json, text: t.text, data: e ? e.data : void 0 } } function Ln(t) { return { state: "idle", formMethod: void 0, formAction: void 0, formEncType: void 0, formData: void 0, json: void 0, text: void 0, data: t } } function tE(t, e) { try { let n = t.sessionStorage.getItem(sy); if (n) { let r = JSON.parse(n); for (let [i, s] of Object.entries(r || {})) s && Array.isArray(s) && e.set(i, new Set(s || [])) } } catch { } } function nE(t, e) { if (e.size > 0) { let n = {}; for (let [r, i] of e) n[r] = [...i]; try { t.sessionStorage.setItem(sy, JSON.stringify(n)) } catch (r) { Mi(!1, "Failed to save applied view transitions in sessionStorage (" + r + ").") } } }/**
 * React Router v6.28.0
 *
 * Copyright (c) Remix Software Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.md file in the root directory of this source tree.
 *
 * @license MIT
 */function Qa() { return Qa = Object.assign ? Object.assign.bind() : function (t) { for (var e = 1; e < arguments.length; e++) { var n = arguments[e]; for (var r in n) Object.prototype.hasOwnProperty.call(n, r) && (t[r] = n[r]) } return t }, Qa.apply(this, arguments) } const uo = b.createContext(null), Ef = b.createContext(null), Pn = b.createContext(null), bf = b.createContext(null), In = b.createContext({ outlet: null, matches: [], isDataRoute: !1 }), uy = b.createContext(null); function rE(t, e) { let { relative: n } = e === void 0 ? {} : e; Wi() || ee(!1); let { basename: r, navigator: i } = b.useContext(Pn), { hash: s, pathname: o, search: l } = Al(t, { relative: n }), a = o; return r !== "/" && (a = o === "/" ? r : mn([r, o])), i.createHref({ pathname: a, search: l, hash: s }) } function Wi() { return b.useContext(bf) != null } function Kr() { return Wi() || ee(!1), b.useContext(bf).location } function dy(t) { b.useContext(Pn).static || b.useLayoutEffect(t) } function qr() { let { isDataRoute: t } = b.useContext(In); return t ? gE() : iE() } function iE() { Wi() || ee(!1); let t = b.useContext(uo), { basename: e, future: n, navigator: r } = b.useContext(Pn), { matches: i } = b.useContext(In), { pathname: s } = Kr(), o = JSON.stringify(Rl(i, n.v7_relativeSplatPath)), l = b.useRef(!1); return dy(() => { l.current = !0 }), b.useCallback(function (c, u) { if (u === void 0 && (u = {}), !l.current) return; if (typeof c == "number") { r.go(c); return } let f = Ol(c, JSON.parse(o), s, u.relative === "path"); t == null && e !== "/" && (f.pathname = f.pathname === "/" ? e : mn([e, f.pathname])), (u.replace ? r.replace : r.push)(f, u.state, u) }, [e, r, o, s, t]) } const sE = b.createContext(null); function oE(t) { let e = b.useContext(In).outlet; return e && b.createElement(sE.Provider, { value: t }, e) } function Al(t, e) { let { relative: n } = e === void 0 ? {} : e, { future: r } = b.useContext(Pn), { matches: i } = b.useContext(In), { pathname: s } = Kr(), o = JSON.stringify(Rl(i, r.v7_relativeSplatPath)); return b.useMemo(() => Ol(t, JSON.parse(o), s, n === "path"), [t, o, s, n]) } function aE(t, e, n, r) { Wi() || ee(!1); let { navigator: i } = b.useContext(Pn), { matches: s } = b.useContext(In), o = s[s.length - 1], l = o ? o.params : {}; o && o.pathname; let a = o ? o.pathnameBase : "/"; o && o.route; let c = Kr(), u; u = c; let f = u.pathname || "/", h = f; if (a !== "/") { let w = a.replace(/^\//, "").split("/"); h = "/" + f.replace(/^\//, "").split("/").slice(w.length).join("/") } let y = Er(t, { pathname: h }); return fE(y && y.map(w => Object.assign({}, w, { params: Object.assign({}, l, w.params), pathname: mn([a, i.encodeLocation ? i.encodeLocation(w.pathname).pathname : w.pathname]), pathnameBase: w.pathnameBase === "/" ? a : mn([a, i.encodeLocation ? i.encodeLocation(w.pathnameBase).pathname : w.pathnameBase]) })), s, n, r) } function lE() { let t = mE(), e = jl(t) ? t.status + " " + t.statusText : t instanceof Error ? t.message : JSON.stringify(t), n = t instanceof Error ? t.stack : null, i = { padding: "0.5rem", backgroundColor: "rgba(200,200,200, 0.5)" }; return b.createElement(b.Fragment, null, b.createElement("h2", null, "Unexpected Application Error!"), b.createElement("h3", { style: { fontStyle: "italic" } }, e), n ? b.createElement("pre", { style: i }, n) : null, null) } const cE = b.createElement(lE, null); class uE extends b.Component { constructor(e) { super(e), this.state = { location: e.location, revalidation: e.revalidation, error: e.error } } static getDerivedStateFromError(e) { return { error: e } } static getDerivedStateFromProps(e, n) { return n.location !== e.location || n.revalidation !== "idle" && e.revalidation === "idle" ? { error: e.error, location: e.location, revalidation: e.revalidation } : { error: e.error !== void 0 ? e.error : n.error, location: n.location, revalidation: e.revalidation || n.revalidation } } componentDidCatch(e, n) { console.error("React Router caught the following error during render", e, n) } render() { return this.state.error !== void 0 ? b.createElement(In.Provider, { value: this.props.routeContext }, b.createElement(uy.Provider, { value: this.state.error, children: this.props.component })) : this.props.children } } function dE(t) { let { routeContext: e, match: n, children: r } = t, i = b.useContext(uo); return i && i.static && i.staticContext && (n.route.errorElement || n.route.ErrorBoundary) && (i.staticContext._deepestRenderedBoundaryId = n.route.id), b.createElement(In.Provider, { value: e }, r) } function fE(t, e, n, r) { var i; if (e === void 0 && (e = []), n === void 0 && (n = null), r === void 0 && (r = null), t == null) { var s; if (!n) return null; if (n.errors) t = n.matches; else if ((s = r) != null && s.v7_partialHydration && e.length === 0 && !n.initialized && n.matches.length > 0) t = n.matches; else return null } let o = t, l = (i = n) == null ? void 0 : i.errors; if (l != null) { let u = o.findIndex(f => f.route.id && (l == null ? void 0 : l[f.route.id]) !== void 0); u >= 0 || ee(!1), o = o.slice(0, Math.min(o.length, u + 1)) } let a = !1, c = -1; if (n && r && r.v7_partialHydration) for (let u = 0; u < o.length; u++) { let f = o[u]; if ((f.route.HydrateFallback || f.route.hydrateFallbackElement) && (c = u), f.route.id) { let { loaderData: h, errors: y } = n, g = f.route.loader && h[f.route.id] === void 0 && (!y || y[f.route.id] === void 0); if (f.route.lazy || g) { a = !0, c >= 0 ? o = o.slice(0, c + 1) : o = [o[0]]; break } } } return o.reduceRight((u, f, h) => { let y, g = !1, w = null, E = null; n && (y = l && f.route.id ? l[f.route.id] : void 0, w = f.route.errorElement || cE, a && (c < 0 && h === 0 ? (vE("route-fallback"), g = !0, E = null) : c === h && (g = !0, E = f.route.hydrateFallbackElement || null))); let v = e.concat(o.slice(0, h + 1)), p = () => { let m; return y ? m = w : g ? m = E : f.route.Component ? m = b.createElement(f.route.Component, null) : f.route.element ? m = f.route.element : m = u, b.createElement(dE, { match: f, routeContext: { outlet: u, matches: v, isDataRoute: n != null }, children: m }) }; return n && (f.route.ErrorBoundary || f.route.errorElement || h === 0) ? b.createElement(uE, { location: n.location, revalidation: n.revalidation, component: w, error: y, children: p(), routeContext: { outlet: null, matches: v, isDataRoute: !0 } }) : p() }, null) } var fy = function (t) { return t.UseBlocker = "useBlocker", t.UseRevalidator = "useRevalidator", t.UseNavigateStable = "useNavigate", t }(fy || {}), Fi = function (t) { return t.UseBlocker = "useBlocker", t.UseLoaderData = "useLoaderData", t.UseActionData = "useActionData", t.UseRouteError = "useRouteError", t.UseNavigation = "useNavigation", t.UseRouteLoaderData = "useRouteLoaderData", t.UseMatches = "useMatches", t.UseRevalidator = "useRevalidator", t.UseNavigateStable = "useNavigate", t.UseRouteId = "useRouteId", t }(Fi || {}); function pE(t) { let e = b.useContext(uo); return e || ee(!1), e } function py(t) { let e = b.useContext(Ef); return e || ee(!1), e } function hE(t) { let e = b.useContext(In); return e || ee(!1), e } function Tf(t) { let e = hE(), n = e.matches[e.matches.length - 1]; return n.route.id || ee(!1), n.route.id } function Ll() { let t = py(Fi.UseLoaderData), e = Tf(Fi.UseLoaderData); if (t.errors && t.errors[e] != null) { console.error("You cannot `useLoaderData` in an errorElement (routeId: " + e + ")"); return } return t.loaderData[e] } function mE() { var t; let e = b.useContext(uy), n = py(Fi.UseRouteError), r = Tf(Fi.UseRouteError); return e !== void 0 ? e : (t = n.errors) == null ? void 0 : t[r] } function gE() { let { router: t } = pE(fy.UseNavigateStable), e = Tf(Fi.UseNavigateStable), n = b.useRef(!1); return dy(() => { n.current = !0 }), b.useCallback(function (i, s) { s === void 0 && (s = {}), n.current && (typeof i == "number" ? t.navigate(i) : t.navigate(i, Qa({ fromRouteId: e }, s))) }, [t, e]) } const Nh = {}; function vE(t, e, n) { Nh[t] || (Nh[t] = !0) } const Rh = {}; function yE(t, e) { Rh[e] || (Rh[e] = !0, console.warn(e)) } const ni = (t, e, n) => yE(t, "⚠️ React Router Future Flag Warning: " + e + ". " + ("You can use the `" + t + "` future flag to opt-in early. ") + ("For more information, see " + n + ".")); function wE(t, e) { t != null && t.v7_startTransition || ni("v7_startTransition", "React Router will begin wrapping state updates in `React.startTransition` in v7", "https://reactrouter.com/v6/upgrading/future#v7_starttransition"), !(t != null && t.v7_relativeSplatPath) && (!e || !e.v7_relativeSplatPath) && ni("v7_relativeSplatPath", "Relative route resolution within Splat routes is changing in v7", "https://reactrouter.com/v6/upgrading/future#v7_relativesplatpath"), e && (e.v7_fetcherPersist || ni("v7_fetcherPersist", "The persistence behavior of fetchers is changing in v7", "https://reactrouter.com/v6/upgrading/future#v7_fetcherpersist"), e.v7_normalizeFormMethod || ni("v7_normalizeFormMethod", "Casing of `formMethod` fields is being normalized to uppercase in v7", "https://reactrouter.com/v6/upgrading/future#v7_normalizeformmethod"), e.v7_partialHydration || ni("v7_partialHydration", "`RouterProvider` hydration behavior is changing in v7", "https://reactrouter.com/v6/upgrading/future#v7_partialhydration"), e.v7_skipActionErrorRevalidation || ni("v7_skipActionErrorRevalidation", "The revalidation behavior after 4xx/5xx `action` responses is changing in v7", "https://reactrouter.com/v6/upgrading/future#v7_skipactionerrorrevalidation")) } function xE(t) { let { to: e, replace: n, state: r, relative: i } = t; Wi() || ee(!1); let { future: s, static: o } = b.useContext(Pn), { matches: l } = b.useContext(In), { pathname: a } = Kr(), c = qr(), u = Ol(e, Rl(l, s.v7_relativeSplatPath), a, i === "path"), f = JSON.stringify(u); return b.useEffect(() => c(JSON.parse(f), { replace: n, state: r, relative: i }), [c, f, i, n, r]), null } function hy(t) { return oE(t.context) } function SE(t) { let { basename: e = "/", children: n = null, location: r, navigationType: i = Ne.Pop, navigator: s, static: o = !1, future: l } = t; Wi() && ee(!1); let a = e.replace(/^\/*/, "/"), c = b.useMemo(() => ({ basename: a, navigator: s, static: o, future: Qa({ v7_relativeSplatPath: !1 }, l) }), [a, l, s, o]); typeof r == "string" && (r = ur(r)); let { pathname: u = "/", search: f = "", hash: h = "", state: y = null, key: g = "default" } = r, w = b.useMemo(() => { let E = En(u, a); return E == null ? null : { location: { pathname: E, search: f, hash: h, state: y, key: g }, navigationType: i } }, [a, u, f, h, y, g, i]); return w == null ? null : b.createElement(Pn.Provider, { value: c }, b.createElement(bf.Provider, { children: n, value: w })) } new Promise(() => { }); function EE(t) { let e = { hasErrorBoundary: t.ErrorBoundary != null || t.errorElement != null }; return t.Component && Object.assign(e, { element: b.createElement(t.Component), Component: void 0 }), t.HydrateFallback && Object.assign(e, { hydrateFallbackElement: b.createElement(t.HydrateFallback), HydrateFallback: void 0 }), t.ErrorBoundary && Object.assign(e, { errorElement: b.createElement(t.ErrorBoundary), ErrorBoundary: void 0 }), e }/**
 * React Router DOM v6.28.0
 *
 * Copyright (c) Remix Software Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.md file in the root directory of this source tree.
 *
 * @license MIT
 */function Ui() { return Ui = Object.assign ? Object.assign.bind() : function (t) { for (var e = 1; e < arguments.length; e++) { var n = arguments[e]; for (var r in n) Object.prototype.hasOwnProperty.call(n, r) && (t[r] = n[r]) } return t }, Ui.apply(this, arguments) } function my(t, e) { if (t == null) return {}; var n = {}, r = Object.keys(t), i, s; for (s = 0; s < r.length; s++)i = r[s], !(e.indexOf(i) >= 0) && (n[i] = t[i]); return n } function bE(t) { return !!(t.metaKey || t.altKey || t.ctrlKey || t.shiftKey) } function TE(t, e) { return t.button === 0 && (!e || e === "_self") && !bE(t) } const CE = ["onClick", "relative", "reloadDocument", "replace", "state", "target", "to", "preventScrollReset", "viewTransition"], _E = ["aria-current", "caseSensitive", "className", "end", "style", "to", "viewTransition", "children"], PE = "6"; try { window.__reactRouterVersion = PE } catch { } function IE(t, e) { return MS({ basename: void 0, future: Ui({}, void 0, { v7_prependBasename: !0 }), history: aS({ window: void 0 }), hydrationData: kE(), routes: t, mapRouteProperties: EE, dataStrategy: void 0, patchRoutesOnNavigation: void 0, window: void 0 }).initialize() } function kE() { var t; let e = (t = window) == null ? void 0 : t.__staticRouterHydrationData; return e && e.errors && (e = Ui({}, e, { errors: NE(e.errors) })), e } function NE(t) { if (!t) return null; let e = Object.entries(t), n = {}; for (let [r, i] of e) if (i && i.__type === "RouteErrorResponse") n[r] = new Xa(i.status, i.statusText, i.data, i.internal === !0); else if (i && i.__type === "Error") { if (i.__subType) { let s = window[i.__subType]; if (typeof s == "function") try { let o = new s(i.message); o.stack = "", n[r] = o } catch { } } if (n[r] == null) { let s = new Error(i.message); s.stack = "", n[r] = s } } else n[r] = i; return n } const gy = b.createContext({ isTransitioning: !1 }), RE = b.createContext(new Map), OE = "startTransition", Oh = qw[OE], jE = "flushSync", jh = oS[jE]; function AE(t) { Oh ? Oh(t) : t() } function cs(t) { jh ? jh(t) : t() } let LE = class { constructor() { this.status = "pending", this.promise = new Promise((e, n) => { this.resolve = r => { this.status === "pending" && (this.status = "resolved", e(r)) }, this.reject = r => { this.status === "pending" && (this.status = "rejected", n(r)) } }) } }; function DE(t) { let { fallbackElement: e, router: n, future: r } = t, [i, s] = b.useState(n.state), [o, l] = b.useState(), [a, c] = b.useState({ isTransitioning: !1 }), [u, f] = b.useState(), [h, y] = b.useState(), [g, w] = b.useState(), E = b.useRef(new Map), { v7_startTransition: v } = r || {}, p = b.useCallback(I => { v ? AE(I) : I() }, [v]), m = b.useCallback((I, N) => { let { deletedFetchers: k, flushSync: j, viewTransitionOpts: F } = N; k.forEach(B => E.current.delete(B)), I.fetchers.forEach((B, J) => { B.data !== void 0 && E.current.set(J, B.data) }); let D = n.window == null || n.window.document == null || typeof n.window.document.startViewTransition != "function"; if (!F || D) { j ? cs(() => s(I)) : p(() => s(I)); return } if (j) { cs(() => { h && (u && u.resolve(), h.skipTransition()), c({ isTransitioning: !0, flushSync: !0, currentLocation: F.currentLocation, nextLocation: F.nextLocation }) }); let B = n.window.document.startViewTransition(() => { cs(() => s(I)) }); B.finished.finally(() => { cs(() => { f(void 0), y(void 0), l(void 0), c({ isTransitioning: !1 }) }) }), cs(() => y(B)); return } h ? (u && u.resolve(), h.skipTransition(), w({ state: I, currentLocation: F.currentLocation, nextLocation: F.nextLocation })) : (l(I), c({ isTransitioning: !0, flushSync: !1, currentLocation: F.currentLocation, nextLocation: F.nextLocation })) }, [n.window, h, u, E, p]); b.useLayoutEffect(() => n.subscribe(m), [n, m]), b.useEffect(() => { a.isTransitioning && !a.flushSync && f(new LE) }, [a]), b.useEffect(() => { if (u && o && n.window) { let I = o, N = u.promise, k = n.window.document.startViewTransition(async () => { p(() => s(I)), await N }); k.finished.finally(() => { f(void 0), y(void 0), l(void 0), c({ isTransitioning: !1 }) }), y(k) } }, [p, o, u, n.window]), b.useEffect(() => { u && o && i.location.key === o.location.key && u.resolve() }, [u, h, i.location, o]), b.useEffect(() => { !a.isTransitioning && g && (l(g.state), c({ isTransitioning: !0, flushSync: !1, currentLocation: g.currentLocation, nextLocation: g.nextLocation }), w(void 0)) }, [a.isTransitioning, g]), b.useEffect(() => { }, []); let S = b.useMemo(() => ({ createHref: n.createHref, encodeLocation: n.encodeLocation, go: I => n.navigate(I), push: (I, N, k) => n.navigate(I, { state: N, preventScrollReset: k == null ? void 0 : k.preventScrollReset }), replace: (I, N, k) => n.navigate(I, { replace: !0, state: N, preventScrollReset: k == null ? void 0 : k.preventScrollReset }) }), [n]), T = n.basename || "/", x = b.useMemo(() => ({ router: n, navigator: S, static: !1, basename: T }), [n, S, T]), P = b.useMemo(() => ({ v7_relativeSplatPath: n.future.v7_relativeSplatPath }), [n.future.v7_relativeSplatPath]); return b.useEffect(() => wE(r, n.future), [r, n.future]), b.createElement(b.Fragment, null, b.createElement(uo.Provider, { value: x }, b.createElement(Ef.Provider, { value: i }, b.createElement(RE.Provider, { value: E.current }, b.createElement(gy.Provider, { value: a }, b.createElement(SE, { basename: T, location: i.location, navigationType: i.historyAction, navigator: S, future: P }, i.initialized || n.future.v7_partialHydration ? b.createElement(ME, { routes: n.routes, future: n.future, state: i }) : e))))), null) } const ME = b.memo(FE); function FE(t) { let { routes: e, future: n, state: r } = t; return aE(e, void 0, r, n) } const UE = typeof window < "u" && typeof window.document < "u" && typeof window.document.createElement < "u", zE = /^(?:[a-z][a-z0-9+.-]*:|\/\/)/i, dr = b.forwardRef(function (e, n) { let { onClick: r, relative: i, reloadDocument: s, replace: o, state: l, target: a, to: c, preventScrollReset: u, viewTransition: f } = e, h = my(e, CE), { basename: y } = b.useContext(Pn), g, w = !1; if (typeof c == "string" && zE.test(c) && (g = c, UE)) try { let m = new URL(window.location.href), S = c.startsWith("//") ? new URL(m.protocol + c) : new URL(c), T = En(S.pathname, y); S.origin === m.origin && T != null ? c = T + S.search + S.hash : w = !0 } catch { } let E = rE(c, { relative: i }), v = BE(c, { replace: o, state: l, target: a, preventScrollReset: u, relative: i, viewTransition: f }); function p(m) { r && r(m), m.defaultPrevented || v(m) } return b.createElement("a", Ui({}, h, { href: g || E, onClick: w || s ? r : p, ref: n, target: a })) }), St = b.forwardRef(function (e, n) { let { "aria-current": r = "page", caseSensitive: i = !1, className: s = "", end: o = !1, style: l, to: a, viewTransition: c, children: u } = e, f = my(e, _E), h = Al(a, { relative: f.relative }), y = Kr(), g = b.useContext(Ef), { navigator: w, basename: E } = b.useContext(Pn), v = g != null && HE(h) && c === !0, p = w.encodeLocation ? w.encodeLocation(h).pathname : h.pathname, m = y.pathname, S = g && g.navigation && g.navigation.location ? g.navigation.location.pathname : null; i || (m = m.toLowerCase(), S = S ? S.toLowerCase() : null, p = p.toLowerCase()), S && E && (S = En(S, E) || S); const T = p !== "/" && p.endsWith("/") ? p.length - 1 : p.length; let x = m === p || !o && m.startsWith(p) && m.charAt(T) === "/", P = S != null && (S === p || !o && S.startsWith(p) && S.charAt(p.length) === "/"), I = { isActive: x, isPending: P, isTransitioning: v }, N = x ? r : void 0, k; typeof s == "function" ? k = s(I) : k = [s, x ? "active" : null, P ? "pending" : null, v ? "transitioning" : null].filter(Boolean).join(" "); let j = typeof l == "function" ? l(I) : l; return b.createElement(dr, Ui({}, f, { "aria-current": N, className: k, ref: n, style: j, to: a, viewTransition: c }), typeof u == "function" ? u(I) : u) }); var Gu; (function (t) { t.UseScrollRestoration = "useScrollRestoration", t.UseSubmit = "useSubmit", t.UseSubmitFetcher = "useSubmitFetcher", t.UseFetcher = "useFetcher", t.useViewTransitionState = "useViewTransitionState" })(Gu || (Gu = {})); var Ah; (function (t) { t.UseFetcher = "useFetcher", t.UseFetchers = "useFetchers", t.UseScrollRestoration = "useScrollRestoration" })(Ah || (Ah = {})); function $E(t) { let e = b.useContext(uo); return e || ee(!1), e } function BE(t, e) { let { target: n, replace: r, state: i, preventScrollReset: s, relative: o, viewTransition: l } = e === void 0 ? {} : e, a = qr(), c = Kr(), u = Al(t, { relative: o }); return b.useCallback(f => { if (TE(f, n)) { f.preventDefault(); let h = r !== void 0 ? r : Ur(c) === Ur(u); a(t, { replace: h, state: i, preventScrollReset: s, relative: o, viewTransition: l }) } }, [c, a, u, r, i, n, t, s, o, l]) } function HE(t, e) { e === void 0 && (e = {}); let n = b.useContext(gy); n == null && ee(!1); let { basename: r } = $E(Gu.useViewTransitionState), i = Al(t, { relative: e.relative }); if (!n.isTransitioning) return !1; let s = En(n.currentLocation.pathname, r) || n.currentLocation.pathname, o = En(n.nextLocation.pathname, r) || n.nextLocation.pathname; return Ja(i.pathname, o) != null || Ja(i.pathname, s) != null } const Dl = "/assets/logo-B8UCsoil.png"; var Lh = {};/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */const vy = function (t) { const e = []; let n = 0; for (let r = 0; r < t.length; r++) { let i = t.charCodeAt(r); i < 128 ? e[n++] = i : i < 2048 ? (e[n++] = i >> 6 | 192, e[n++] = i & 63 | 128) : (i & 64512) === 55296 && r + 1 < t.length && (t.charCodeAt(r + 1) & 64512) === 56320 ? (i = 65536 + ((i & 1023) << 10) + (t.charCodeAt(++r) & 1023), e[n++] = i >> 18 | 240, e[n++] = i >> 12 & 63 | 128, e[n++] = i >> 6 & 63 | 128, e[n++] = i & 63 | 128) : (e[n++] = i >> 12 | 224, e[n++] = i >> 6 & 63 | 128, e[n++] = i & 63 | 128) } return e }, VE = function (t) { const e = []; let n = 0, r = 0; for (; n < t.length;) { const i = t[n++]; if (i < 128) e[r++] = String.fromCharCode(i); else if (i > 191 && i < 224) { const s = t[n++]; e[r++] = String.fromCharCode((i & 31) << 6 | s & 63) } else if (i > 239 && i < 365) { const s = t[n++], o = t[n++], l = t[n++], a = ((i & 7) << 18 | (s & 63) << 12 | (o & 63) << 6 | l & 63) - 65536; e[r++] = String.fromCharCode(55296 + (a >> 10)), e[r++] = String.fromCharCode(56320 + (a & 1023)) } else { const s = t[n++], o = t[n++]; e[r++] = String.fromCharCode((i & 15) << 12 | (s & 63) << 6 | o & 63) } } return e.join("") }, yy = { byteToCharMap_: null, charToByteMap_: null, byteToCharMapWebSafe_: null, charToByteMapWebSafe_: null, ENCODED_VALS_BASE: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789", get ENCODED_VALS() { return this.ENCODED_VALS_BASE + "+/=" }, get ENCODED_VALS_WEBSAFE() { return this.ENCODED_VALS_BASE + "-_." }, HAS_NATIVE_SUPPORT: typeof atob == "function", encodeByteArray(t, e) { if (!Array.isArray(t)) throw Error("encodeByteArray takes an array as a parameter"); this.init_(); const n = e ? this.byteToCharMapWebSafe_ : this.byteToCharMap_, r = []; for (let i = 0; i < t.length; i += 3) { const s = t[i], o = i + 1 < t.length, l = o ? t[i + 1] : 0, a = i + 2 < t.length, c = a ? t[i + 2] : 0, u = s >> 2, f = (s & 3) << 4 | l >> 4; let h = (l & 15) << 2 | c >> 6, y = c & 63; a || (y = 64, o || (h = 64)), r.push(n[u], n[f], n[h], n[y]) } return r.join("") }, encodeString(t, e) { return this.HAS_NATIVE_SUPPORT && !e ? btoa(t) : this.encodeByteArray(vy(t), e) }, decodeString(t, e) { return this.HAS_NATIVE_SUPPORT && !e ? atob(t) : VE(this.decodeStringToByteArray(t, e)) }, decodeStringToByteArray(t, e) { this.init_(); const n = e ? this.charToByteMapWebSafe_ : this.charToByteMap_, r = []; for (let i = 0; i < t.length;) { const s = n[t.charAt(i++)], l = i < t.length ? n[t.charAt(i)] : 0; ++i; const c = i < t.length ? n[t.charAt(i)] : 64; ++i; const f = i < t.length ? n[t.charAt(i)] : 64; if (++i, s == null || l == null || c == null || f == null) throw new WE; const h = s << 2 | l >> 4; if (r.push(h), c !== 64) { const y = l << 4 & 240 | c >> 2; if (r.push(y), f !== 64) { const g = c << 6 & 192 | f; r.push(g) } } } return r }, init_() { if (!this.byteToCharMap_) { this.byteToCharMap_ = {}, this.charToByteMap_ = {}, this.byteToCharMapWebSafe_ = {}, this.charToByteMapWebSafe_ = {}; for (let t = 0; t < this.ENCODED_VALS.length; t++)this.byteToCharMap_[t] = this.ENCODED_VALS.charAt(t), this.charToByteMap_[this.byteToCharMap_[t]] = t, this.byteToCharMapWebSafe_[t] = this.ENCODED_VALS_WEBSAFE.charAt(t), this.charToByteMapWebSafe_[this.byteToCharMapWebSafe_[t]] = t, t >= this.ENCODED_VALS_BASE.length && (this.charToByteMap_[this.ENCODED_VALS_WEBSAFE.charAt(t)] = t, this.charToByteMapWebSafe_[this.ENCODED_VALS.charAt(t)] = t) } } }; class WE extends Error { constructor() { super(...arguments), this.name = "DecodeBase64StringError" } } const GE = function (t) { const e = vy(t); return yy.encodeByteArray(e, !0) }, wy = function (t) { return GE(t).replace(/\./g, "") }, xy = function (t) { try { return yy.decodeString(t, !0) } catch (e) { console.error("base64Decode failed: ", e) } return null };/**
 * @license
 * Copyright 2022 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */function KE() { if (typeof self < "u") return self; if (typeof window < "u") return window; if (typeof global < "u") return global; throw new Error("Unable to locate global object.") }/**
 * @license
 * Copyright 2022 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */const qE = () => KE().__FIREBASE_DEFAULTS__, YE = () => { if (typeof process > "u" || typeof Lh > "u") return; const t = Lh.__FIREBASE_DEFAULTS__; if (t) return JSON.parse(t) }, JE = () => { if (typeof document > "u") return; let t; try { t = document.cookie.match(/__FIREBASE_DEFAULTS__=([^;]+)/) } catch { return } const e = t && xy(t[1]); return e && JSON.parse(e) }, Cf = () => { try { return qE() || YE() || JE() } catch (t) { console.info(`Unable to get __FIREBASE_DEFAULTS__ due to: ${t}`); return } }, XE = t => { var e, n; return (n = (e = Cf()) === null || e === void 0 ? void 0 : e.emulatorHosts) === null || n === void 0 ? void 0 : n[t] }, Sy = () => { var t; return (t = Cf()) === null || t === void 0 ? void 0 : t.config }, Ey = t => { var e; return (e = Cf()) === null || e === void 0 ? void 0 : e[`_${t}`] };/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */class QE { constructor() { this.reject = () => { }, this.resolve = () => { }, this.promise = new Promise((e, n) => { this.resolve = e, this.reject = n }) } wrapCallback(e) { return (n, r) => { n ? this.reject(n) : this.resolve(r), typeof e == "function" && (this.promise.catch(() => { }), e.length === 1 ? e(n) : e(n, r)) } } }/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */function Ze() { return typeof navigator < "u" && typeof navigator.userAgent == "string" ? navigator.userAgent : "" } function ZE() { return typeof window < "u" && !!(window.cordova || window.phonegap || window.PhoneGap) && /ios|iphone|ipod|ipad|android|blackberry|iemobile/i.test(Ze()) } function eb() { return typeof navigator < "u" && navigator.userAgent === "Cloudflare-Workers" } function tb() { const t = typeof chrome == "object" ? chrome.runtime : typeof browser == "object" ? browser.runtime : void 0; return typeof t == "object" && t.id !== void 0 } function nb() { return typeof navigator == "object" && navigator.product === "ReactNative" } function rb() { const t = Ze(); return t.indexOf("MSIE ") >= 0 || t.indexOf("Trident/") >= 0 } function ib() { try { return typeof indexedDB == "object" } catch { return !1 } } function sb() { return new Promise((t, e) => { try { let n = !0; const r = "validate-browser-context-for-indexeddb-analytics-module", i = self.indexedDB.open(r); i.onsuccess = () => { i.result.close(), n || self.indexedDB.deleteDatabase(r), t(!0) }, i.onupgradeneeded = () => { n = !1 }, i.onerror = () => { var s; e(((s = i.error) === null || s === void 0 ? void 0 : s.message) || "") } } catch (n) { e(n) } }) }/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */const ob = "FirebaseError"; class fr extends Error { constructor(e, n, r) { super(n), this.code = e, this.customData = r, this.name = ob, Object.setPrototypeOf(this, fr.prototype), Error.captureStackTrace && Error.captureStackTrace(this, fo.prototype.create) } } class fo { constructor(e, n, r) { this.service = e, this.serviceName = n, this.errors = r } create(e, ...n) { const r = n[0] || {}, i = `${this.service}/${e}`, s = this.errors[e], o = s ? ab(s, r) : "Error", l = `${this.serviceName}: ${o} (${i}).`; return new fr(i, l, r) } } function ab(t, e) { return t.replace(lb, (n, r) => { const i = e[r]; return i != null ? String(i) : `<${r}?>` }) } const lb = /\{\$([^}]+)}/g; function cb(t) { for (const e in t) if (Object.prototype.hasOwnProperty.call(t, e)) return !1; return !0 } function Za(t, e) { if (t === e) return !0; const n = Object.keys(t), r = Object.keys(e); for (const i of n) { if (!r.includes(i)) return !1; const s = t[i], o = e[i]; if (Dh(s) && Dh(o)) { if (!Za(s, o)) return !1 } else if (s !== o) return !1 } for (const i of r) if (!n.includes(i)) return !1; return !0 } function Dh(t) { return t !== null && typeof t == "object" }/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */function po(t) { const e = []; for (const [n, r] of Object.entries(t)) Array.isArray(r) ? r.forEach(i => { e.push(encodeURIComponent(n) + "=" + encodeURIComponent(i)) }) : e.push(encodeURIComponent(n) + "=" + encodeURIComponent(r)); return e.length ? "&" + e.join("&") : "" } function xs(t) { const e = {}; return t.replace(/^\?/, "").split("&").forEach(r => { if (r) { const [i, s] = r.split("="); e[decodeURIComponent(i)] = decodeURIComponent(s) } }), e } function Ss(t) { const e = t.indexOf("?"); if (!e) return ""; const n = t.indexOf("#", e); return t.substring(e, n > 0 ? n : void 0) } function ub(t, e) { const n = new db(t, e); return n.subscribe.bind(n) } class db { constructor(e, n) { this.observers = [], this.unsubscribes = [], this.observerCount = 0, this.task = Promise.resolve(), this.finalized = !1, this.onNoObservers = n, this.task.then(() => { e(this) }).catch(r => { this.error(r) }) } next(e) { this.forEachObserver(n => { n.next(e) }) } error(e) { this.forEachObserver(n => { n.error(e) }), this.close(e) } complete() { this.forEachObserver(e => { e.complete() }), this.close() } subscribe(e, n, r) { let i; if (e === void 0 && n === void 0 && r === void 0) throw new Error("Missing Observer."); fb(e, ["next", "error", "complete"]) ? i = e : i = { next: e, error: n, complete: r }, i.next === void 0 && (i.next = Pc), i.error === void 0 && (i.error = Pc), i.complete === void 0 && (i.complete = Pc); const s = this.unsubscribeOne.bind(this, this.observers.length); return this.finalized && this.task.then(() => { try { this.finalError ? i.error(this.finalError) : i.complete() } catch { } }), this.observers.push(i), s } unsubscribeOne(e) { this.observers === void 0 || this.observers[e] === void 0 || (delete this.observers[e], this.observerCount -= 1, this.observerCount === 0 && this.onNoObservers !== void 0 && this.onNoObservers(this)) } forEachObserver(e) { if (!this.finalized) for (let n = 0; n < this.observers.length; n++)this.sendOne(n, e) } sendOne(e, n) { this.task.then(() => { if (this.observers !== void 0 && this.observers[e] !== void 0) try { n(this.observers[e]) } catch (r) { typeof console < "u" && console.error && console.error(r) } }) } close(e) { this.finalized || (this.finalized = !0, e !== void 0 && (this.finalError = e), this.task.then(() => { this.observers = void 0, this.onNoObservers = void 0 })) } } function fb(t, e) { if (typeof t != "object" || t === null) return !1; for (const n of e) if (n in t && typeof t[n] == "function") return !0; return !1 } function Pc() { }/**
 * @license
 * Copyright 2021 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */function Qt(t) { return t && t._delegate ? t._delegate : t } class zi { constructor(e, n, r) { this.name = e, this.instanceFactory = n, this.type = r, this.multipleInstances = !1, this.serviceProps = {}, this.instantiationMode = "LAZY", this.onInstanceCreated = null } setInstantiationMode(e) { return this.instantiationMode = e, this } setMultipleInstances(e) { return this.multipleInstances = e, this } setServiceProps(e) { return this.serviceProps = e, this } setInstanceCreatedCallback(e) { return this.onInstanceCreated = e, this } }/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */const Sr = "[DEFAULT]";/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */class pb { constructor(e, n) { this.name = e, this.container = n, this.component = null, this.instances = new Map, this.instancesDeferred = new Map, this.instancesOptions = new Map, this.onInitCallbacks = new Map } get(e) { const n = this.normalizeInstanceIdentifier(e); if (!this.instancesDeferred.has(n)) { const r = new QE; if (this.instancesDeferred.set(n, r), this.isInitialized(n) || this.shouldAutoInitialize()) try { const i = this.getOrInitializeService({ instanceIdentifier: n }); i && r.resolve(i) } catch { } } return this.instancesDeferred.get(n).promise } getImmediate(e) { var n; const r = this.normalizeInstanceIdentifier(e == null ? void 0 : e.identifier), i = (n = e == null ? void 0 : e.optional) !== null && n !== void 0 ? n : !1; if (this.isInitialized(r) || this.shouldAutoInitialize()) try { return this.getOrInitializeService({ instanceIdentifier: r }) } catch (s) { if (i) return null; throw s } else { if (i) return null; throw Error(`Service ${this.name} is not available`) } } getComponent() { return this.component } setComponent(e) { if (e.name !== this.name) throw Error(`Mismatching Component ${e.name} for Provider ${this.name}.`); if (this.component) throw Error(`Component for ${this.name} has already been provided`); if (this.component = e, !!this.shouldAutoInitialize()) { if (mb(e)) try { this.getOrInitializeService({ instanceIdentifier: Sr }) } catch { } for (const [n, r] of this.instancesDeferred.entries()) { const i = this.normalizeInstanceIdentifier(n); try { const s = this.getOrInitializeService({ instanceIdentifier: i }); r.resolve(s) } catch { } } } } clearInstance(e = Sr) { this.instancesDeferred.delete(e), this.instancesOptions.delete(e), this.instances.delete(e) } async delete() { const e = Array.from(this.instances.values()); await Promise.all([...e.filter(n => "INTERNAL" in n).map(n => n.INTERNAL.delete()), ...e.filter(n => "_delete" in n).map(n => n._delete())]) } isComponentSet() { return this.component != null } isInitialized(e = Sr) { return this.instances.has(e) } getOptions(e = Sr) { return this.instancesOptions.get(e) || {} } initialize(e = {}) { const { options: n = {} } = e, r = this.normalizeInstanceIdentifier(e.instanceIdentifier); if (this.isInitialized(r)) throw Error(`${this.name}(${r}) has already been initialized`); if (!this.isComponentSet()) throw Error(`Component ${this.name} has not been registered yet`); const i = this.getOrInitializeService({ instanceIdentifier: r, options: n }); for (const [s, o] of this.instancesDeferred.entries()) { const l = this.normalizeInstanceIdentifier(s); r === l && o.resolve(i) } return i } onInit(e, n) { var r; const i = this.normalizeInstanceIdentifier(n), s = (r = this.onInitCallbacks.get(i)) !== null && r !== void 0 ? r : new Set; s.add(e), this.onInitCallbacks.set(i, s); const o = this.instances.get(i); return o && e(o, i), () => { s.delete(e) } } invokeOnInitCallbacks(e, n) { const r = this.onInitCallbacks.get(n); if (r) for (const i of r) try { i(e, n) } catch { } } getOrInitializeService({ instanceIdentifier: e, options: n = {} }) { let r = this.instances.get(e); if (!r && this.component && (r = this.component.instanceFactory(this.container, { instanceIdentifier: hb(e), options: n }), this.instances.set(e, r), this.instancesOptions.set(e, n), this.invokeOnInitCallbacks(r, e), this.component.onInstanceCreated)) try { this.component.onInstanceCreated(this.container, e, r) } catch { } return r || null } normalizeInstanceIdentifier(e = Sr) { return this.component ? this.component.multipleInstances ? e : Sr : e } shouldAutoInitialize() { return !!this.component && this.component.instantiationMode !== "EXPLICIT" } } function hb(t) { return t === Sr ? void 0 : t } function mb(t) { return t.instantiationMode === "EAGER" }/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */class gb { constructor(e) { this.name = e, this.providers = new Map } addComponent(e) { const n = this.getProvider(e.name); if (n.isComponentSet()) throw new Error(`Component ${e.name} has already been registered with ${this.name}`); n.setComponent(e) } addOrOverwriteComponent(e) { this.getProvider(e.name).isComponentSet() && this.providers.delete(e.name), this.addComponent(e) } getProvider(e) { if (this.providers.has(e)) return this.providers.get(e); const n = new pb(e, this); return this.providers.set(e, n), n } getProviders() { return Array.from(this.providers.values()) } }/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */var he; (function (t) { t[t.DEBUG = 0] = "DEBUG", t[t.VERBOSE = 1] = "VERBOSE", t[t.INFO = 2] = "INFO", t[t.WARN = 3] = "WARN", t[t.ERROR = 4] = "ERROR", t[t.SILENT = 5] = "SILENT" })(he || (he = {})); const vb = { debug: he.DEBUG, verbose: he.VERBOSE, info: he.INFO, warn: he.WARN, error: he.ERROR, silent: he.SILENT }, yb = he.INFO, wb = { [he.DEBUG]: "log", [he.VERBOSE]: "log", [he.INFO]: "info", [he.WARN]: "warn", [he.ERROR]: "error" }, xb = (t, e, ...n) => { if (e < t.logLevel) return; const r = new Date().toISOString(), i = wb[e]; if (i) console[i](`[${r}]  ${t.name}:`, ...n); else throw new Error(`Attempted to log a message with an invalid logType (value: ${e})`) }; class by { constructor(e) { this.name = e, this._logLevel = yb, this._logHandler = xb, this._userLogHandler = null } get logLevel() { return this._logLevel } set logLevel(e) { if (!(e in he)) throw new TypeError(`Invalid value "${e}" assigned to \`logLevel\``); this._logLevel = e } setLogLevel(e) { this._logLevel = typeof e == "string" ? vb[e] : e } get logHandler() { return this._logHandler } set logHandler(e) { if (typeof e != "function") throw new TypeError("Value assigned to `logHandler` must be a function"); this._logHandler = e } get userLogHandler() { return this._userLogHandler } set userLogHandler(e) { this._userLogHandler = e } debug(...e) { this._userLogHandler && this._userLogHandler(this, he.DEBUG, ...e), this._logHandler(this, he.DEBUG, ...e) } log(...e) { this._userLogHandler && this._userLogHandler(this, he.VERBOSE, ...e), this._logHandler(this, he.VERBOSE, ...e) } info(...e) { this._userLogHandler && this._userLogHandler(this, he.INFO, ...e), this._logHandler(this, he.INFO, ...e) } warn(...e) { this._userLogHandler && this._userLogHandler(this, he.WARN, ...e), this._logHandler(this, he.WARN, ...e) } error(...e) { this._userLogHandler && this._userLogHandler(this, he.ERROR, ...e), this._logHandler(this, he.ERROR, ...e) } } const Sb = (t, e) => e.some(n => t instanceof n); let Mh, Fh; function Eb() { return Mh || (Mh = [IDBDatabase, IDBObjectStore, IDBIndex, IDBCursor, IDBTransaction]) } function bb() { return Fh || (Fh = [IDBCursor.prototype.advance, IDBCursor.prototype.continue, IDBCursor.prototype.continuePrimaryKey]) } const Ty = new WeakMap, Ku = new WeakMap, Cy = new WeakMap, Ic = new WeakMap, _f = new WeakMap; function Tb(t) { const e = new Promise((n, r) => { const i = () => { t.removeEventListener("success", s), t.removeEventListener("error", o) }, s = () => { n(rr(t.result)), i() }, o = () => { r(t.error), i() }; t.addEventListener("success", s), t.addEventListener("error", o) }); return e.then(n => { n instanceof IDBCursor && Ty.set(n, t) }).catch(() => { }), _f.set(e, t), e } function Cb(t) { if (Ku.has(t)) return; const e = new Promise((n, r) => { const i = () => { t.removeEventListener("complete", s), t.removeEventListener("error", o), t.removeEventListener("abort", o) }, s = () => { n(), i() }, o = () => { r(t.error || new DOMException("AbortError", "AbortError")), i() }; t.addEventListener("complete", s), t.addEventListener("error", o), t.addEventListener("abort", o) }); Ku.set(t, e) } let qu = { get(t, e, n) { if (t instanceof IDBTransaction) { if (e === "done") return Ku.get(t); if (e === "objectStoreNames") return t.objectStoreNames || Cy.get(t); if (e === "store") return n.objectStoreNames[1] ? void 0 : n.objectStore(n.objectStoreNames[0]) } return rr(t[e]) }, set(t, e, n) { return t[e] = n, !0 }, has(t, e) { return t instanceof IDBTransaction && (e === "done" || e === "store") ? !0 : e in t } }; function _b(t) { qu = t(qu) } function Pb(t) { return t === IDBDatabase.prototype.transaction && !("objectStoreNames" in IDBTransaction.prototype) ? function (e, ...n) { const r = t.call(kc(this), e, ...n); return Cy.set(r, e.sort ? e.sort() : [e]), rr(r) } : bb().includes(t) ? function (...e) { return t.apply(kc(this), e), rr(Ty.get(this)) } : function (...e) { return rr(t.apply(kc(this), e)) } } function Ib(t) { return typeof t == "function" ? Pb(t) : (t instanceof IDBTransaction && Cb(t), Sb(t, Eb()) ? new Proxy(t, qu) : t) } function rr(t) { if (t instanceof IDBRequest) return Tb(t); if (Ic.has(t)) return Ic.get(t); const e = Ib(t); return e !== t && (Ic.set(t, e), _f.set(e, t)), e } const kc = t => _f.get(t); function kb(t, e, { blocked: n, upgrade: r, blocking: i, terminated: s } = {}) { const o = indexedDB.open(t, e), l = rr(o); return r && o.addEventListener("upgradeneeded", a => { r(rr(o.result), a.oldVersion, a.newVersion, rr(o.transaction), a) }), n && o.addEventListener("blocked", a => n(a.oldVersion, a.newVersion, a)), l.then(a => { s && a.addEventListener("close", () => s()), i && a.addEventListener("versionchange", c => i(c.oldVersion, c.newVersion, c)) }).catch(() => { }), l } const Nb = ["get", "getKey", "getAll", "getAllKeys", "count"], Rb = ["put", "add", "delete", "clear"], Nc = new Map; function Uh(t, e) { if (!(t instanceof IDBDatabase && !(e in t) && typeof e == "string")) return; if (Nc.get(e)) return Nc.get(e); const n = e.replace(/FromIndex$/, ""), r = e !== n, i = Rb.includes(n); if (!(n in (r ? IDBIndex : IDBObjectStore).prototype) || !(i || Nb.includes(n))) return; const s = async function (o, ...l) { const a = this.transaction(o, i ? "readwrite" : "readonly"); let c = a.store; return r && (c = c.index(l.shift())), (await Promise.all([c[n](...l), i && a.done]))[0] }; return Nc.set(e, s), s } _b(t => ({ ...t, get: (e, n, r) => Uh(e, n) || t.get(e, n, r), has: (e, n) => !!Uh(e, n) || t.has(e, n) }));/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */class Ob { constructor(e) { this.container = e } getPlatformInfoString() { return this.container.getProviders().map(n => { if (jb(n)) { const r = n.getImmediate(); return `${r.library}/${r.version}` } else return null }).filter(n => n).join(" ") } } function jb(t) { const e = t.getComponent(); return (e == null ? void 0 : e.type) === "VERSION" } const Yu = "@firebase/app", zh = "0.10.16";/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */const bn = new by("@firebase/app"), Ab = "@firebase/app-compat", Lb = "@firebase/analytics-compat", Db = "@firebase/analytics", Mb = "@firebase/app-check-compat", Fb = "@firebase/app-check", Ub = "@firebase/auth", zb = "@firebase/auth-compat", $b = "@firebase/database", Bb = "@firebase/data-connect", Hb = "@firebase/database-compat", Vb = "@firebase/functions", Wb = "@firebase/functions-compat", Gb = "@firebase/installations", Kb = "@firebase/installations-compat", qb = "@firebase/messaging", Yb = "@firebase/messaging-compat", Jb = "@firebase/performance", Xb = "@firebase/performance-compat", Qb = "@firebase/remote-config", Zb = "@firebase/remote-config-compat", eT = "@firebase/storage", tT = "@firebase/storage-compat", nT = "@firebase/firestore", rT = "@firebase/vertexai", iT = "@firebase/firestore-compat", sT = "firebase", oT = "11.0.2";/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */const Ju = "[DEFAULT]", aT = { [Yu]: "fire-core", [Ab]: "fire-core-compat", [Db]: "fire-analytics", [Lb]: "fire-analytics-compat", [Fb]: "fire-app-check", [Mb]: "fire-app-check-compat", [Ub]: "fire-auth", [zb]: "fire-auth-compat", [$b]: "fire-rtdb", [Bb]: "fire-data-connect", [Hb]: "fire-rtdb-compat", [Vb]: "fire-fn", [Wb]: "fire-fn-compat", [Gb]: "fire-iid", [Kb]: "fire-iid-compat", [qb]: "fire-fcm", [Yb]: "fire-fcm-compat", [Jb]: "fire-perf", [Xb]: "fire-perf-compat", [Qb]: "fire-rc", [Zb]: "fire-rc-compat", [eT]: "fire-gcs", [tT]: "fire-gcs-compat", [nT]: "fire-fst", [iT]: "fire-fst-compat", [rT]: "fire-vertex", "fire-js": "fire-js", [sT]: "fire-js-all" };/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */const el = new Map, lT = new Map, Xu = new Map; function $h(t, e) { try { t.container.addComponent(e) } catch (n) { bn.debug(`Component ${e.name} failed to register with FirebaseApp ${t.name}`, n) } } function eo(t) { const e = t.name; if (Xu.has(e)) return bn.debug(`There were multiple attempts to register component ${e}.`), !1; Xu.set(e, t); for (const n of el.values()) $h(n, t); for (const n of lT.values()) $h(n, t); return !0 } function _y(t, e) { const n = t.container.getProvider("heartbeat").getImmediate({ optional: !0 }); return n && n.triggerHeartbeat(), t.container.getProvider(e) } function Lt(t) { return t.settings !== void 0 }/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */const cT = { "no-app": "No Firebase App '{$appName}' has been created - call initializeApp() first", "bad-app-name": "Illegal App name: '{$appName}'", "duplicate-app": "Firebase App named '{$appName}' already exists with different options or config", "app-deleted": "Firebase App named '{$appName}' already deleted", "server-app-deleted": "Firebase Server App has been deleted", "no-options": "Need to provide options, when not being deployed to hosting via source.", "invalid-app-argument": "firebase.{$appName}() takes either no argument or a Firebase App instance.", "invalid-log-argument": "First argument to `onLog` must be null or a function.", "idb-open": "Error thrown when opening IndexedDB. Original error: {$originalErrorMessage}.", "idb-get": "Error thrown when reading from IndexedDB. Original error: {$originalErrorMessage}.", "idb-set": "Error thrown when writing to IndexedDB. Original error: {$originalErrorMessage}.", "idb-delete": "Error thrown when deleting from IndexedDB. Original error: {$originalErrorMessage}.", "finalization-registry-not-supported": "FirebaseServerApp deleteOnDeref field defined but the JS runtime does not support FinalizationRegistry.", "invalid-server-app-environment": "FirebaseServerApp is not for use in browser environments." }, ir = new fo("app", "Firebase", cT);/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */class uT { constructor(e, n, r) { this._isDeleted = !1, this._options = Object.assign({}, e), this._config = Object.assign({}, n), this._name = n.name, this._automaticDataCollectionEnabled = n.automaticDataCollectionEnabled, this._container = r, this.container.addComponent(new zi("app", () => this, "PUBLIC")) } get automaticDataCollectionEnabled() { return this.checkDestroyed(), this._automaticDataCollectionEnabled } set automaticDataCollectionEnabled(e) { this.checkDestroyed(), this._automaticDataCollectionEnabled = e } get name() { return this.checkDestroyed(), this._name } get options() { return this.checkDestroyed(), this._options } get config() { return this.checkDestroyed(), this._config } get container() { return this._container } get isDeleted() { return this._isDeleted } set isDeleted(e) { this._isDeleted = e } checkDestroyed() { if (this.isDeleted) throw ir.create("app-deleted", { appName: this._name }) } }/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */const ho = oT; function Py(t, e = {}) { let n = t; typeof e != "object" && (e = { name: e }); const r = Object.assign({ name: Ju, automaticDataCollectionEnabled: !1 }, e), i = r.name; if (typeof i != "string" || !i) throw ir.create("bad-app-name", { appName: String(i) }); if (n || (n = Sy()), !n) throw ir.create("no-options"); const s = el.get(i); if (s) { if (Za(n, s.options) && Za(r, s.config)) return s; throw ir.create("duplicate-app", { appName: i }) } const o = new gb(i); for (const a of Xu.values()) o.addComponent(a); const l = new uT(n, r, o); return el.set(i, l), l } function dT(t = Ju) { const e = el.get(t); if (!e && t === Ju && Sy()) return Py(); if (!e) throw ir.create("no-app", { appName: t }); return e } function bi(t, e, n) { var r; let i = (r = aT[t]) !== null && r !== void 0 ? r : t; n && (i += `-${n}`); const s = i.match(/\s|\//), o = e.match(/\s|\//); if (s || o) { const l = [`Unable to register library "${i}" with version "${e}":`]; s && l.push(`library name "${i}" contains illegal characters (whitespace or "/")`), s && o && l.push("and"), o && l.push(`version name "${e}" contains illegal characters (whitespace or "/")`), bn.warn(l.join(" ")); return } eo(new zi(`${i}-version`, () => ({ library: i, version: e }), "VERSION")) }/**
 * @license
 * Copyright 2021 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */const fT = "firebase-heartbeat-database", pT = 1, to = "firebase-heartbeat-store"; let Rc = null; function Iy() { return Rc || (Rc = kb(fT, pT, { upgrade: (t, e) => { switch (e) { case 0: try { t.createObjectStore(to) } catch (n) { console.warn(n) } } } }).catch(t => { throw ir.create("idb-open", { originalErrorMessage: t.message }) })), Rc } async function hT(t) { try { const n = (await Iy()).transaction(to), r = await n.objectStore(to).get(ky(t)); return await n.done, r } catch (e) { if (e instanceof fr) bn.warn(e.message); else { const n = ir.create("idb-get", { originalErrorMessage: e == null ? void 0 : e.message }); bn.warn(n.message) } } } async function Bh(t, e) { try { const r = (await Iy()).transaction(to, "readwrite"); await r.objectStore(to).put(e, ky(t)), await r.done } catch (n) { if (n instanceof fr) bn.warn(n.message); else { const r = ir.create("idb-set", { originalErrorMessage: n == null ? void 0 : n.message }); bn.warn(r.message) } } } function ky(t) { return `${t.name}!${t.options.appId}` }/**
 * @license
 * Copyright 2021 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */const mT = 1024, gT = 30 * 24 * 60 * 60 * 1e3; class vT { constructor(e) { this.container = e, this._heartbeatsCache = null; const n = this.container.getProvider("app").getImmediate(); this._storage = new wT(n), this._heartbeatsCachePromise = this._storage.read().then(r => (this._heartbeatsCache = r, r)) } async triggerHeartbeat() { var e, n; try { const i = this.container.getProvider("platform-logger").getImmediate().getPlatformInfoString(), s = Hh(); return ((e = this._heartbeatsCache) === null || e === void 0 ? void 0 : e.heartbeats) == null && (this._heartbeatsCache = await this._heartbeatsCachePromise, ((n = this._heartbeatsCache) === null || n === void 0 ? void 0 : n.heartbeats) == null) || this._heartbeatsCache.lastSentHeartbeatDate === s || this._heartbeatsCache.heartbeats.some(o => o.date === s) ? void 0 : (this._heartbeatsCache.heartbeats.push({ date: s, agent: i }), this._heartbeatsCache.heartbeats = this._heartbeatsCache.heartbeats.filter(o => { const l = new Date(o.date).valueOf(); return Date.now() - l <= gT }), this._storage.overwrite(this._heartbeatsCache)) } catch (r) { bn.warn(r) } } async getHeartbeatsHeader() { var e; try { if (this._heartbeatsCache === null && await this._heartbeatsCachePromise, ((e = this._heartbeatsCache) === null || e === void 0 ? void 0 : e.heartbeats) == null || this._heartbeatsCache.heartbeats.length === 0) return ""; const n = Hh(), { heartbeatsToSend: r, unsentEntries: i } = yT(this._heartbeatsCache.heartbeats), s = wy(JSON.stringify({ version: 2, heartbeats: r })); return this._heartbeatsCache.lastSentHeartbeatDate = n, i.length > 0 ? (this._heartbeatsCache.heartbeats = i, await this._storage.overwrite(this._heartbeatsCache)) : (this._heartbeatsCache.heartbeats = [], this._storage.overwrite(this._heartbeatsCache)), s } catch (n) { return bn.warn(n), "" } } } function Hh() { return new Date().toISOString().substring(0, 10) } function yT(t, e = mT) { const n = []; let r = t.slice(); for (const i of t) { const s = n.find(o => o.agent === i.agent); if (s) { if (s.dates.push(i.date), Vh(n) > e) { s.dates.pop(); break } } else if (n.push({ agent: i.agent, dates: [i.date] }), Vh(n) > e) { n.pop(); break } r = r.slice(1) } return { heartbeatsToSend: n, unsentEntries: r } } class wT { constructor(e) { this.app = e, this._canUseIndexedDBPromise = this.runIndexedDBEnvironmentCheck() } async runIndexedDBEnvironmentCheck() { return ib() ? sb().then(() => !0).catch(() => !1) : !1 } async read() { if (await this._canUseIndexedDBPromise) { const n = await hT(this.app); return n != null && n.heartbeats ? n : { heartbeats: [] } } else return { heartbeats: [] } } async overwrite(e) { var n; if (await this._canUseIndexedDBPromise) { const i = await this.read(); return Bh(this.app, { lastSentHeartbeatDate: (n = e.lastSentHeartbeatDate) !== null && n !== void 0 ? n : i.lastSentHeartbeatDate, heartbeats: e.heartbeats }) } else return } async add(e) { var n; if (await this._canUseIndexedDBPromise) { const i = await this.read(); return Bh(this.app, { lastSentHeartbeatDate: (n = e.lastSentHeartbeatDate) !== null && n !== void 0 ? n : i.lastSentHeartbeatDate, heartbeats: [...i.heartbeats, ...e.heartbeats] }) } else return } } function Vh(t) { return wy(JSON.stringify({ version: 2, heartbeats: t })).length }/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */function xT(t) { eo(new zi("platform-logger", e => new Ob(e), "PRIVATE")), eo(new zi("heartbeat", e => new vT(e), "PRIVATE")), bi(Yu, zh, t), bi(Yu, zh, "esm2017"), bi("fire-js", "") } xT(""); function Pf(t, e) { var n = {}; for (var r in t) Object.prototype.hasOwnProperty.call(t, r) && e.indexOf(r) < 0 && (n[r] = t[r]); if (t != null && typeof Object.getOwnPropertySymbols == "function") for (var i = 0, r = Object.getOwnPropertySymbols(t); i < r.length; i++)e.indexOf(r[i]) < 0 && Object.prototype.propertyIsEnumerable.call(t, r[i]) && (n[r[i]] = t[r[i]]); return n } function Ny() { return { "dependent-sdk-initialized-before-auth": "Another Firebase SDK was initialized and is trying to use Auth before Auth is initialized. Please be sure to call `initializeAuth` or `getAuth` before starting any other Firebase SDK." } } const ST = Ny, Ry = new fo("auth", "Firebase", Ny());/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */const tl = new by("@firebase/auth"); function ET(t, ...e) { tl.logLevel <= he.WARN && tl.warn(`Auth (${ho}): ${t}`, ...e) } function da(t, ...e) { tl.logLevel <= he.ERROR && tl.error(`Auth (${ho}): ${t}`, ...e) }/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */function It(t, ...e) { throw kf(t, ...e) } function Ut(t, ...e) { return kf(t, ...e) } function If(t, e, n) { const r = Object.assign(Object.assign({}, ST()), { [e]: n }); return new fo("auth", "Firebase", r).create(e, { appName: t.name }) } function gn(t) { return If(t, "operation-not-supported-in-this-environment", "Operations that alter the current user are not supported in conjunction with FirebaseServerApp") } function bT(t, e, n) { const r = n; if (!(e instanceof r)) throw r.name !== e.constructor.name && It(t, "argument-error"), If(t, "argument-error", `Type of ${e.constructor.name} does not match expected instance.Did you pass a reference from a different Auth SDK?`) } function kf(t, ...e) { if (typeof t != "string") { const n = e[0], r = [...e.slice(1)]; return r[0] && (r[0].appName = t.name), t._errorFactory.create(n, ...r) } return Ry.create(t, ...e) } function Y(t, e, ...n) { if (!t) throw kf(e, ...n) } function dn(t) { const e = "INTERNAL ASSERTION FAILED: " + t; throw da(e), new Error(e) } function Tn(t, e) { t || dn(e) }/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */function Qu() { var t; return typeof self < "u" && ((t = self.location) === null || t === void 0 ? void 0 : t.href) || "" } function TT() { return Wh() === "http:" || Wh() === "https:" } function Wh() { var t; return typeof self < "u" && ((t = self.location) === null || t === void 0 ? void 0 : t.protocol) || null }/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */function CT() { return typeof navigator < "u" && navigator && "onLine" in navigator && typeof navigator.onLine == "boolean" && (TT() || tb() || "connection" in navigator) ? navigator.onLine : !0 } function _T() { if (typeof navigator > "u") return null; const t = navigator; return t.languages && t.languages[0] || t.language || null }/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */class mo { constructor(e, n) { this.shortDelay = e, this.longDelay = n, Tn(n > e, "Short delay should be less than long delay!"), this.isMobile = ZE() || nb() } get() { return CT() ? this.isMobile ? this.longDelay : this.shortDelay : Math.min(5e3, this.shortDelay) } }/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */function Nf(t, e) { Tn(t.emulator, "Emulator should always be set here"); const { url: n } = t.emulator; return e ? `${n}${e.startsWith("/") ? e.slice(1) : e}` : n }/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */class Oy { static initialize(e, n, r) { this.fetchImpl = e, n && (this.headersImpl = n), r && (this.responseImpl = r) } static fetch() { if (this.fetchImpl) return this.fetchImpl; if (typeof self < "u" && "fetch" in self) return self.fetch; if (typeof globalThis < "u" && globalThis.fetch) return globalThis.fetch; if (typeof fetch < "u") return fetch; dn("Could not find fetch implementation, make sure you call FetchProvider.initialize() with an appropriate polyfill") } static headers() { if (this.headersImpl) return this.headersImpl; if (typeof self < "u" && "Headers" in self) return self.Headers; if (typeof globalThis < "u" && globalThis.Headers) return globalThis.Headers; if (typeof Headers < "u") return Headers; dn("Could not find Headers implementation, make sure you call FetchProvider.initialize() with an appropriate polyfill") } static response() { if (this.responseImpl) return this.responseImpl; if (typeof self < "u" && "Response" in self) return self.Response; if (typeof globalThis < "u" && globalThis.Response) return globalThis.Response; if (typeof Response < "u") return Response; dn("Could not find Response implementation, make sure you call FetchProvider.initialize() with an appropriate polyfill") } }/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */const PT = { CREDENTIAL_MISMATCH: "custom-token-mismatch", MISSING_CUSTOM_TOKEN: "internal-error", INVALID_IDENTIFIER: "invalid-email", MISSING_CONTINUE_URI: "internal-error", INVALID_PASSWORD: "wrong-password", MISSING_PASSWORD: "missing-password", INVALID_LOGIN_CREDENTIALS: "invalid-credential", EMAIL_EXISTS: "email-already-in-use", PASSWORD_LOGIN_DISABLED: "operation-not-allowed", INVALID_IDP_RESPONSE: "invalid-credential", INVALID_PENDING_TOKEN: "invalid-credential", FEDERATED_USER_ID_ALREADY_LINKED: "credential-already-in-use", MISSING_REQ_TYPE: "internal-error", EMAIL_NOT_FOUND: "user-not-found", RESET_PASSWORD_EXCEED_LIMIT: "too-many-requests", EXPIRED_OOB_CODE: "expired-action-code", INVALID_OOB_CODE: "invalid-action-code", MISSING_OOB_CODE: "internal-error", CREDENTIAL_TOO_OLD_LOGIN_AGAIN: "requires-recent-login", INVALID_ID_TOKEN: "invalid-user-token", TOKEN_EXPIRED: "user-token-expired", USER_NOT_FOUND: "user-token-expired", TOO_MANY_ATTEMPTS_TRY_LATER: "too-many-requests", PASSWORD_DOES_NOT_MEET_REQUIREMENTS: "password-does-not-meet-requirements", INVALID_CODE: "invalid-verification-code", INVALID_SESSION_INFO: "invalid-verification-id", INVALID_TEMPORARY_PROOF: "invalid-credential", MISSING_SESSION_INFO: "missing-verification-id", SESSION_EXPIRED: "code-expired", MISSING_ANDROID_PACKAGE_NAME: "missing-android-pkg-name", UNAUTHORIZED_DOMAIN: "unauthorized-continue-uri", INVALID_OAUTH_CLIENT_ID: "invalid-oauth-client-id", ADMIN_ONLY_OPERATION: "admin-restricted-operation", INVALID_MFA_PENDING_CREDENTIAL: "invalid-multi-factor-session", MFA_ENROLLMENT_NOT_FOUND: "multi-factor-info-not-found", MISSING_MFA_ENROLLMENT_ID: "missing-multi-factor-info", MISSING_MFA_PENDING_CREDENTIAL: "missing-multi-factor-session", SECOND_FACTOR_EXISTS: "second-factor-already-in-use", SECOND_FACTOR_LIMIT_EXCEEDED: "maximum-second-factor-count-exceeded", BLOCKING_FUNCTION_ERROR_RESPONSE: "internal-error", RECAPTCHA_NOT_ENABLED: "recaptcha-not-enabled", MISSING_RECAPTCHA_TOKEN: "missing-recaptcha-token", INVALID_RECAPTCHA_TOKEN: "invalid-recaptcha-token", INVALID_RECAPTCHA_ACTION: "invalid-recaptcha-action", MISSING_CLIENT_TYPE: "missing-client-type", MISSING_RECAPTCHA_VERSION: "missing-recaptcha-version", INVALID_RECAPTCHA_VERSION: "invalid-recaptcha-version", INVALID_REQ_TYPE: "invalid-req-type" };/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */const IT = new mo(3e4, 6e4); function pr(t, e) { return t.tenantId && !e.tenantId ? Object.assign(Object.assign({}, e), { tenantId: t.tenantId }) : e } async function kn(t, e, n, r, i = {}) { return jy(t, i, async () => { let s = {}, o = {}; r && (e === "GET" ? o = r : s = { body: JSON.stringify(r) }); const l = po(Object.assign({ key: t.config.apiKey }, o)).slice(1), a = await t._getAdditionalHeaders(); a["Content-Type"] = "application/json", t.languageCode && (a["X-Firebase-Locale"] = t.languageCode); const c = Object.assign({ method: e, headers: a }, s); return eb() || (c.referrerPolicy = "no-referrer"), Oy.fetch()(Ay(t, t.config.apiHost, n, l), c) }) } async function jy(t, e, n) { t._canInitEmulator = !1; const r = Object.assign(Object.assign({}, PT), e); try { const i = new NT(t), s = await Promise.race([n(), i.promise]); i.clearNetworkTimeout(); const o = await s.json(); if ("needConfirmation" in o) throw Go(t, "account-exists-with-different-credential", o); if (s.ok && !("errorMessage" in o)) return o; { const l = s.ok ? o.errorMessage : o.error.message, [a, c] = l.split(" : "); if (a === "FEDERATED_USER_ID_ALREADY_LINKED") throw Go(t, "credential-already-in-use", o); if (a === "EMAIL_EXISTS") throw Go(t, "email-already-in-use", o); if (a === "USER_DISABLED") throw Go(t, "user-disabled", o); const u = r[a] || a.toLowerCase().replace(/[_\s]+/g, "-"); if (c) throw If(t, u, c); It(t, u) } } catch (i) { if (i instanceof fr) throw i; It(t, "network-request-failed", { message: String(i) }) } } async function go(t, e, n, r, i = {}) { const s = await kn(t, e, n, r, i); return "mfaPendingCredential" in s && It(t, "multi-factor-auth-required", { _serverResponse: s }), s } function Ay(t, e, n, r) { const i = `${e}${n}?${r}`; return t.config.emulator ? Nf(t.config, i) : `${t.config.apiScheme}://${i}` } function kT(t) { switch (t) { case "ENFORCE": return "ENFORCE"; case "AUDIT": return "AUDIT"; case "OFF": return "OFF"; default: return "ENFORCEMENT_STATE_UNSPECIFIED" } } class NT { clearNetworkTimeout() { clearTimeout(this.timer) } constructor(e) { this.auth = e, this.timer = null, this.promise = new Promise((n, r) => { this.timer = setTimeout(() => r(Ut(this.auth, "network-request-failed")), IT.get()) }) } } function Go(t, e, n) { const r = { appName: t.name }; n.email && (r.email = n.email), n.phoneNumber && (r.phoneNumber = n.phoneNumber); const i = Ut(t, e, r); return i.customData._tokenResponse = n, i } function Gh(t) { return t !== void 0 && t.enterprise !== void 0 } class RT { constructor(e) { if (this.siteKey = "", this.recaptchaEnforcementState = [], e.recaptchaKey === void 0) throw new Error("recaptchaKey undefined"); this.siteKey = e.recaptchaKey.split("/")[3], this.recaptchaEnforcementState = e.recaptchaEnforcementState } getProviderEnforcementState(e) { if (!this.recaptchaEnforcementState || this.recaptchaEnforcementState.length === 0) return null; for (const n of this.recaptchaEnforcementState) if (n.provider && n.provider === e) return kT(n.enforcementState); return null } isProviderEnabled(e) { return this.getProviderEnforcementState(e) === "ENFORCE" || this.getProviderEnforcementState(e) === "AUDIT" } isAnyProviderEnabled() { return this.isProviderEnabled("EMAIL_PASSWORD_PROVIDER") || this.isProviderEnabled("PHONE_PROVIDER") } } async function OT(t, e) { return kn(t, "GET", "/v2/recaptchaConfig", pr(t, e)) }/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */async function jT(t, e) { return kn(t, "POST", "/v1/accounts:delete", e) } async function Ly(t, e) { return kn(t, "POST", "/v1/accounts:lookup", e) }/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */function Os(t) { if (t) try { const e = new Date(Number(t)); if (!isNaN(e.getTime())) return e.toUTCString() } catch { } } async function AT(t, e = !1) { const n = Qt(t), r = await n.getIdToken(e), i = Rf(r); Y(i && i.exp && i.auth_time && i.iat, n.auth, "internal-error"); const s = typeof i.firebase == "object" ? i.firebase : void 0, o = s == null ? void 0 : s.sign_in_provider; return { claims: i, token: r, authTime: Os(Oc(i.auth_time)), issuedAtTime: Os(Oc(i.iat)), expirationTime: Os(Oc(i.exp)), signInProvider: o || null, signInSecondFactor: (s == null ? void 0 : s.sign_in_second_factor) || null } } function Oc(t) { return Number(t) * 1e3 } function Rf(t) { const [e, n, r] = t.split("."); if (e === void 0 || n === void 0 || r === void 0) return da("JWT malformed, contained fewer than 3 sections"), null; try { const i = xy(n); return i ? JSON.parse(i) : (da("Failed to decode base64 JWT payload"), null) } catch (i) { return da("Caught error parsing JWT payload as JSON", i == null ? void 0 : i.toString()), null } } function Kh(t) { const e = Rf(t); return Y(e, "internal-error"), Y(typeof e.exp < "u", "internal-error"), Y(typeof e.iat < "u", "internal-error"), Number(e.exp) - Number(e.iat) }/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */async function $i(t, e, n = !1) { if (n) return e; try { return await e } catch (r) { throw r instanceof fr && LT(r) && t.auth.currentUser === t && await t.auth.signOut(), r } } function LT({ code: t }) { return t === "auth/user-disabled" || t === "auth/user-token-expired" }/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */class DT { constructor(e) { this.user = e, this.isRunning = !1, this.timerId = null, this.errorBackoff = 3e4 } _start() { this.isRunning || (this.isRunning = !0, this.schedule()) } _stop() { this.isRunning && (this.isRunning = !1, this.timerId !== null && clearTimeout(this.timerId)) } getInterval(e) { var n; if (e) { const r = this.errorBackoff; return this.errorBackoff = Math.min(this.errorBackoff * 2, 96e4), r } else { this.errorBackoff = 3e4; const i = ((n = this.user.stsTokenManager.expirationTime) !== null && n !== void 0 ? n : 0) - Date.now() - 3e5; return Math.max(0, i) } } schedule(e = !1) { if (!this.isRunning) return; const n = this.getInterval(e); this.timerId = setTimeout(async () => { await this.iteration() }, n) } async iteration() { try { await this.user.getIdToken(!0) } catch (e) { (e == null ? void 0 : e.code) === "auth/network-request-failed" && this.schedule(!0); return } this.schedule() } }/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */class Zu { constructor(e, n) { this.createdAt = e, this.lastLoginAt = n, this._initializeTime() } _initializeTime() { this.lastSignInTime = Os(this.lastLoginAt), this.creationTime = Os(this.createdAt) } _copy(e) { this.createdAt = e.createdAt, this.lastLoginAt = e.lastLoginAt, this._initializeTime() } toJSON() { return { createdAt: this.createdAt, lastLoginAt: this.lastLoginAt } } }/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */async function nl(t) { var e; const n = t.auth, r = await t.getIdToken(), i = await $i(t, Ly(n, { idToken: r })); Y(i == null ? void 0 : i.users.length, n, "internal-error"); const s = i.users[0]; t._notifyReloadListener(s); const o = !((e = s.providerUserInfo) === null || e === void 0) && e.length ? Dy(s.providerUserInfo) : [], l = FT(t.providerData, o), a = t.isAnonymous, c = !(t.email && s.passwordHash) && !(l != null && l.length), u = a ? c : !1, f = { uid: s.localId, displayName: s.displayName || null, photoURL: s.photoUrl || null, email: s.email || null, emailVerified: s.emailVerified || !1, phoneNumber: s.phoneNumber || null, tenantId: s.tenantId || null, providerData: l, metadata: new Zu(s.createdAt, s.lastLoginAt), isAnonymous: u }; Object.assign(t, f) } async function MT(t) { const e = Qt(t); await nl(e), await e.auth._persistUserIfCurrent(e), e.auth._notifyListenersIfCurrent(e) } function FT(t, e) { return [...t.filter(r => !e.some(i => i.providerId === r.providerId)), ...e] } function Dy(t) { return t.map(e => { var { providerId: n } = e, r = Pf(e, ["providerId"]); return { providerId: n, uid: r.rawId || "", displayName: r.displayName || null, email: r.email || null, phoneNumber: r.phoneNumber || null, photoURL: r.photoUrl || null } }) }/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */async function UT(t, e) { const n = await jy(t, {}, async () => { const r = po({ grant_type: "refresh_token", refresh_token: e }).slice(1), { tokenApiHost: i, apiKey: s } = t.config, o = Ay(t, i, "/v1/token", `key=${s}`), l = await t._getAdditionalHeaders(); return l["Content-Type"] = "application/x-www-form-urlencoded", Oy.fetch()(o, { method: "POST", headers: l, body: r }) }); return { accessToken: n.access_token, expiresIn: n.expires_in, refreshToken: n.refresh_token } } async function zT(t, e) { return kn(t, "POST", "/v2/accounts:revokeToken", pr(t, e)) }/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */class Ti { constructor() { this.refreshToken = null, this.accessToken = null, this.expirationTime = null } get isExpired() { return !this.expirationTime || Date.now() > this.expirationTime - 3e4 } updateFromServerResponse(e) { Y(e.idToken, "internal-error"), Y(typeof e.idToken < "u", "internal-error"), Y(typeof e.refreshToken < "u", "internal-error"); const n = "expiresIn" in e && typeof e.expiresIn < "u" ? Number(e.expiresIn) : Kh(e.idToken); this.updateTokensAndExpiration(e.idToken, e.refreshToken, n) } updateFromIdToken(e) { Y(e.length !== 0, "internal-error"); const n = Kh(e); this.updateTokensAndExpiration(e, null, n) } async getToken(e, n = !1) { return !n && this.accessToken && !this.isExpired ? this.accessToken : (Y(this.refreshToken, e, "user-token-expired"), this.refreshToken ? (await this.refresh(e, this.refreshToken), this.accessToken) : null) } clearRefreshToken() { this.refreshToken = null } async refresh(e, n) { const { accessToken: r, refreshToken: i, expiresIn: s } = await UT(e, n); this.updateTokensAndExpiration(r, i, Number(s)) } updateTokensAndExpiration(e, n, r) { this.refreshToken = n || null, this.accessToken = e || null, this.expirationTime = Date.now() + r * 1e3 } static fromJSON(e, n) { const { refreshToken: r, accessToken: i, expirationTime: s } = n, o = new Ti; return r && (Y(typeof r == "string", "internal-error", { appName: e }), o.refreshToken = r), i && (Y(typeof i == "string", "internal-error", { appName: e }), o.accessToken = i), s && (Y(typeof s == "number", "internal-error", { appName: e }), o.expirationTime = s), o } toJSON() { return { refreshToken: this.refreshToken, accessToken: this.accessToken, expirationTime: this.expirationTime } } _assign(e) { this.accessToken = e.accessToken, this.refreshToken = e.refreshToken, this.expirationTime = e.expirationTime } _clone() { return Object.assign(new Ti, this.toJSON()) } _performRefresh() { return dn("not implemented") } }/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */function jn(t, e) { Y(typeof t == "string" || typeof t > "u", "internal-error", { appName: e }) } class fn { constructor(e) { var { uid: n, auth: r, stsTokenManager: i } = e, s = Pf(e, ["uid", "auth", "stsTokenManager"]); this.providerId = "firebase", this.proactiveRefresh = new DT(this), this.reloadUserInfo = null, this.reloadListener = null, this.uid = n, this.auth = r, this.stsTokenManager = i, this.accessToken = i.accessToken, this.displayName = s.displayName || null, this.email = s.email || null, this.emailVerified = s.emailVerified || !1, this.phoneNumber = s.phoneNumber || null, this.photoURL = s.photoURL || null, this.isAnonymous = s.isAnonymous || !1, this.tenantId = s.tenantId || null, this.providerData = s.providerData ? [...s.providerData] : [], this.metadata = new Zu(s.createdAt || void 0, s.lastLoginAt || void 0) } async getIdToken(e) { const n = await $i(this, this.stsTokenManager.getToken(this.auth, e)); return Y(n, this.auth, "internal-error"), this.accessToken !== n && (this.accessToken = n, await this.auth._persistUserIfCurrent(this), this.auth._notifyListenersIfCurrent(this)), n } getIdTokenResult(e) { return AT(this, e) } reload() { return MT(this) } _assign(e) { this !== e && (Y(this.uid === e.uid, this.auth, "internal-error"), this.displayName = e.displayName, this.photoURL = e.photoURL, this.email = e.email, this.emailVerified = e.emailVerified, this.phoneNumber = e.phoneNumber, this.isAnonymous = e.isAnonymous, this.tenantId = e.tenantId, this.providerData = e.providerData.map(n => Object.assign({}, n)), this.metadata._copy(e.metadata), this.stsTokenManager._assign(e.stsTokenManager)) } _clone(e) { const n = new fn(Object.assign(Object.assign({}, this), { auth: e, stsTokenManager: this.stsTokenManager._clone() })); return n.metadata._copy(this.metadata), n } _onReload(e) { Y(!this.reloadListener, this.auth, "internal-error"), this.reloadListener = e, this.reloadUserInfo && (this._notifyReloadListener(this.reloadUserInfo), this.reloadUserInfo = null) } _notifyReloadListener(e) { this.reloadListener ? this.reloadListener(e) : this.reloadUserInfo = e } _startProactiveRefresh() { this.proactiveRefresh._start() } _stopProactiveRefresh() { this.proactiveRefresh._stop() } async _updateTokensIfNecessary(e, n = !1) { let r = !1; e.idToken && e.idToken !== this.stsTokenManager.accessToken && (this.stsTokenManager.updateFromServerResponse(e), r = !0), n && await nl(this), await this.auth._persistUserIfCurrent(this), r && this.auth._notifyListenersIfCurrent(this) } async delete() { if (Lt(this.auth.app)) return Promise.reject(gn(this.auth)); const e = await this.getIdToken(); return await $i(this, jT(this.auth, { idToken: e })), this.stsTokenManager.clearRefreshToken(), this.auth.signOut() } toJSON() { return Object.assign(Object.assign({ uid: this.uid, email: this.email || void 0, emailVerified: this.emailVerified, displayName: this.displayName || void 0, isAnonymous: this.isAnonymous, photoURL: this.photoURL || void 0, phoneNumber: this.phoneNumber || void 0, tenantId: this.tenantId || void 0, providerData: this.providerData.map(e => Object.assign({}, e)), stsTokenManager: this.stsTokenManager.toJSON(), _redirectEventId: this._redirectEventId }, this.metadata.toJSON()), { apiKey: this.auth.config.apiKey, appName: this.auth.name }) } get refreshToken() { return this.stsTokenManager.refreshToken || "" } static _fromJSON(e, n) { var r, i, s, o, l, a, c, u; const f = (r = n.displayName) !== null && r !== void 0 ? r : void 0, h = (i = n.email) !== null && i !== void 0 ? i : void 0, y = (s = n.phoneNumber) !== null && s !== void 0 ? s : void 0, g = (o = n.photoURL) !== null && o !== void 0 ? o : void 0, w = (l = n.tenantId) !== null && l !== void 0 ? l : void 0, E = (a = n._redirectEventId) !== null && a !== void 0 ? a : void 0, v = (c = n.createdAt) !== null && c !== void 0 ? c : void 0, p = (u = n.lastLoginAt) !== null && u !== void 0 ? u : void 0, { uid: m, emailVerified: S, isAnonymous: T, providerData: x, stsTokenManager: P } = n; Y(m && P, e, "internal-error"); const I = Ti.fromJSON(this.name, P); Y(typeof m == "string", e, "internal-error"), jn(f, e.name), jn(h, e.name), Y(typeof S == "boolean", e, "internal-error"), Y(typeof T == "boolean", e, "internal-error"), jn(y, e.name), jn(g, e.name), jn(w, e.name), jn(E, e.name), jn(v, e.name), jn(p, e.name); const N = new fn({ uid: m, auth: e, email: h, emailVerified: S, displayName: f, isAnonymous: T, photoURL: g, phoneNumber: y, tenantId: w, stsTokenManager: I, createdAt: v, lastLoginAt: p }); return x && Array.isArray(x) && (N.providerData = x.map(k => Object.assign({}, k))), E && (N._redirectEventId = E), N } static async _fromIdTokenResponse(e, n, r = !1) { const i = new Ti; i.updateFromServerResponse(n); const s = new fn({ uid: n.localId, auth: e, stsTokenManager: i, isAnonymous: r }); return await nl(s), s } static async _fromGetAccountInfoResponse(e, n, r) { const i = n.users[0]; Y(i.localId !== void 0, "internal-error"); const s = i.providerUserInfo !== void 0 ? Dy(i.providerUserInfo) : [], o = !(i.email && i.passwordHash) && !(s != null && s.length), l = new Ti; l.updateFromIdToken(r); const a = new fn({ uid: i.localId, auth: e, stsTokenManager: l, isAnonymous: o }), c = { uid: i.localId, displayName: i.displayName || null, photoURL: i.photoUrl || null, email: i.email || null, emailVerified: i.emailVerified || !1, phoneNumber: i.phoneNumber || null, tenantId: i.tenantId || null, providerData: s, metadata: new Zu(i.createdAt, i.lastLoginAt), isAnonymous: !(i.email && i.passwordHash) && !(s != null && s.length) }; return Object.assign(a, c), a } }/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */const qh = new Map; function pn(t) { Tn(t instanceof Function, "Expected a class definition"); let e = qh.get(t); return e ? (Tn(e instanceof t, "Instance stored in cache mismatched with class"), e) : (e = new t, qh.set(t, e), e) }/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */class My { constructor() { this.type = "NONE", this.storage = {} } async _isAvailable() { return !0 } async _set(e, n) { this.storage[e] = n } async _get(e) { const n = this.storage[e]; return n === void 0 ? null : n } async _remove(e) { delete this.storage[e] } _addListener(e, n) { } _removeListener(e, n) { } } My.type = "NONE"; const Yh = My;/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */function fa(t, e, n) { return `firebase:${t}:${e}:${n}` } class Ci { constructor(e, n, r) { this.persistence = e, this.auth = n, this.userKey = r; const { config: i, name: s } = this.auth; this.fullUserKey = fa(this.userKey, i.apiKey, s), this.fullPersistenceKey = fa("persistence", i.apiKey, s), this.boundEventHandler = n._onStorageEvent.bind(n), this.persistence._addListener(this.fullUserKey, this.boundEventHandler) } setCurrentUser(e) { return this.persistence._set(this.fullUserKey, e.toJSON()) } async getCurrentUser() { const e = await this.persistence._get(this.fullUserKey); return e ? fn._fromJSON(this.auth, e) : null } removeCurrentUser() { return this.persistence._remove(this.fullUserKey) } savePersistenceForRedirect() { return this.persistence._set(this.fullPersistenceKey, this.persistence.type) } async setPersistence(e) { if (this.persistence === e) return; const n = await this.getCurrentUser(); if (await this.removeCurrentUser(), this.persistence = e, n) return this.setCurrentUser(n) } delete() { this.persistence._removeListener(this.fullUserKey, this.boundEventHandler) } static async create(e, n, r = "authUser") { if (!n.length) return new Ci(pn(Yh), e, r); const i = (await Promise.all(n.map(async c => { if (await c._isAvailable()) return c }))).filter(c => c); let s = i[0] || pn(Yh); const o = fa(r, e.config.apiKey, e.name); let l = null; for (const c of n) try { const u = await c._get(o); if (u) { const f = fn._fromJSON(e, u); c !== s && (l = f), s = c; break } } catch { } const a = i.filter(c => c._shouldAllowMigration); return !s._shouldAllowMigration || !a.length ? new Ci(s, e, r) : (s = a[0], l && await s._set(o, l.toJSON()), await Promise.all(n.map(async c => { if (c !== s) try { await c._remove(o) } catch { } })), new Ci(s, e, r)) } }/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */function Jh(t) { const e = t.toLowerCase(); if (e.includes("opera/") || e.includes("opr/") || e.includes("opios/")) return "Opera"; if ($y(e)) return "IEMobile"; if (e.includes("msie") || e.includes("trident/")) return "IE"; if (e.includes("edge/")) return "Edge"; if (Fy(e)) return "Firefox"; if (e.includes("silk/")) return "Silk"; if (Hy(e)) return "Blackberry"; if (Vy(e)) return "Webos"; if (Uy(e)) return "Safari"; if ((e.includes("chrome/") || zy(e)) && !e.includes("edge/")) return "Chrome"; if (By(e)) return "Android"; { const n = /([a-zA-Z\d\.]+)\/[a-zA-Z\d\.]*$/, r = t.match(n); if ((r == null ? void 0 : r.length) === 2) return r[1] } return "Other" } function Fy(t = Ze()) { return /firefox\//i.test(t) } function Uy(t = Ze()) { const e = t.toLowerCase(); return e.includes("safari/") && !e.includes("chrome/") && !e.includes("crios/") && !e.includes("android") } function zy(t = Ze()) { return /crios\//i.test(t) } function $y(t = Ze()) { return /iemobile/i.test(t) } function By(t = Ze()) { return /android/i.test(t) } function Hy(t = Ze()) { return /blackberry/i.test(t) } function Vy(t = Ze()) { return /webos/i.test(t) } function Of(t = Ze()) { return /iphone|ipad|ipod/i.test(t) || /macintosh/i.test(t) && /mobile/i.test(t) } function $T(t = Ze()) { var e; return Of(t) && !!(!((e = window.navigator) === null || e === void 0) && e.standalone) } function BT() { return rb() && document.documentMode === 10 } function Wy(t = Ze()) { return Of(t) || By(t) || Vy(t) || Hy(t) || /windows phone/i.test(t) || $y(t) }/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */function Gy(t, e = []) { let n; switch (t) { case "Browser": n = Jh(Ze()); break; case "Worker": n = `${Jh(Ze())}-${t}`; break; default: n = t }const r = e.length ? e.join(",") : "FirebaseCore-web"; return `${n}/JsCore/${ho}/${r}` }/**
 * @license
 * Copyright 2022 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */class HT { constructor(e) { this.auth = e, this.queue = [] } pushCallback(e, n) { const r = s => new Promise((o, l) => { try { const a = e(s); o(a) } catch (a) { l(a) } }); r.onAbort = n, this.queue.push(r); const i = this.queue.length - 1; return () => { this.queue[i] = () => Promise.resolve() } } async runMiddleware(e) { if (this.auth.currentUser === e) return; const n = []; try { for (const r of this.queue) await r(e), r.onAbort && n.push(r.onAbort) } catch (r) { n.reverse(); for (const i of n) try { i() } catch { } throw this.auth._errorFactory.create("login-blocked", { originalMessage: r == null ? void 0 : r.message }) } } }/**
 * @license
 * Copyright 2023 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */async function VT(t, e = {}) { return kn(t, "GET", "/v2/passwordPolicy", pr(t, e)) }/**
 * @license
 * Copyright 2023 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */const WT = 6; class GT { constructor(e) { var n, r, i, s; const o = e.customStrengthOptions; this.customStrengthOptions = {}, this.customStrengthOptions.minPasswordLength = (n = o.minPasswordLength) !== null && n !== void 0 ? n : WT, o.maxPasswordLength && (this.customStrengthOptions.maxPasswordLength = o.maxPasswordLength), o.containsLowercaseCharacter !== void 0 && (this.customStrengthOptions.containsLowercaseLetter = o.containsLowercaseCharacter), o.containsUppercaseCharacter !== void 0 && (this.customStrengthOptions.containsUppercaseLetter = o.containsUppercaseCharacter), o.containsNumericCharacter !== void 0 && (this.customStrengthOptions.containsNumericCharacter = o.containsNumericCharacter), o.containsNonAlphanumericCharacter !== void 0 && (this.customStrengthOptions.containsNonAlphanumericCharacter = o.containsNonAlphanumericCharacter), this.enforcementState = e.enforcementState, this.enforcementState === "ENFORCEMENT_STATE_UNSPECIFIED" && (this.enforcementState = "OFF"), this.allowedNonAlphanumericCharacters = (i = (r = e.allowedNonAlphanumericCharacters) === null || r === void 0 ? void 0 : r.join("")) !== null && i !== void 0 ? i : "", this.forceUpgradeOnSignin = (s = e.forceUpgradeOnSignin) !== null && s !== void 0 ? s : !1, this.schemaVersion = e.schemaVersion } validatePassword(e) { var n, r, i, s, o, l; const a = { isValid: !0, passwordPolicy: this }; return this.validatePasswordLengthOptions(e, a), this.validatePasswordCharacterOptions(e, a), a.isValid && (a.isValid = (n = a.meetsMinPasswordLength) !== null && n !== void 0 ? n : !0), a.isValid && (a.isValid = (r = a.meetsMaxPasswordLength) !== null && r !== void 0 ? r : !0), a.isValid && (a.isValid = (i = a.containsLowercaseLetter) !== null && i !== void 0 ? i : !0), a.isValid && (a.isValid = (s = a.containsUppercaseLetter) !== null && s !== void 0 ? s : !0), a.isValid && (a.isValid = (o = a.containsNumericCharacter) !== null && o !== void 0 ? o : !0), a.isValid && (a.isValid = (l = a.containsNonAlphanumericCharacter) !== null && l !== void 0 ? l : !0), a } validatePasswordLengthOptions(e, n) { const r = this.customStrengthOptions.minPasswordLength, i = this.customStrengthOptions.maxPasswordLength; r && (n.meetsMinPasswordLength = e.length >= r), i && (n.meetsMaxPasswordLength = e.length <= i) } validatePasswordCharacterOptions(e, n) { this.updatePasswordCharacterOptionsStatuses(n, !1, !1, !1, !1); let r; for (let i = 0; i < e.length; i++)r = e.charAt(i), this.updatePasswordCharacterOptionsStatuses(n, r >= "a" && r <= "z", r >= "A" && r <= "Z", r >= "0" && r <= "9", this.allowedNonAlphanumericCharacters.includes(r)) } updatePasswordCharacterOptionsStatuses(e, n, r, i, s) { this.customStrengthOptions.containsLowercaseLetter && (e.containsLowercaseLetter || (e.containsLowercaseLetter = n)), this.customStrengthOptions.containsUppercaseLetter && (e.containsUppercaseLetter || (e.containsUppercaseLetter = r)), this.customStrengthOptions.containsNumericCharacter && (e.containsNumericCharacter || (e.containsNumericCharacter = i)), this.customStrengthOptions.containsNonAlphanumericCharacter && (e.containsNonAlphanumericCharacter || (e.containsNonAlphanumericCharacter = s)) } }/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */class KT { constructor(e, n, r, i) { this.app = e, this.heartbeatServiceProvider = n, this.appCheckServiceProvider = r, this.config = i, this.currentUser = null, this.emulatorConfig = null, this.operations = Promise.resolve(), this.authStateSubscription = new Xh(this), this.idTokenSubscription = new Xh(this), this.beforeStateQueue = new HT(this), this.redirectUser = null, this.isProactiveRefreshEnabled = !1, this.EXPECTED_PASSWORD_POLICY_SCHEMA_VERSION = 1, this._canInitEmulator = !0, this._isInitialized = !1, this._deleted = !1, this._initializationPromise = null, this._popupRedirectResolver = null, this._errorFactory = Ry, this._agentRecaptchaConfig = null, this._tenantRecaptchaConfigs = {}, this._projectPasswordPolicy = null, this._tenantPasswordPolicies = {}, this.lastNotifiedUid = void 0, this.languageCode = null, this.tenantId = null, this.settings = { appVerificationDisabledForTesting: !1 }, this.frameworks = [], this.name = e.name, this.clientVersion = i.sdkClientVersion } _initializeWithPersistence(e, n) { return n && (this._popupRedirectResolver = pn(n)), this._initializationPromise = this.queue(async () => { var r, i; if (!this._deleted && (this.persistenceManager = await Ci.create(this, e), !this._deleted)) { if (!((r = this._popupRedirectResolver) === null || r === void 0) && r._shouldInitProactively) try { await this._popupRedirectResolver._initialize(this) } catch { } await this.initializeCurrentUser(n), this.lastNotifiedUid = ((i = this.currentUser) === null || i === void 0 ? void 0 : i.uid) || null, !this._deleted && (this._isInitialized = !0) } }), this._initializationPromise } async _onStorageEvent() { if (this._deleted) return; const e = await this.assertedPersistence.getCurrentUser(); if (!(!this.currentUser && !e)) { if (this.currentUser && e && this.currentUser.uid === e.uid) { this._currentUser._assign(e), await this.currentUser.getIdToken(); return } await this._updateCurrentUser(e, !0) } } async initializeCurrentUserFromIdToken(e) { try { const n = await Ly(this, { idToken: e }), r = await fn._fromGetAccountInfoResponse(this, n, e); await this.directlySetCurrentUser(r) } catch (n) { console.warn("FirebaseServerApp could not login user with provided authIdToken: ", n), await this.directlySetCurrentUser(null) } } async initializeCurrentUser(e) { var n; if (Lt(this.app)) { const o = this.app.settings.authIdToken; return o ? new Promise(l => { setTimeout(() => this.initializeCurrentUserFromIdToken(o).then(l, l)) }) : this.directlySetCurrentUser(null) } const r = await this.assertedPersistence.getCurrentUser(); let i = r, s = !1; if (e && this.config.authDomain) { await this.getOrInitRedirectPersistenceManager(); const o = (n = this.redirectUser) === null || n === void 0 ? void 0 : n._redirectEventId, l = i == null ? void 0 : i._redirectEventId, a = await this.tryRedirectSignIn(e); (!o || o === l) && (a != null && a.user) && (i = a.user, s = !0) } if (!i) return this.directlySetCurrentUser(null); if (!i._redirectEventId) { if (s) try { await this.beforeStateQueue.runMiddleware(i) } catch (o) { i = r, this._popupRedirectResolver._overrideRedirectResult(this, () => Promise.reject(o)) } return i ? this.reloadAndSetCurrentUserOrClear(i) : this.directlySetCurrentUser(null) } return Y(this._popupRedirectResolver, this, "argument-error"), await this.getOrInitRedirectPersistenceManager(), this.redirectUser && this.redirectUser._redirectEventId === i._redirectEventId ? this.directlySetCurrentUser(i) : this.reloadAndSetCurrentUserOrClear(i) } async tryRedirectSignIn(e) { let n = null; try { n = await this._popupRedirectResolver._completeRedirectFn(this, e, !0) } catch { await this._setRedirectUser(null) } return n } async reloadAndSetCurrentUserOrClear(e) { try { await nl(e) } catch (n) { if ((n == null ? void 0 : n.code) !== "auth/network-request-failed") return this.directlySetCurrentUser(null) } return this.directlySetCurrentUser(e) } useDeviceLanguage() { this.languageCode = _T() } async _delete() { this._deleted = !0 } async updateCurrentUser(e) { if (Lt(this.app)) return Promise.reject(gn(this)); const n = e ? Qt(e) : null; return n && Y(n.auth.config.apiKey === this.config.apiKey, this, "invalid-user-token"), this._updateCurrentUser(n && n._clone(this)) } async _updateCurrentUser(e, n = !1) { if (!this._deleted) return e && Y(this.tenantId === e.tenantId, this, "tenant-id-mismatch"), n || await this.beforeStateQueue.runMiddleware(e), this.queue(async () => { await this.directlySetCurrentUser(e), this.notifyAuthListeners() }) } async signOut() { return Lt(this.app) ? Promise.reject(gn(this)) : (await this.beforeStateQueue.runMiddleware(null), (this.redirectPersistenceManager || this._popupRedirectResolver) && await this._setRedirectUser(null), this._updateCurrentUser(null, !0)) } setPersistence(e) { return Lt(this.app) ? Promise.reject(gn(this)) : this.queue(async () => { await this.assertedPersistence.setPersistence(pn(e)) }) } _getRecaptchaConfig() { return this.tenantId == null ? this._agentRecaptchaConfig : this._tenantRecaptchaConfigs[this.tenantId] } async validatePassword(e) { this._getPasswordPolicyInternal() || await this._updatePasswordPolicy(); const n = this._getPasswordPolicyInternal(); return n.schemaVersion !== this.EXPECTED_PASSWORD_POLICY_SCHEMA_VERSION ? Promise.reject(this._errorFactory.create("unsupported-password-policy-schema-version", {})) : n.validatePassword(e) } _getPasswordPolicyInternal() { return this.tenantId === null ? this._projectPasswordPolicy : this._tenantPasswordPolicies[this.tenantId] } async _updatePasswordPolicy() { const e = await VT(this), n = new GT(e); this.tenantId === null ? this._projectPasswordPolicy = n : this._tenantPasswordPolicies[this.tenantId] = n } _getPersistence() { return this.assertedPersistence.persistence.type } _updateErrorMap(e) { this._errorFactory = new fo("auth", "Firebase", e()) } onAuthStateChanged(e, n, r) { return this.registerStateListener(this.authStateSubscription, e, n, r) } beforeAuthStateChanged(e, n) { return this.beforeStateQueue.pushCallback(e, n) } onIdTokenChanged(e, n, r) { return this.registerStateListener(this.idTokenSubscription, e, n, r) } authStateReady() { return new Promise((e, n) => { if (this.currentUser) e(); else { const r = this.onAuthStateChanged(() => { r(), e() }, n) } }) } async revokeAccessToken(e) { if (this.currentUser) { const n = await this.currentUser.getIdToken(), r = { providerId: "apple.com", tokenType: "ACCESS_TOKEN", token: e, idToken: n }; this.tenantId != null && (r.tenantId = this.tenantId), await zT(this, r) } } toJSON() { var e; return { apiKey: this.config.apiKey, authDomain: this.config.authDomain, appName: this.name, currentUser: (e = this._currentUser) === null || e === void 0 ? void 0 : e.toJSON() } } async _setRedirectUser(e, n) { const r = await this.getOrInitRedirectPersistenceManager(n); return e === null ? r.removeCurrentUser() : r.setCurrentUser(e) } async getOrInitRedirectPersistenceManager(e) { if (!this.redirectPersistenceManager) { const n = e && pn(e) || this._popupRedirectResolver; Y(n, this, "argument-error"), this.redirectPersistenceManager = await Ci.create(this, [pn(n._redirectPersistence)], "redirectUser"), this.redirectUser = await this.redirectPersistenceManager.getCurrentUser() } return this.redirectPersistenceManager } async _redirectUserForId(e) { var n, r; return this._isInitialized && await this.queue(async () => { }), ((n = this._currentUser) === null || n === void 0 ? void 0 : n._redirectEventId) === e ? this._currentUser : ((r = this.redirectUser) === null || r === void 0 ? void 0 : r._redirectEventId) === e ? this.redirectUser : null } async _persistUserIfCurrent(e) { if (e === this.currentUser) return this.queue(async () => this.directlySetCurrentUser(e)) } _notifyListenersIfCurrent(e) { e === this.currentUser && this.notifyAuthListeners() } _key() { return `${this.config.authDomain}:${this.config.apiKey}:${this.name}` } _startProactiveRefresh() { this.isProactiveRefreshEnabled = !0, this.currentUser && this._currentUser._startProactiveRefresh() } _stopProactiveRefresh() { this.isProactiveRefreshEnabled = !1, this.currentUser && this._currentUser._stopProactiveRefresh() } get _currentUser() { return this.currentUser } notifyAuthListeners() { var e, n; if (!this._isInitialized) return; this.idTokenSubscription.next(this.currentUser); const r = (n = (e = this.currentUser) === null || e === void 0 ? void 0 : e.uid) !== null && n !== void 0 ? n : null; this.lastNotifiedUid !== r && (this.lastNotifiedUid = r, this.authStateSubscription.next(this.currentUser)) } registerStateListener(e, n, r, i) { if (this._deleted) return () => { }; const s = typeof n == "function" ? n : n.next.bind(n); let o = !1; const l = this._isInitialized ? Promise.resolve() : this._initializationPromise; if (Y(l, this, "internal-error"), l.then(() => { o || s(this.currentUser) }), typeof n == "function") { const a = e.addObserver(n, r, i); return () => { o = !0, a() } } else { const a = e.addObserver(n); return () => { o = !0, a() } } } async directlySetCurrentUser(e) { this.currentUser && this.currentUser !== e && this._currentUser._stopProactiveRefresh(), e && this.isProactiveRefreshEnabled && e._startProactiveRefresh(), this.currentUser = e, e ? await this.assertedPersistence.setCurrentUser(e) : await this.assertedPersistence.removeCurrentUser() } queue(e) { return this.operations = this.operations.then(e, e), this.operations } get assertedPersistence() { return Y(this.persistenceManager, this, "internal-error"), this.persistenceManager } _logFramework(e) { !e || this.frameworks.includes(e) || (this.frameworks.push(e), this.frameworks.sort(), this.clientVersion = Gy(this.config.clientPlatform, this._getFrameworks())) } _getFrameworks() { return this.frameworks } async _getAdditionalHeaders() { var e; const n = { "X-Client-Version": this.clientVersion }; this.app.options.appId && (n["X-Firebase-gmpid"] = this.app.options.appId); const r = await ((e = this.heartbeatServiceProvider.getImmediate({ optional: !0 })) === null || e === void 0 ? void 0 : e.getHeartbeatsHeader()); r && (n["X-Firebase-Client"] = r); const i = await this._getAppCheckToken(); return i && (n["X-Firebase-AppCheck"] = i), n } async _getAppCheckToken() { var e; const n = await ((e = this.appCheckServiceProvider.getImmediate({ optional: !0 })) === null || e === void 0 ? void 0 : e.getToken()); return n != null && n.error && ET(`Error while retrieving App Check token: ${n.error}`), n == null ? void 0 : n.token } } function hr(t) { return Qt(t) } class Xh { constructor(e) { this.auth = e, this.observer = null, this.addObserver = ub(n => this.observer = n) } get next() { return Y(this.observer, this.auth, "internal-error"), this.observer.next.bind(this.observer) } }/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */let Ml = { async loadJS() { throw new Error("Unable to load external scripts") }, recaptchaV2Script: "", recaptchaEnterpriseScript: "", gapiScript: "" }; function qT(t) { Ml = t } function Ky(t) { return Ml.loadJS(t) } function YT() { return Ml.recaptchaEnterpriseScript } function JT() { return Ml.gapiScript } function XT(t) { return `__${t}${Math.floor(Math.random() * 1e6)}` } class QT { constructor() { this.enterprise = new ZT } ready(e) { e() } execute(e, n) { return Promise.resolve("token") } render(e, n) { return "" } } class ZT { ready(e) { e() } execute(e, n) { return Promise.resolve("token") } render(e, n) { return "" } } const eC = "recaptcha-enterprise", qy = "NO_RECAPTCHA"; class tC { constructor(e) { this.type = eC, this.auth = hr(e) } async verify(e = "verify", n = !1) { async function r(s) { if (!n) { if (s.tenantId == null && s._agentRecaptchaConfig != null) return s._agentRecaptchaConfig.siteKey; if (s.tenantId != null && s._tenantRecaptchaConfigs[s.tenantId] !== void 0) return s._tenantRecaptchaConfigs[s.tenantId].siteKey } return new Promise(async (o, l) => { OT(s, { clientType: "CLIENT_TYPE_WEB", version: "RECAPTCHA_ENTERPRISE" }).then(a => { if (a.recaptchaKey === void 0) l(new Error("recaptcha Enterprise site key undefined")); else { const c = new RT(a); return s.tenantId == null ? s._agentRecaptchaConfig = c : s._tenantRecaptchaConfigs[s.tenantId] = c, o(c.siteKey) } }).catch(a => { l(a) }) }) } function i(s, o, l) { const a = window.grecaptcha; Gh(a) ? a.enterprise.ready(() => { a.enterprise.execute(s, { action: e }).then(c => { o(c) }).catch(() => { o(qy) }) }) : l(Error("No reCAPTCHA enterprise script loaded.")) } return this.auth.settings.appVerificationDisabledForTesting ? new QT().execute("siteKey", { action: "verify" }) : new Promise((s, o) => { r(this.auth).then(l => { if (!n && Gh(window.grecaptcha)) i(l, s, o); else { if (typeof window > "u") { o(new Error("RecaptchaVerifier is only supported in browser")); return } let a = YT(); a.length !== 0 && (a += l), Ky(a).then(() => { i(l, s, o) }).catch(c => { o(c) }) } }).catch(l => { o(l) }) }) } } async function Qh(t, e, n, r = !1, i = !1) { const s = new tC(t); let o; if (i) o = qy; else try { o = await s.verify(n) } catch { o = await s.verify(n, !0) } const l = Object.assign({}, e); if (n === "mfaSmsEnrollment" || n === "mfaSmsSignIn") { if ("phoneEnrollmentInfo" in l) { const a = l.phoneEnrollmentInfo.phoneNumber, c = l.phoneEnrollmentInfo.recaptchaToken; Object.assign(l, { phoneEnrollmentInfo: { phoneNumber: a, recaptchaToken: c, captchaResponse: o, clientType: "CLIENT_TYPE_WEB", recaptchaVersion: "RECAPTCHA_ENTERPRISE" } }) } else if ("phoneSignInInfo" in l) { const a = l.phoneSignInInfo.recaptchaToken; Object.assign(l, { phoneSignInInfo: { recaptchaToken: a, captchaResponse: o, clientType: "CLIENT_TYPE_WEB", recaptchaVersion: "RECAPTCHA_ENTERPRISE" } }) } return l } return r ? Object.assign(l, { captchaResp: o }) : Object.assign(l, { captchaResponse: o }), Object.assign(l, { clientType: "CLIENT_TYPE_WEB" }), Object.assign(l, { recaptchaVersion: "RECAPTCHA_ENTERPRISE" }), l } async function ed(t, e, n, r, i) { var s; if (!((s = t._getRecaptchaConfig()) === null || s === void 0) && s.isProviderEnabled("EMAIL_PASSWORD_PROVIDER")) { const o = await Qh(t, e, n, n === "getOobCode"); return r(t, o) } else return r(t, e).catch(async o => { if (o.code === "auth/missing-recaptcha-token") { console.log(`${n} is protected by reCAPTCHA Enterprise for this project. Automatically triggering the reCAPTCHA flow and restarting the flow.`); const l = await Qh(t, e, n, n === "getOobCode"); return r(t, l) } else return Promise.reject(o) }) }/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */function nC(t, e) { const n = _y(t, "auth"); if (n.isInitialized()) { const i = n.getImmediate(), s = n.getOptions(); if (Za(s, e ?? {})) return i; It(i, "already-initialized") } return n.initialize({ options: e }) } function rC(t, e) { const n = (e == null ? void 0 : e.persistence) || [], r = (Array.isArray(n) ? n : [n]).map(pn); e != null && e.errorMap && t._updateErrorMap(e.errorMap), t._initializeWithPersistence(r, e == null ? void 0 : e.popupRedirectResolver) } function iC(t, e, n) { const r = hr(t); Y(r._canInitEmulator, r, "emulator-config-failed"), Y(/^https?:\/\//.test(e), r, "invalid-emulator-scheme"); const i = !1, s = Yy(e), { host: o, port: l } = sC(e), a = l === null ? "" : `:${l}`; r.config.emulator = { url: `${s}//${o}${a}/` }, r.settings.appVerificationDisabledForTesting = !0, r.emulatorConfig = Object.freeze({ host: o, port: l, protocol: s.replace(":", ""), options: Object.freeze({ disableWarnings: i }) }), oC() } function Yy(t) { const e = t.indexOf(":"); return e < 0 ? "" : t.substr(0, e + 1) } function sC(t) { const e = Yy(t), n = /(\/\/)?([^?#/]+)/.exec(t.substr(e.length)); if (!n) return { host: "", port: null }; const r = n[2].split("@").pop() || "", i = /^(\[[^\]]+\])(:|$)/.exec(r); if (i) { const s = i[1]; return { host: s, port: Zh(r.substr(s.length + 1)) } } else { const [s, o] = r.split(":"); return { host: s, port: Zh(o) } } } function Zh(t) { if (!t) return null; const e = Number(t); return isNaN(e) ? null : e } function oC() { function t() { const e = document.createElement("p"), n = e.style; e.innerText = "Running in emulator mode. Do not use with production credentials.", n.position = "fixed", n.width = "100%", n.backgroundColor = "#ffffff", n.border = ".1em solid #000000", n.color = "#b50000", n.bottom = "0px", n.left = "0px", n.margin = "0px", n.zIndex = "10000", n.textAlign = "center", e.classList.add("firebase-emulator-warning"), document.body.appendChild(e) } typeof console < "u" && typeof console.info == "function" && console.info("WARNING: You are using the Auth Emulator, which is intended for local testing only.  Do not use with production credentials."), typeof window < "u" && typeof document < "u" && (document.readyState === "loading" ? window.addEventListener("DOMContentLoaded", t) : t()) }/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */class jf { constructor(e, n) { this.providerId = e, this.signInMethod = n } toJSON() { return dn("not implemented") } _getIdTokenResponse(e) { return dn("not implemented") } _linkToIdToken(e, n) { return dn("not implemented") } _getReauthenticationResolver(e) { return dn("not implemented") } } async function aC(t, e) { return kn(t, "POST", "/v1/accounts:signUp", e) }/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */async function lC(t, e) { return go(t, "POST", "/v1/accounts:signInWithPassword", pr(t, e)) }/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */async function cC(t, e) { return go(t, "POST", "/v1/accounts:signInWithEmailLink", pr(t, e)) } async function uC(t, e) { return go(t, "POST", "/v1/accounts:signInWithEmailLink", pr(t, e)) }/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */class no extends jf { constructor(e, n, r, i = null) { super("password", r), this._email = e, this._password = n, this._tenantId = i } static _fromEmailAndPassword(e, n) { return new no(e, n, "password") } static _fromEmailAndCode(e, n, r = null) { return new no(e, n, "emailLink", r) } toJSON() { return { email: this._email, password: this._password, signInMethod: this.signInMethod, tenantId: this._tenantId } } static fromJSON(e) { const n = typeof e == "string" ? JSON.parse(e) : e; if (n != null && n.email && (n != null && n.password)) { if (n.signInMethod === "password") return this._fromEmailAndPassword(n.email, n.password); if (n.signInMethod === "emailLink") return this._fromEmailAndCode(n.email, n.password, n.tenantId) } return null } async _getIdTokenResponse(e) { switch (this.signInMethod) { case "password": const n = { returnSecureToken: !0, email: this._email, password: this._password, clientType: "CLIENT_TYPE_WEB" }; return ed(e, n, "signInWithPassword", lC); case "emailLink": return cC(e, { email: this._email, oobCode: this._password }); default: It(e, "internal-error") } } async _linkToIdToken(e, n) { switch (this.signInMethod) { case "password": const r = { idToken: n, returnSecureToken: !0, email: this._email, password: this._password, clientType: "CLIENT_TYPE_WEB" }; return ed(e, r, "signUpPassword", aC); case "emailLink": return uC(e, { idToken: n, email: this._email, oobCode: this._password }); default: It(e, "internal-error") } } _getReauthenticationResolver(e) { return this._getIdTokenResponse(e) } }/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */async function _i(t, e) { return go(t, "POST", "/v1/accounts:signInWithIdp", pr(t, e)) }/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */const dC = "http://localhost"; class zr extends jf { constructor() { super(...arguments), this.pendingToken = null } static _fromParams(e) { const n = new zr(e.providerId, e.signInMethod); return e.idToken || e.accessToken ? (e.idToken && (n.idToken = e.idToken), e.accessToken && (n.accessToken = e.accessToken), e.nonce && !e.pendingToken && (n.nonce = e.nonce), e.pendingToken && (n.pendingToken = e.pendingToken)) : e.oauthToken && e.oauthTokenSecret ? (n.accessToken = e.oauthToken, n.secret = e.oauthTokenSecret) : It("argument-error"), n } toJSON() { return { idToken: this.idToken, accessToken: this.accessToken, secret: this.secret, nonce: this.nonce, pendingToken: this.pendingToken, providerId: this.providerId, signInMethod: this.signInMethod } } static fromJSON(e) { const n = typeof e == "string" ? JSON.parse(e) : e, { providerId: r, signInMethod: i } = n, s = Pf(n, ["providerId", "signInMethod"]); if (!r || !i) return null; const o = new zr(r, i); return o.idToken = s.idToken || void 0, o.accessToken = s.accessToken || void 0, o.secret = s.secret, o.nonce = s.nonce, o.pendingToken = s.pendingToken || null, o } _getIdTokenResponse(e) { const n = this.buildRequest(); return _i(e, n) } _linkToIdToken(e, n) { const r = this.buildRequest(); return r.idToken = n, _i(e, r) } _getReauthenticationResolver(e) { const n = this.buildRequest(); return n.autoCreate = !1, _i(e, n) } buildRequest() { const e = { requestUri: dC, returnSecureToken: !0 }; if (this.pendingToken) e.pendingToken = this.pendingToken; else { const n = {}; this.idToken && (n.id_token = this.idToken), this.accessToken && (n.access_token = this.accessToken), this.secret && (n.oauth_token_secret = this.secret), n.providerId = this.providerId, this.nonce && !this.pendingToken && (n.nonce = this.nonce), e.postBody = po(n) } return e } }/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */function fC(t) { switch (t) { case "recoverEmail": return "RECOVER_EMAIL"; case "resetPassword": return "PASSWORD_RESET"; case "signIn": return "EMAIL_SIGNIN"; case "verifyEmail": return "VERIFY_EMAIL"; case "verifyAndChangeEmail": return "VERIFY_AND_CHANGE_EMAIL"; case "revertSecondFactorAddition": return "REVERT_SECOND_FACTOR_ADDITION"; default: return null } } function pC(t) { const e = xs(Ss(t)).link, n = e ? xs(Ss(e)).deep_link_id : null, r = xs(Ss(t)).deep_link_id; return (r ? xs(Ss(r)).link : null) || r || n || e || t } class Af { constructor(e) { var n, r, i, s, o, l; const a = xs(Ss(e)), c = (n = a.apiKey) !== null && n !== void 0 ? n : null, u = (r = a.oobCode) !== null && r !== void 0 ? r : null, f = fC((i = a.mode) !== null && i !== void 0 ? i : null); Y(c && u && f, "argument-error"), this.apiKey = c, this.operation = f, this.code = u, this.continueUrl = (s = a.continueUrl) !== null && s !== void 0 ? s : null, this.languageCode = (o = a.languageCode) !== null && o !== void 0 ? o : null, this.tenantId = (l = a.tenantId) !== null && l !== void 0 ? l : null } static parseLink(e) { const n = pC(e); try { return new Af(n) } catch { return null } } }/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */class Gi { constructor() { this.providerId = Gi.PROVIDER_ID } static credential(e, n) { return no._fromEmailAndPassword(e, n) } static credentialWithLink(e, n) { const r = Af.parseLink(n); return Y(r, "argument-error"), no._fromEmailAndCode(e, r.code, r.tenantId) } } Gi.PROVIDER_ID = "password"; Gi.EMAIL_PASSWORD_SIGN_IN_METHOD = "password"; Gi.EMAIL_LINK_SIGN_IN_METHOD = "emailLink";/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */class Lf { constructor(e) { this.providerId = e, this.defaultLanguageCode = null, this.customParameters = {} } setDefaultLanguage(e) { this.defaultLanguageCode = e } setCustomParameters(e) { return this.customParameters = e, this } getCustomParameters() { return this.customParameters } }/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */class vo extends Lf { constructor() { super(...arguments), this.scopes = [] } addScope(e) { return this.scopes.includes(e) || this.scopes.push(e), this } getScopes() { return [...this.scopes] } }/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */class $n extends vo { constructor() { super("facebook.com") } static credential(e) { return zr._fromParams({ providerId: $n.PROVIDER_ID, signInMethod: $n.FACEBOOK_SIGN_IN_METHOD, accessToken: e }) } static credentialFromResult(e) { return $n.credentialFromTaggedObject(e) } static credentialFromError(e) { return $n.credentialFromTaggedObject(e.customData || {}) } static credentialFromTaggedObject({ _tokenResponse: e }) { if (!e || !("oauthAccessToken" in e) || !e.oauthAccessToken) return null; try { return $n.credential(e.oauthAccessToken) } catch { return null } } } $n.FACEBOOK_SIGN_IN_METHOD = "facebook.com"; $n.PROVIDER_ID = "facebook.com";/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */class ln extends vo { constructor() { super("google.com"), this.addScope("profile") } static credential(e, n) { return zr._fromParams({ providerId: ln.PROVIDER_ID, signInMethod: ln.GOOGLE_SIGN_IN_METHOD, idToken: e, accessToken: n }) } static credentialFromResult(e) { return ln.credentialFromTaggedObject(e) } static credentialFromError(e) { return ln.credentialFromTaggedObject(e.customData || {}) } static credentialFromTaggedObject({ _tokenResponse: e }) { if (!e) return null; const { oauthIdToken: n, oauthAccessToken: r } = e; if (!n && !r) return null; try { return ln.credential(n, r) } catch { return null } } } ln.GOOGLE_SIGN_IN_METHOD = "google.com"; ln.PROVIDER_ID = "google.com";/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */class Bn extends vo { constructor() { super("github.com") } static credential(e) { return zr._fromParams({ providerId: Bn.PROVIDER_ID, signInMethod: Bn.GITHUB_SIGN_IN_METHOD, accessToken: e }) } static credentialFromResult(e) { return Bn.credentialFromTaggedObject(e) } static credentialFromError(e) { return Bn.credentialFromTaggedObject(e.customData || {}) } static credentialFromTaggedObject({ _tokenResponse: e }) { if (!e || !("oauthAccessToken" in e) || !e.oauthAccessToken) return null; try { return Bn.credential(e.oauthAccessToken) } catch { return null } } } Bn.GITHUB_SIGN_IN_METHOD = "github.com"; Bn.PROVIDER_ID = "github.com";/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */class Hn extends vo { constructor() { super("twitter.com") } static credential(e, n) { return zr._fromParams({ providerId: Hn.PROVIDER_ID, signInMethod: Hn.TWITTER_SIGN_IN_METHOD, oauthToken: e, oauthTokenSecret: n }) } static credentialFromResult(e) { return Hn.credentialFromTaggedObject(e) } static credentialFromError(e) { return Hn.credentialFromTaggedObject(e.customData || {}) } static credentialFromTaggedObject({ _tokenResponse: e }) { if (!e) return null; const { oauthAccessToken: n, oauthTokenSecret: r } = e; if (!n || !r) return null; try { return Hn.credential(n, r) } catch { return null } } } Hn.TWITTER_SIGN_IN_METHOD = "twitter.com"; Hn.PROVIDER_ID = "twitter.com";/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */async function hC(t, e) { return go(t, "POST", "/v1/accounts:signUp", pr(t, e)) }/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */class $r { constructor(e) { this.user = e.user, this.providerId = e.providerId, this._tokenResponse = e._tokenResponse, this.operationType = e.operationType } static async _fromIdTokenResponse(e, n, r, i = !1) { const s = await fn._fromIdTokenResponse(e, r, i), o = em(r); return new $r({ user: s, providerId: o, _tokenResponse: r, operationType: n }) } static async _forOperation(e, n, r) { await e._updateTokensIfNecessary(r, !0); const i = em(r); return new $r({ user: e, providerId: i, _tokenResponse: r, operationType: n }) } } function em(t) { return t.providerId ? t.providerId : "phoneNumber" in t ? "phone" : null }/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */class rl extends fr { constructor(e, n, r, i) { var s; super(n.code, n.message), this.operationType = r, this.user = i, Object.setPrototypeOf(this, rl.prototype), this.customData = { appName: e.name, tenantId: (s = e.tenantId) !== null && s !== void 0 ? s : void 0, _serverResponse: n.customData._serverResponse, operationType: r } } static _fromErrorAndOperation(e, n, r, i) { return new rl(e, n, r, i) } } function Jy(t, e, n, r) { return (e === "reauthenticate" ? n._getReauthenticationResolver(t) : n._getIdTokenResponse(t)).catch(s => { throw s.code === "auth/multi-factor-auth-required" ? rl._fromErrorAndOperation(t, s, e, r) : s }) } async function mC(t, e, n = !1) { const r = await $i(t, e._linkToIdToken(t.auth, await t.getIdToken()), n); return $r._forOperation(t, "link", r) }/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */async function gC(t, e, n = !1) { const { auth: r } = t; if (Lt(r.app)) return Promise.reject(gn(r)); const i = "reauthenticate"; try { const s = await $i(t, Jy(r, i, e, t), n); Y(s.idToken, r, "internal-error"); const o = Rf(s.idToken); Y(o, r, "internal-error"); const { sub: l } = o; return Y(t.uid === l, r, "user-mismatch"), $r._forOperation(t, i, s) } catch (s) { throw (s == null ? void 0 : s.code) === "auth/user-not-found" && It(r, "user-mismatch"), s } }/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */async function Xy(t, e, n = !1) { if (Lt(t.app)) return Promise.reject(gn(t)); const r = "signIn", i = await Jy(t, r, e), s = await $r._fromIdTokenResponse(t, r, i); return n || await t._updateCurrentUser(s.user), s } async function vC(t, e) { return Xy(hr(t), e) }/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */async function Qy(t) { const e = hr(t); e._getPasswordPolicyInternal() && await e._updatePasswordPolicy() } async function yC(t, e, n) { if (Lt(t.app)) return Promise.reject(gn(t)); const r = hr(t), o = await ed(r, { returnSecureToken: !0, email: e, password: n, clientType: "CLIENT_TYPE_WEB" }, "signUpPassword", hC).catch(a => { throw a.code === "auth/password-does-not-meet-requirements" && Qy(t), a }), l = await $r._fromIdTokenResponse(r, "signIn", o); return await r._updateCurrentUser(l.user), l } function wC(t, e, n) { return Lt(t.app) ? Promise.reject(gn(t)) : vC(Qt(t), Gi.credential(e, n)).catch(async r => { throw r.code === "auth/password-does-not-meet-requirements" && Qy(t), r }) }/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */async function xC(t, e) { return kn(t, "POST", "/v1/accounts:update", e) }/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */async function SC(t, { displayName: e, photoURL: n }) { if (e === void 0 && n === void 0) return; const r = Qt(t), s = { idToken: await r.getIdToken(), displayName: e, photoUrl: n, returnSecureToken: !0 }, o = await $i(r, xC(r.auth, s)); r.displayName = o.displayName || null, r.photoURL = o.photoUrl || null; const l = r.providerData.find(({ providerId: a }) => a === "password"); l && (l.displayName = r.displayName, l.photoURL = r.photoURL), await r._updateTokensIfNecessary(o) } function EC(t, e, n, r) { return Qt(t).onIdTokenChanged(e, n, r) } function bC(t, e, n) { return Qt(t).beforeAuthStateChanged(e, n) } function TC(t, e, n, r) { return Qt(t).onAuthStateChanged(e, n, r) } function CC(t) { return Qt(t).signOut() } const il = "__sak";/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */class Zy { constructor(e, n) { this.storageRetriever = e, this.type = n } _isAvailable() { try { return this.storage ? (this.storage.setItem(il, "1"), this.storage.removeItem(il), Promise.resolve(!0)) : Promise.resolve(!1) } catch { return Promise.resolve(!1) } } _set(e, n) { return this.storage.setItem(e, JSON.stringify(n)), Promise.resolve() } _get(e) { const n = this.storage.getItem(e); return Promise.resolve(n ? JSON.parse(n) : null) } _remove(e) { return this.storage.removeItem(e), Promise.resolve() } get storage() { return this.storageRetriever() } }/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */const _C = 1e3, PC = 10; class e0 extends Zy { constructor() { super(() => window.localStorage, "LOCAL"), this.boundEventHandler = (e, n) => this.onStorageEvent(e, n), this.listeners = {}, this.localCache = {}, this.pollTimer = null, this.fallbackToPolling = Wy(), this._shouldAllowMigration = !0 } forAllChangedKeys(e) { for (const n of Object.keys(this.listeners)) { const r = this.storage.getItem(n), i = this.localCache[n]; r !== i && e(n, i, r) } } onStorageEvent(e, n = !1) { if (!e.key) { this.forAllChangedKeys((o, l, a) => { this.notifyListeners(o, a) }); return } const r = e.key; n ? this.detachListener() : this.stopPolling(); const i = () => { const o = this.storage.getItem(r); !n && this.localCache[r] === o || this.notifyListeners(r, o) }, s = this.storage.getItem(r); BT() && s !== e.newValue && e.newValue !== e.oldValue ? setTimeout(i, PC) : i() } notifyListeners(e, n) { this.localCache[e] = n; const r = this.listeners[e]; if (r) for (const i of Array.from(r)) i(n && JSON.parse(n)) } startPolling() { this.stopPolling(), this.pollTimer = setInterval(() => { this.forAllChangedKeys((e, n, r) => { this.onStorageEvent(new StorageEvent("storage", { key: e, oldValue: n, newValue: r }), !0) }) }, _C) } stopPolling() { this.pollTimer && (clearInterval(this.pollTimer), this.pollTimer = null) } attachListener() { window.addEventListener("storage", this.boundEventHandler) } detachListener() { window.removeEventListener("storage", this.boundEventHandler) } _addListener(e, n) { Object.keys(this.listeners).length === 0 && (this.fallbackToPolling ? this.startPolling() : this.attachListener()), this.listeners[e] || (this.listeners[e] = new Set, this.localCache[e] = this.storage.getItem(e)), this.listeners[e].add(n) } _removeListener(e, n) { this.listeners[e] && (this.listeners[e].delete(n), this.listeners[e].size === 0 && delete this.listeners[e]), Object.keys(this.listeners).length === 0 && (this.detachListener(), this.stopPolling()) } async _set(e, n) { await super._set(e, n), this.localCache[e] = JSON.stringify(n) } async _get(e) { const n = await super._get(e); return this.localCache[e] = JSON.stringify(n), n } async _remove(e) { await super._remove(e), delete this.localCache[e] } } e0.type = "LOCAL"; const IC = e0;/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */class t0 extends Zy { constructor() { super(() => window.sessionStorage, "SESSION") } _addListener(e, n) { } _removeListener(e, n) { } } t0.type = "SESSION"; const n0 = t0;/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */function kC(t) { return Promise.all(t.map(async e => { try { return { fulfilled: !0, value: await e } } catch (n) { return { fulfilled: !1, reason: n } } })) }/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */class Fl { constructor(e) { this.eventTarget = e, this.handlersMap = {}, this.boundEventHandler = this.handleEvent.bind(this) } static _getInstance(e) { const n = this.receivers.find(i => i.isListeningto(e)); if (n) return n; const r = new Fl(e); return this.receivers.push(r), r } isListeningto(e) { return this.eventTarget === e } async handleEvent(e) { const n = e, { eventId: r, eventType: i, data: s } = n.data, o = this.handlersMap[i]; if (!(o != null && o.size)) return; n.ports[0].postMessage({ status: "ack", eventId: r, eventType: i }); const l = Array.from(o).map(async c => c(n.origin, s)), a = await kC(l); n.ports[0].postMessage({ status: "done", eventId: r, eventType: i, response: a }) } _subscribe(e, n) { Object.keys(this.handlersMap).length === 0 && this.eventTarget.addEventListener("message", this.boundEventHandler), this.handlersMap[e] || (this.handlersMap[e] = new Set), this.handlersMap[e].add(n) } _unsubscribe(e, n) { this.handlersMap[e] && n && this.handlersMap[e].delete(n), (!n || this.handlersMap[e].size === 0) && delete this.handlersMap[e], Object.keys(this.handlersMap).length === 0 && this.eventTarget.removeEventListener("message", this.boundEventHandler) } } Fl.receivers = [];/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */function Df(t = "", e = 10) { let n = ""; for (let r = 0; r < e; r++)n += Math.floor(Math.random() * 10); return t + n }/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */class NC { constructor(e) { this.target = e, this.handlers = new Set } removeMessageHandler(e) { e.messageChannel && (e.messageChannel.port1.removeEventListener("message", e.onMessage), e.messageChannel.port1.close()), this.handlers.delete(e) } async _send(e, n, r = 50) { const i = typeof MessageChannel < "u" ? new MessageChannel : null; if (!i) throw new Error("connection_unavailable"); let s, o; return new Promise((l, a) => { const c = Df("", 20); i.port1.start(); const u = setTimeout(() => { a(new Error("unsupported_event")) }, r); o = { messageChannel: i, onMessage(f) { const h = f; if (h.data.eventId === c) switch (h.data.status) { case "ack": clearTimeout(u), s = setTimeout(() => { a(new Error("timeout")) }, 3e3); break; case "done": clearTimeout(s), l(h.data.response); break; default: clearTimeout(u), clearTimeout(s), a(new Error("invalid_response")); break } } }, this.handlers.add(o), i.port1.addEventListener("message", o.onMessage), this.target.postMessage({ eventType: e, eventId: c, data: n }, [i.port2]) }).finally(() => { o && this.removeMessageHandler(o) }) } }/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */function Xt() { return window } function RC(t) { Xt().location.href = t }/**
 * @license
 * Copyright 2020 Google LLC.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */function r0() { return typeof Xt().WorkerGlobalScope < "u" && typeof Xt().importScripts == "function" } async function OC() { if (!(navigator != null && navigator.serviceWorker)) return null; try { return (await navigator.serviceWorker.ready).active } catch { return null } } function jC() { var t; return ((t = navigator == null ? void 0 : navigator.serviceWorker) === null || t === void 0 ? void 0 : t.controller) || null } function AC() { return r0() ? self : null }/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */const i0 = "firebaseLocalStorageDb", LC = 1, sl = "firebaseLocalStorage", s0 = "fbase_key"; class yo { constructor(e) { this.request = e } toPromise() { return new Promise((e, n) => { this.request.addEventListener("success", () => { e(this.request.result) }), this.request.addEventListener("error", () => { n(this.request.error) }) }) } } function Ul(t, e) { return t.transaction([sl], e ? "readwrite" : "readonly").objectStore(sl) } function DC() { const t = indexedDB.deleteDatabase(i0); return new yo(t).toPromise() } function td() { const t = indexedDB.open(i0, LC); return new Promise((e, n) => { t.addEventListener("error", () => { n(t.error) }), t.addEventListener("upgradeneeded", () => { const r = t.result; try { r.createObjectStore(sl, { keyPath: s0 }) } catch (i) { n(i) } }), t.addEventListener("success", async () => { const r = t.result; r.objectStoreNames.contains(sl) ? e(r) : (r.close(), await DC(), e(await td())) }) }) } async function tm(t, e, n) { const r = Ul(t, !0).put({ [s0]: e, value: n }); return new yo(r).toPromise() } async function MC(t, e) { const n = Ul(t, !1).get(e), r = await new yo(n).toPromise(); return r === void 0 ? null : r.value } function nm(t, e) { const n = Ul(t, !0).delete(e); return new yo(n).toPromise() } const FC = 800, UC = 3; class o0 { constructor() { this.type = "LOCAL", this._shouldAllowMigration = !0, this.listeners = {}, this.localCache = {}, this.pollTimer = null, this.pendingWrites = 0, this.receiver = null, this.sender = null, this.serviceWorkerReceiverAvailable = !1, this.activeServiceWorker = null, this._workerInitializationPromise = this.initializeServiceWorkerMessaging().then(() => { }, () => { }) } async _openDb() { return this.db ? this.db : (this.db = await td(), this.db) } async _withRetries(e) { let n = 0; for (; ;)try { const r = await this._openDb(); return await e(r) } catch (r) { if (n++ > UC) throw r; this.db && (this.db.close(), this.db = void 0) } } async initializeServiceWorkerMessaging() { return r0() ? this.initializeReceiver() : this.initializeSender() } async initializeReceiver() { this.receiver = Fl._getInstance(AC()), this.receiver._subscribe("keyChanged", async (e, n) => ({ keyProcessed: (await this._poll()).includes(n.key) })), this.receiver._subscribe("ping", async (e, n) => ["keyChanged"]) } async initializeSender() { var e, n; if (this.activeServiceWorker = await OC(), !this.activeServiceWorker) return; this.sender = new NC(this.activeServiceWorker); const r = await this.sender._send("ping", {}, 800); r && !((e = r[0]) === null || e === void 0) && e.fulfilled && !((n = r[0]) === null || n === void 0) && n.value.includes("keyChanged") && (this.serviceWorkerReceiverAvailable = !0) } async notifyServiceWorker(e) { if (!(!this.sender || !this.activeServiceWorker || jC() !== this.activeServiceWorker)) try { await this.sender._send("keyChanged", { key: e }, this.serviceWorkerReceiverAvailable ? 800 : 50) } catch { } } async _isAvailable() { try { if (!indexedDB) return !1; const e = await td(); return await tm(e, il, "1"), await nm(e, il), !0 } catch { } return !1 } async _withPendingWrite(e) { this.pendingWrites++; try { await e() } finally { this.pendingWrites-- } } async _set(e, n) { return this._withPendingWrite(async () => (await this._withRetries(r => tm(r, e, n)), this.localCache[e] = n, this.notifyServiceWorker(e))) } async _get(e) { const n = await this._withRetries(r => MC(r, e)); return this.localCache[e] = n, n } async _remove(e) { return this._withPendingWrite(async () => (await this._withRetries(n => nm(n, e)), delete this.localCache[e], this.notifyServiceWorker(e))) } async _poll() { const e = await this._withRetries(i => { const s = Ul(i, !1).getAll(); return new yo(s).toPromise() }); if (!e) return []; if (this.pendingWrites !== 0) return []; const n = [], r = new Set; if (e.length !== 0) for (const { fbase_key: i, value: s } of e) r.add(i), JSON.stringify(this.localCache[i]) !== JSON.stringify(s) && (this.notifyListeners(i, s), n.push(i)); for (const i of Object.keys(this.localCache)) this.localCache[i] && !r.has(i) && (this.notifyListeners(i, null), n.push(i)); return n } notifyListeners(e, n) { this.localCache[e] = n; const r = this.listeners[e]; if (r) for (const i of Array.from(r)) i(n) } startPolling() { this.stopPolling(), this.pollTimer = setInterval(async () => this._poll(), FC) } stopPolling() { this.pollTimer && (clearInterval(this.pollTimer), this.pollTimer = null) } _addListener(e, n) { Object.keys(this.listeners).length === 0 && this.startPolling(), this.listeners[e] || (this.listeners[e] = new Set, this._get(e)), this.listeners[e].add(n) } _removeListener(e, n) { this.listeners[e] && (this.listeners[e].delete(n), this.listeners[e].size === 0 && delete this.listeners[e]), Object.keys(this.listeners).length === 0 && this.stopPolling() } } o0.type = "LOCAL"; const zC = o0; new mo(3e4, 6e4);/**
 * @license
 * Copyright 2021 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */function a0(t, e) { return e ? pn(e) : (Y(t._popupRedirectResolver, t, "argument-error"), t._popupRedirectResolver) }/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */class Mf extends jf { constructor(e) { super("custom", "custom"), this.params = e } _getIdTokenResponse(e) { return _i(e, this._buildIdpRequest()) } _linkToIdToken(e, n) { return _i(e, this._buildIdpRequest(n)) } _getReauthenticationResolver(e) { return _i(e, this._buildIdpRequest()) } _buildIdpRequest(e) { const n = { requestUri: this.params.requestUri, sessionId: this.params.sessionId, postBody: this.params.postBody, tenantId: this.params.tenantId, pendingToken: this.params.pendingToken, returnSecureToken: !0, returnIdpCredential: !0 }; return e && (n.idToken = e), n } } function $C(t) { return Xy(t.auth, new Mf(t), t.bypassAuthState) } function BC(t) { const { auth: e, user: n } = t; return Y(n, e, "internal-error"), gC(n, new Mf(t), t.bypassAuthState) } async function HC(t) { const { auth: e, user: n } = t; return Y(n, e, "internal-error"), mC(n, new Mf(t), t.bypassAuthState) }/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */class l0 { constructor(e, n, r, i, s = !1) { this.auth = e, this.resolver = r, this.user = i, this.bypassAuthState = s, this.pendingPromise = null, this.eventManager = null, this.filter = Array.isArray(n) ? n : [n] } execute() { return new Promise(async (e, n) => { this.pendingPromise = { resolve: e, reject: n }; try { this.eventManager = await this.resolver._initialize(this.auth), await this.onExecution(), this.eventManager.registerConsumer(this) } catch (r) { this.reject(r) } }) } async onAuthEvent(e) { const { urlResponse: n, sessionId: r, postBody: i, tenantId: s, error: o, type: l } = e; if (o) { this.reject(o); return } const a = { auth: this.auth, requestUri: n, sessionId: r, tenantId: s || void 0, postBody: i || void 0, user: this.user, bypassAuthState: this.bypassAuthState }; try { this.resolve(await this.getIdpTask(l)(a)) } catch (c) { this.reject(c) } } onError(e) { this.reject(e) } getIdpTask(e) { switch (e) { case "signInViaPopup": case "signInViaRedirect": return $C; case "linkViaPopup": case "linkViaRedirect": return HC; case "reauthViaPopup": case "reauthViaRedirect": return BC; default: It(this.auth, "internal-error") } } resolve(e) { Tn(this.pendingPromise, "Pending promise was never set"), this.pendingPromise.resolve(e), this.unregisterAndCleanUp() } reject(e) { Tn(this.pendingPromise, "Pending promise was never set"), this.pendingPromise.reject(e), this.unregisterAndCleanUp() } unregisterAndCleanUp() { this.eventManager && this.eventManager.unregisterConsumer(this), this.pendingPromise = null, this.cleanUp() } }/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */const VC = new mo(2e3, 1e4); async function WC(t, e, n) { if (Lt(t.app)) return Promise.reject(Ut(t, "operation-not-supported-in-this-environment")); const r = hr(t); bT(t, e, Lf); const i = a0(r, n); return new Ir(r, "signInViaPopup", e, i).executeNotNull() } class Ir extends l0 { constructor(e, n, r, i, s) { super(e, n, i, s), this.provider = r, this.authWindow = null, this.pollId = null, Ir.currentPopupAction && Ir.currentPopupAction.cancel(), Ir.currentPopupAction = this } async executeNotNull() { const e = await this.execute(); return Y(e, this.auth, "internal-error"), e } async onExecution() { Tn(this.filter.length === 1, "Popup operations only handle one event"); const e = Df(); this.authWindow = await this.resolver._openPopup(this.auth, this.provider, this.filter[0], e), this.authWindow.associatedEvent = e, this.resolver._originValidation(this.auth).catch(n => { this.reject(n) }), this.resolver._isIframeWebStorageSupported(this.auth, n => { n || this.reject(Ut(this.auth, "web-storage-unsupported")) }), this.pollUserCancellation() } get eventId() { var e; return ((e = this.authWindow) === null || e === void 0 ? void 0 : e.associatedEvent) || null } cancel() { this.reject(Ut(this.auth, "cancelled-popup-request")) } cleanUp() { this.authWindow && this.authWindow.close(), this.pollId && window.clearTimeout(this.pollId), this.authWindow = null, this.pollId = null, Ir.currentPopupAction = null } pollUserCancellation() { const e = () => { var n, r; if (!((r = (n = this.authWindow) === null || n === void 0 ? void 0 : n.window) === null || r === void 0) && r.closed) { this.pollId = window.setTimeout(() => { this.pollId = null, this.reject(Ut(this.auth, "popup-closed-by-user")) }, 8e3); return } this.pollId = window.setTimeout(e, VC.get()) }; e() } } Ir.currentPopupAction = null;/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */const GC = "pendingRedirect", pa = new Map; class KC extends l0 { constructor(e, n, r = !1) { super(e, ["signInViaRedirect", "linkViaRedirect", "reauthViaRedirect", "unknown"], n, void 0, r), this.eventId = null } async execute() { let e = pa.get(this.auth._key()); if (!e) { try { const r = await qC(this.resolver, this.auth) ? await super.execute() : null; e = () => Promise.resolve(r) } catch (n) { e = () => Promise.reject(n) } pa.set(this.auth._key(), e) } return this.bypassAuthState || pa.set(this.auth._key(), () => Promise.resolve(null)), e() } async onAuthEvent(e) { if (e.type === "signInViaRedirect") return super.onAuthEvent(e); if (e.type === "unknown") { this.resolve(null); return } if (e.eventId) { const n = await this.auth._redirectUserForId(e.eventId); if (n) return this.user = n, super.onAuthEvent(e); this.resolve(null) } } async onExecution() { } cleanUp() { } } async function qC(t, e) { const n = XC(e), r = JC(t); if (!await r._isAvailable()) return !1; const i = await r._get(n) === "true"; return await r._remove(n), i } function YC(t, e) { pa.set(t._key(), e) } function JC(t) { return pn(t._redirectPersistence) } function XC(t) { return fa(GC, t.config.apiKey, t.name) } async function QC(t, e, n = !1) { if (Lt(t.app)) return Promise.reject(gn(t)); const r = hr(t), i = a0(r, e), o = await new KC(r, i, n).execute(); return o && !n && (delete o.user._redirectEventId, await r._persistUserIfCurrent(o.user), await r._setRedirectUser(null, e)), o }/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */const ZC = 10 * 60 * 1e3; class e_ { constructor(e) { this.auth = e, this.cachedEventUids = new Set, this.consumers = new Set, this.queuedRedirectEvent = null, this.hasHandledPotentialRedirect = !1, this.lastProcessedEventTime = Date.now() } registerConsumer(e) { this.consumers.add(e), this.queuedRedirectEvent && this.isEventForConsumer(this.queuedRedirectEvent, e) && (this.sendToConsumer(this.queuedRedirectEvent, e), this.saveEventToCache(this.queuedRedirectEvent), this.queuedRedirectEvent = null) } unregisterConsumer(e) { this.consumers.delete(e) } onEvent(e) { if (this.hasEventBeenHandled(e)) return !1; let n = !1; return this.consumers.forEach(r => { this.isEventForConsumer(e, r) && (n = !0, this.sendToConsumer(e, r), this.saveEventToCache(e)) }), this.hasHandledPotentialRedirect || !t_(e) || (this.hasHandledPotentialRedirect = !0, n || (this.queuedRedirectEvent = e, n = !0)), n } sendToConsumer(e, n) { var r; if (e.error && !c0(e)) { const i = ((r = e.error.code) === null || r === void 0 ? void 0 : r.split("auth/")[1]) || "internal-error"; n.onError(Ut(this.auth, i)) } else n.onAuthEvent(e) } isEventForConsumer(e, n) { const r = n.eventId === null || !!e.eventId && e.eventId === n.eventId; return n.filter.includes(e.type) && r } hasEventBeenHandled(e) { return Date.now() - this.lastProcessedEventTime >= ZC && this.cachedEventUids.clear(), this.cachedEventUids.has(rm(e)) } saveEventToCache(e) { this.cachedEventUids.add(rm(e)), this.lastProcessedEventTime = Date.now() } } function rm(t) { return [t.type, t.eventId, t.sessionId, t.tenantId].filter(e => e).join("-") } function c0({ type: t, error: e }) { return t === "unknown" && (e == null ? void 0 : e.code) === "auth/no-auth-event" } function t_(t) { switch (t.type) { case "signInViaRedirect": case "linkViaRedirect": case "reauthViaRedirect": return !0; case "unknown": return c0(t); default: return !1 } }/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */async function n_(t, e = {}) { return kn(t, "GET", "/v1/projects", e) }/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */const r_ = /^\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}$/, i_ = /^https?/; async function s_(t) { if (t.config.emulator) return; const { authorizedDomains: e } = await n_(t); for (const n of e) try { if (o_(n)) return } catch { } It(t, "unauthorized-domain") } function o_(t) { const e = Qu(), { protocol: n, hostname: r } = new URL(e); if (t.startsWith("chrome-extension://")) { const o = new URL(t); return o.hostname === "" && r === "" ? n === "chrome-extension:" && t.replace("chrome-extension://", "") === e.replace("chrome-extension://", "") : n === "chrome-extension:" && o.hostname === r } if (!i_.test(n)) return !1; if (r_.test(t)) return r === t; const i = t.replace(/\./g, "\\."); return new RegExp("^(.+\\." + i + "|" + i + ")$", "i").test(r) }/**
 * @license
 * Copyright 2020 Google LLC.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */const a_ = new mo(3e4, 6e4); function im() { const t = Xt().___jsl; if (t != null && t.H) { for (const e of Object.keys(t.H)) if (t.H[e].r = t.H[e].r || [], t.H[e].L = t.H[e].L || [], t.H[e].r = [...t.H[e].L], t.CP) for (let n = 0; n < t.CP.length; n++)t.CP[n] = null } } function l_(t) { return new Promise((e, n) => { var r, i, s; function o() { im(), gapi.load("gapi.iframes", { callback: () => { e(gapi.iframes.getContext()) }, ontimeout: () => { im(), n(Ut(t, "network-request-failed")) }, timeout: a_.get() }) } if (!((i = (r = Xt().gapi) === null || r === void 0 ? void 0 : r.iframes) === null || i === void 0) && i.Iframe) e(gapi.iframes.getContext()); else if (!((s = Xt().gapi) === null || s === void 0) && s.load) o(); else { const l = XT("iframefcb"); return Xt()[l] = () => { gapi.load ? o() : n(Ut(t, "network-request-failed")) }, Ky(`${JT()}?onload=${l}`).catch(a => n(a)) } }).catch(e => { throw ha = null, e }) } let ha = null; function c_(t) { return ha = ha || l_(t), ha }/**
 * @license
 * Copyright 2020 Google LLC.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */const u_ = new mo(5e3, 15e3), d_ = "__/auth/iframe", f_ = "emulator/auth/iframe", p_ = { style: { position: "absolute", top: "-100px", width: "1px", height: "1px" }, "aria-hidden": "true", tabindex: "-1" }, h_ = new Map([["identitytoolkit.googleapis.com", "p"], ["staging-identitytoolkit.sandbox.googleapis.com", "s"], ["test-identitytoolkit.sandbox.googleapis.com", "t"]]); function m_(t) { const e = t.config; Y(e.authDomain, t, "auth-domain-config-required"); const n = e.emulator ? Nf(e, f_) : `https://${t.config.authDomain}/${d_}`, r = { apiKey: e.apiKey, appName: t.name, v: ho }, i = h_.get(t.config.apiHost); i && (r.eid = i); const s = t._getFrameworks(); return s.length && (r.fw = s.join(",")), `${n}?${po(r).slice(1)}` } async function g_(t) { const e = await c_(t), n = Xt().gapi; return Y(n, t, "internal-error"), e.open({ where: document.body, url: m_(t), messageHandlersFilter: n.iframes.CROSS_ORIGIN_IFRAMES_FILTER, attributes: p_, dontclear: !0 }, r => new Promise(async (i, s) => { await r.restyle({ setHideOnLeave: !1 }); const o = Ut(t, "network-request-failed"), l = Xt().setTimeout(() => { s(o) }, u_.get()); function a() { Xt().clearTimeout(l), i(r) } r.ping(a).then(a, () => { s(o) }) })) }/**
 * @license
 * Copyright 2020 Google LLC.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */const v_ = { location: "yes", resizable: "yes", statusbar: "yes", toolbar: "no" }, y_ = 500, w_ = 600, x_ = "_blank", S_ = "http://localhost"; class sm { constructor(e) { this.window = e, this.associatedEvent = null } close() { if (this.window) try { this.window.close() } catch { } } } function E_(t, e, n, r = y_, i = w_) { const s = Math.max((window.screen.availHeight - i) / 2, 0).toString(), o = Math.max((window.screen.availWidth - r) / 2, 0).toString(); let l = ""; const a = Object.assign(Object.assign({}, v_), { width: r.toString(), height: i.toString(), top: s, left: o }), c = Ze().toLowerCase(); n && (l = zy(c) ? x_ : n), Fy(c) && (e = e || S_, a.scrollbars = "yes"); const u = Object.entries(a).reduce((h, [y, g]) => `${h}${y}=${g},`, ""); if ($T(c) && l !== "_self") return b_(e || "", l), new sm(null); const f = window.open(e || "", l, u); Y(f, t, "popup-blocked"); try { f.focus() } catch { } return new sm(f) } function b_(t, e) { const n = document.createElement("a"); n.href = t, n.target = e; const r = document.createEvent("MouseEvent"); r.initMouseEvent("click", !0, !0, window, 1, 0, 0, 0, 0, !1, !1, !1, !1, 1, null), n.dispatchEvent(r) }/**
 * @license
 * Copyright 2021 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */const T_ = "__/auth/handler", C_ = "emulator/auth/handler", __ = encodeURIComponent("fac"); async function om(t, e, n, r, i, s) { Y(t.config.authDomain, t, "auth-domain-config-required"), Y(t.config.apiKey, t, "invalid-api-key"); const o = { apiKey: t.config.apiKey, appName: t.name, authType: n, redirectUrl: r, v: ho, eventId: i }; if (e instanceof Lf) { e.setDefaultLanguage(t.languageCode), o.providerId = e.providerId || "", cb(e.getCustomParameters()) || (o.customParameters = JSON.stringify(e.getCustomParameters())); for (const [u, f] of Object.entries({})) o[u] = f } if (e instanceof vo) { const u = e.getScopes().filter(f => f !== ""); u.length > 0 && (o.scopes = u.join(",")) } t.tenantId && (o.tid = t.tenantId); const l = o; for (const u of Object.keys(l)) l[u] === void 0 && delete l[u]; const a = await t._getAppCheckToken(), c = a ? `#${__}=${encodeURIComponent(a)}` : ""; return `${P_(t)}?${po(l).slice(1)}${c}` } function P_({ config: t }) { return t.emulator ? Nf(t, C_) : `https://${t.authDomain}/${T_}` }/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */const jc = "webStorageSupport"; class I_ { constructor() { this.eventManagers = {}, this.iframes = {}, this.originValidationPromises = {}, this._redirectPersistence = n0, this._completeRedirectFn = QC, this._overrideRedirectResult = YC } async _openPopup(e, n, r, i) { var s; Tn((s = this.eventManagers[e._key()]) === null || s === void 0 ? void 0 : s.manager, "_initialize() not called before _openPopup()"); const o = await om(e, n, r, Qu(), i); return E_(e, o, Df()) } async _openRedirect(e, n, r, i) { await this._originValidation(e); const s = await om(e, n, r, Qu(), i); return RC(s), new Promise(() => { }) } _initialize(e) { const n = e._key(); if (this.eventManagers[n]) { const { manager: i, promise: s } = this.eventManagers[n]; return i ? Promise.resolve(i) : (Tn(s, "If manager is not set, promise should be"), s) } const r = this.initAndGetManager(e); return this.eventManagers[n] = { promise: r }, r.catch(() => { delete this.eventManagers[n] }), r } async initAndGetManager(e) { const n = await g_(e), r = new e_(e); return n.register("authEvent", i => (Y(i == null ? void 0 : i.authEvent, e, "invalid-auth-event"), { status: r.onEvent(i.authEvent) ? "ACK" : "ERROR" }), gapi.iframes.CROSS_ORIGIN_IFRAMES_FILTER), this.eventManagers[e._key()] = { manager: r }, this.iframes[e._key()] = n, r } _isIframeWebStorageSupported(e, n) { this.iframes[e._key()].send(jc, { type: jc }, i => { var s; const o = (s = i == null ? void 0 : i[0]) === null || s === void 0 ? void 0 : s[jc]; o !== void 0 && n(!!o), It(e, "internal-error") }, gapi.iframes.CROSS_ORIGIN_IFRAMES_FILTER) } _originValidation(e) { const n = e._key(); return this.originValidationPromises[n] || (this.originValidationPromises[n] = s_(e)), this.originValidationPromises[n] } get _shouldInitProactively() { return Wy() || Uy() || Of() } } const k_ = I_; var am = "@firebase/auth", lm = "1.8.1";/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */class N_ { constructor(e) { this.auth = e, this.internalListeners = new Map } getUid() { var e; return this.assertAuthConfigured(), ((e = this.auth.currentUser) === null || e === void 0 ? void 0 : e.uid) || null } async getToken(e) { return this.assertAuthConfigured(), await this.auth._initializationPromise, this.auth.currentUser ? { accessToken: await this.auth.currentUser.getIdToken(e) } : null } addAuthTokenListener(e) { if (this.assertAuthConfigured(), this.internalListeners.has(e)) return; const n = this.auth.onIdTokenChanged(r => { e((r == null ? void 0 : r.stsTokenManager.accessToken) || null) }); this.internalListeners.set(e, n), this.updateProactiveRefresh() } removeAuthTokenListener(e) { this.assertAuthConfigured(); const n = this.internalListeners.get(e); n && (this.internalListeners.delete(e), n(), this.updateProactiveRefresh()) } assertAuthConfigured() { Y(this.auth._initializationPromise, "dependent-sdk-initialized-before-auth") } updateProactiveRefresh() { this.internalListeners.size > 0 ? this.auth._startProactiveRefresh() : this.auth._stopProactiveRefresh() } }/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */function R_(t) { switch (t) { case "Node": return "node"; case "ReactNative": return "rn"; case "Worker": return "webworker"; case "Cordova": return "cordova"; case "WebExtension": return "web-extension"; default: return } } function O_(t) { eo(new zi("auth", (e, { options: n }) => { const r = e.getProvider("app").getImmediate(), i = e.getProvider("heartbeat"), s = e.getProvider("app-check-internal"), { apiKey: o, authDomain: l } = r.options; Y(o && !o.includes(":"), "invalid-api-key", { appName: r.name }); const a = { apiKey: o, authDomain: l, clientPlatform: t, apiHost: "identitytoolkit.googleapis.com", tokenApiHost: "securetoken.googleapis.com", apiScheme: "https", sdkClientVersion: Gy(t) }, c = new KT(r, i, s, a); return rC(c, n), c }, "PUBLIC").setInstantiationMode("EXPLICIT").setInstanceCreatedCallback((e, n, r) => { e.getProvider("auth-internal").initialize() })), eo(new zi("auth-internal", e => { const n = hr(e.getProvider("auth").getImmediate()); return (r => new N_(r))(n) }, "PRIVATE").setInstantiationMode("EXPLICIT")), bi(am, lm, R_(t)), bi(am, lm, "esm2017") }/**
 * @license
 * Copyright 2021 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */const j_ = 5 * 60, A_ = Ey("authIdTokenMaxAge") || j_; let cm = null; const L_ = t => async e => { const n = e && await e.getIdTokenResult(), r = n && (new Date().getTime() - Date.parse(n.issuedAtTime)) / 1e3; if (r && r > A_) return; const i = n == null ? void 0 : n.token; cm !== i && (cm = i, await fetch(t, { method: i ? "POST" : "DELETE", headers: i ? { Authorization: `Bearer ${i}` } : {} })) }; function D_(t = dT()) { const e = _y(t, "auth"); if (e.isInitialized()) return e.getImmediate(); const n = nC(t, { popupRedirectResolver: k_, persistence: [zC, IC, n0] }), r = Ey("authTokenSyncURL"); if (r && typeof isSecureContext == "boolean" && isSecureContext) { const s = new URL(r, location.origin); if (location.origin === s.origin) { const o = L_(s.toString()); bC(n, o, () => o(n.currentUser)), EC(n, l => o(l)) } } const i = XE("auth"); return i && iC(n, `http://${i}`), n } function M_() { var t, e; return (e = (t = document.getElementsByTagName("head")) === null || t === void 0 ? void 0 : t[0]) !== null && e !== void 0 ? e : document } qT({ loadJS(t) { return new Promise((e, n) => { const r = document.createElement("script"); r.setAttribute("src", t), r.onload = e, r.onerror = i => { const s = Ut("internal-error"); s.customData = i, n(s) }, r.type = "text/javascript", r.charset = "UTF-8", M_().appendChild(r) }) }, gapiScript: "https://apis.google.com/js/api.js", recaptchaV2Script: "https://www.google.com/recaptcha/api.js", recaptchaEnterpriseScript: "https://www.google.com/recaptcha/enterprise.js?render=" }); O_("Browser"); var F_ = "firebase", U_ = "11.0.2";/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */bi(F_, U_, "app"); const z_ = { apiKey: "AIzaSyDOjzwQcH_VsnUAXJkspe5GIKmJDWaAe40", authDomain: "wave3-d9177.firebaseapp.com", projectId: "wave3-d9177", storageBucket: "wave3-d9177.firebasestorage.app", messagingSenderId: "686289419830", appId: "1:686289419830:web:dfcb30861c39890760e297", measurementId: "G-HHDNG0P6VX" }, $_ = Py(z_), Ke = b.createContext(null), ri = D_($_), B_ = new ln, H_ = ({ children: t }) => { const [e, n] = b.useState(null), [r, i] = b.useState(!0), s = (f, h) => (i(!0), yC(ri, f, h)), o = (f, h) => (i(!0), wC(ri, f, h)), l = () => (i(!0), WC(ri, B_)), a = async () => (i(!0), CC(ri)), c = (f, h) => SC(ri.currentUser, { displayName: f, photoURL: h }); b.useEffect(() => { const f = TC(ri, h => { n(h), console.log("CurrentUser-->", h), i(!1) }); return () => f() }, []); const u = { user: e, setUser: n, loading: r, setLoading: i, createUser: s, signIn: o, signInWithGoogle: l, logOut: a, updateUserProfile: c }; return d.jsx(Ke.Provider, { value: u, children: t }) }, V_ = () => { const { user: t, logOut: e } = b.useContext(Ke), [n, r] = b.useState(!1); return d.jsx("nav", { className: "bg-white shadow-sm sticky top-0 z-50", children: d.jsxs("div", { className: "container mx-auto px-4 py-3 flex justify-between items-center", children: [d.jsxs(dr, { to: "/", className: "flex items-center gap-2", children: [d.jsx("img", { className: "h-7 w-auto", src: Dl, alt: "Logo" }), d.jsx("span", { className: "font-bold text-gray-800 text-lg", children: "Seba Corner" })] }), d.jsx("button", { onClick: () => r(!n), className: "lg:hidden focus:outline-none", "aria-label": "Toggle Menu", children: d.jsx("svg", { className: "w-6 h-6 text-gray-800", fill: "none", stroke: "currentColor", viewBox: "0 0 24 24", xmlns: "http://www.w3.org/2000/svg", children: d.jsx("path", { strokeLinecap: "round", strokeLinejoin: "round", strokeWidth: "2", d: "M4 6h16M4 12h16m-7 6h7" }) }) }), d.jsxs("ul", { className: `lg:flex items-center gap-8 ${n ? "block" : "hidden"} lg:block absolute lg:relative top-full left-0 w-full lg:w-auto bg-white lg:bg-transparent lg:static lg:p-0 p-4`, children: [d.jsx("li", { children: d.jsx(St, { to: "/", className: ({ isActive: i }) => `block py-2 lg:py-0 hover:text-blue-500 transition ${i ? "text-blue-500 font-semibold" : "text-gray-700"}`, children: "Home" }) }), d.jsx("li", { children: d.jsx(St, { to: "/productPage", className: ({ isActive: i }) => `block py-2 lg:py-0 hover:text-blue-500 transition ${i ? "text-blue-500 font-semibold" : "text-gray-700"}`, children: "Product" }) }), d.jsx("li", { children: d.jsx(St, { to: "/dashboard", className: ({ isActive: i }) => `block py-2 lg:py-0 hover:text-blue-500 transition ${i ? "text-blue-500 font-semibold" : "text-gray-700"}`, children: "Dashboard" }) }), t ? d.jsx("li", { className: "relative", children: d.jsxs("div", { className: "flex items-center gap-4", children: [d.jsxs("div", { className: "dropdown relative", children: [d.jsxs("button", { className: "flex items-center gap-2", role: "button", tabIndex: 0, children: [d.jsx("span", { className: "text-gray-800 font-medium", children: "Menu" }), d.jsx("svg", { className: "w-4 h-4", fill: "none", stroke: "currentColor", viewBox: "0 0 24 24", xmlns: "http://www.w3.org/2000/svg", children: d.jsx("path", { strokeLinecap: "round", strokeLinejoin: "round", strokeWidth: "2", d: "M19 9l-7 7-7-7" }) })] }), d.jsxs("ul", { className: "dropdown-menu absolute mt-2 bg-white shadow-lg rounded-lg w-40 text-sm text-gray-700 hidden", role: "menu", children: [d.jsx("li", { children: d.jsx(St, { to: "add_job", className: "block px-4 py-2 hover:bg-gray-100", children: "Add Service" }) }), d.jsx("li", { children: d.jsx(St, { to: "my_posted_jobs", className: "block px-4 py-2 hover:bg-gray-100", children: "Manage Service" }) }), d.jsx("li", { children: d.jsx(St, { to: "booked_section", className: "block px-4 py-2 hover:bg-gray-100", children: "Booked Service" }) }), d.jsx("li", { children: d.jsx(St, { to: "/productPage", className: "block px-4 py-2 hover:bg-gray-100", children: "Product" }) })] })] }), d.jsx("img", { src: t == null ? void 0 : t.photoURL, alt: "User Profile", className: "w-8 h-8 rounded-full border", title: t == null ? void 0 : t.displayName }), d.jsx("button", { onClick: e, className: "text-red-500 text-sm hover:underline", children: "Logout" })] }) }) : d.jsx("li", { children: d.jsx(St, { to: "/login", className: ({ isActive: i }) => `block py-2 lg:py-0 hover:text-blue-500 transition ${i ? "text-blue-500 font-semibold" : "text-gray-700"}`, children: "Login" }) })] })] }) }) }, W_ = () => d.jsxs("footer", { className: " shadow-sm mt-5", children: [d.jsx("hr", {}), d.jsxs("div", { className: "container px-6 py-8 mx-auto", children: [d.jsxs("div", { className: "flex flex-col items-center text-center", children: [d.jsxs("div", { className: "flex gap-2 items-center", children: [d.jsx("img", { className: "w-auto h-7", src: Dl, alt: "" }), d.jsx("span", { children: "Seba Corner " })] }), d.jsxs("div", { className: "flex flex-wrap justify-center mt-6 -mx-4", children: [d.jsxs("a", { href: "#", className: "mx-4 text-sm  transition-colors duration-300 hover:text-blue-500 ", "aria-label": "Reddit", children: [" ", " ", "   Home", " ", " "] }), d.jsxs("a", { href: "#", className: "mx-4 text-sm  transition-colors duration-300 hover:text-blue-500 ", "aria-label": "Reddit", children: [" ", " ", " About", " ", " "] }), d.jsxs("a", { href: "#", className: "mx-4 text-sm  transition-colors duration-300 hover:text-blue-500 ", "aria-label": "Reddit", children: ["   ", " ", "   Teams", " ", " "] }), d.jsxs("a", { href: "#", className: "mx-4 text-sm text-gray-600 transition-colors duration-300 hover:text-blue-500 ", "aria-label": "Reddit", children: [" ", " ", "   Privacy", " ", " "] }), d.jsxs("a", { href: "#", className: "mx-4 text-sm text-gray-600 transition-colors duration-300 hover:text-blue-500 ", "aria-label": "Reddit", children: ["   ", " ", " Cookies", " ", " "] })] })] }), d.jsx("hr", { className: "my-6  md:my-10 " }), d.jsxs("div", { className: "flex flex-col items-center sm:flex-row sm:justify-between", children: [d.jsx("p", { className: "text-sm  ", children: "   © Copyright 2021. All Rights Reserved." }), d.jsxs("div", { className: "flex -mx-2", children: [d.jsx("a", { href: "#", className: "mx-2 text-gray-600 transition-colors duration-300 hover:text-blue-500 ", "aria-label": "Reddit", children: d.jsx("svg", { className: "w-5 h-5 fill-current", viewBox: "0 0 24 24", fill: "none", xmlns: "http://www.w3.org/2000/svg", children: d.jsx("path", { d: "M12 22C6.47715 22 2 17.5228 2 12C2 6.47715 6.47715 2 12 2C17.5228 2 22 6.47715 22 12C21.9939 17.5203 17.5203 21.9939 12 22ZM6.807 10.543C6.20862 10.5433 5.67102 10.9088 5.45054 11.465C5.23006 12.0213 5.37133 12.6558 5.807 13.066C5.92217 13.1751 6.05463 13.2643 6.199 13.33C6.18644 13.4761 6.18644 13.6229 6.199 13.769C6.199 16.009 8.814 17.831 12.028 17.831C15.242 17.831 17.858 16.009 17.858 13.769C17.8696 13.6229 17.8696 13.4761 17.858 13.33C18.4649 13.0351 18.786 12.3585 18.6305 11.7019C18.475 11.0453 17.8847 10.5844 17.21 10.593H17.157C16.7988 10.6062 16.458 10.7512 16.2 11C15.0625 10.2265 13.7252 9.79927 12.35 9.77L13 6.65L15.138 7.1C15.1931 7.60706 15.621 7.99141 16.131 7.992C16.1674 7.99196 16.2038 7.98995 16.24 7.986C16.7702 7.93278 17.1655 7.47314 17.1389 6.94094C17.1122 6.40873 16.6729 5.991 16.14 5.991C16.1022 5.99191 16.0645 5.99491 16.027 6C15.71 6.03367 15.4281 6.21641 15.268 6.492L12.82 6C12.7983 5.99535 12.7762 5.993 12.754 5.993C12.6094 5.99472 12.4851 6.09583 12.454 6.237L11.706 9.71C10.3138 9.7297 8.95795 10.157 7.806 10.939C7.53601 10.6839 7.17843 10.5422 6.807 10.543ZM12.18 16.524C12.124 16.524 12.067 16.524 12.011 16.524C11.955 16.524 11.898 16.524 11.842 16.524C11.0121 16.5208 10.2054 16.2497 9.542 15.751C9.49626 15.6958 9.47445 15.6246 9.4814 15.5533C9.48834 15.482 9.52348 15.4163 9.579 15.371C9.62737 15.3318 9.68771 15.3102 9.75 15.31C9.81233 15.31 9.87275 15.3315 9.921 15.371C10.4816 15.7818 11.159 16.0022 11.854 16C11.9027 16 11.9513 16 12 16C12.059 16 12.119 16 12.178 16C12.864 16.0011 13.5329 15.7863 14.09 15.386C14.1427 15.3322 14.2147 15.302 14.29 15.302C14.3653 15.302 14.4373 15.3322 14.49 15.386C14.5985 15.4981 14.5962 15.6767 14.485 15.786V15.746C13.8213 16.2481 13.0123 16.5208 12.18 16.523V16.524ZM14.307 14.08H14.291L14.299 14.041C13.8591 14.011 13.4994 13.6789 13.4343 13.2429C13.3691 12.8068 13.6162 12.3842 14.028 12.2269C14.4399 12.0697 14.9058 12.2202 15.1478 12.5887C15.3899 12.9572 15.3429 13.4445 15.035 13.76C14.856 13.9554 14.6059 14.0707 14.341 14.08H14.306H14.307ZM9.67 14C9.11772 14 8.67 13.5523 8.67 13C8.67 12.4477 9.11772 12 9.67 12C10.2223 12 10.67 12.4477 10.67 13C10.67 13.5523 10.2223 14 9.67 14Z" }) }) }), d.jsx("a", { href: "#", className: "mx-2 text-gray-600 transition-colors duration-300 hover:text-blue-500 ", "aria-label": "Facebook", children: d.jsx("svg", { className: "w-5 h-5 fill-current", viewBox: "0 0 24 24", fill: "none", xmlns: "http://www.w3.org/2000/svg", children: d.jsx("path", { d: "M2.00195 12.002C2.00312 16.9214 5.58036 21.1101 10.439 21.881V14.892H7.90195V12.002H10.442V9.80204C10.3284 8.75958 10.6845 7.72064 11.4136 6.96698C12.1427 6.21332 13.1693 5.82306 14.215 5.90204C14.9655 5.91417 15.7141 5.98101 16.455 6.10205V8.56104H15.191C14.7558 8.50405 14.3183 8.64777 14.0017 8.95171C13.6851 9.25566 13.5237 9.68693 13.563 10.124V12.002H16.334L15.891 14.893H13.563V21.881C18.8174 21.0506 22.502 16.2518 21.9475 10.9611C21.3929 5.67041 16.7932 1.73997 11.4808 2.01722C6.16831 2.29447 2.0028 6.68235 2.00195 12.002Z" }) }) }), d.jsx("a", { href: "#", className: "mx-2  transition-colors duration-300 hover:text-blue-500 ", "aria-label": "Github", children: d.jsx("svg", { className: "w-5 h-5 fill-current", viewBox: "0 0 24 24", fill: "none", xmlns: "http://www.w3.org/2000/svg", children: d.jsx("path", { d: "M12.026 2C7.13295 1.99937 2.96183 5.54799 2.17842 10.3779C1.395 15.2079 4.23061 19.893 8.87302 21.439C9.37302 21.529 9.55202 21.222 9.55202 20.958C9.55202 20.721 9.54402 20.093 9.54102 19.258C6.76602 19.858 6.18002 17.92 6.18002 17.92C5.99733 17.317 5.60459 16.7993 5.07302 16.461C4.17302 15.842 5.14202 15.856 5.14202 15.856C5.78269 15.9438 6.34657 16.3235 6.66902 16.884C6.94195 17.3803 7.40177 17.747 7.94632 17.9026C8.49087 18.0583 9.07503 17.99 9.56902 17.713C9.61544 17.207 9.84055 16.7341 10.204 16.379C7.99002 16.128 5.66202 15.272 5.66202 11.449C5.64973 10.4602 6.01691 9.5043 6.68802 8.778C6.38437 7.91731 6.42013 6.97325 6.78802 6.138C6.78802 6.138 7.62502 5.869 9.53002 7.159C11.1639 6.71101 12.8882 6.71101 14.522 7.159C16.428 5.868 17.264 6.138 17.264 6.138C17.6336 6.97286 17.6694 7.91757 17.364 8.778C18.0376 9.50423 18.4045 10.4626 18.388 11.453C18.388 15.286 16.058 16.128 13.836 16.375C14.3153 16.8651 14.5612 17.5373 14.511 18.221C14.511 19.555 14.499 20.631 14.499 20.958C14.499 21.225 14.677 21.535 15.186 21.437C19.8265 19.8884 22.6591 15.203 21.874 10.3743C21.089 5.54565 16.9181 1.99888 12.026 2Z" }) }) })] })] })] })] }), G_ = () => d.jsx("div", { children: d.jsxs("div", { className: "container mx-auto bg-white", children: [d.jsx(V_, {}), d.jsx(hy, {}), d.jsx(W_, {})] }) }), K_ = "/assets/login-DSFchm1x.jpg"; let q_ = { data: "" }, Y_ = t => typeof window == "object" ? ((t ? t.querySelector("#_goober") : window._goober) || Object.assign((t || document.head).appendChild(document.createElement("style")), { innerHTML: " ", id: "_goober" })).firstChild : t || q_, J_ = /(?:([\u0080-\uFFFF\w-%@]+) *:? *([^{;]+?);|([^;}{]*?) *{)|(}\s*)/g, X_ = /\/\*[^]*?\*\/|  +/g, um = /\n+/g, Vn = (t, e) => { let n = "", r = "", i = ""; for (let s in t) { let o = t[s]; s[0] == "@" ? s[1] == "i" ? n = s + " " + o + ";" : r += s[1] == "f" ? Vn(o, s) : s + "{" + Vn(o, s[1] == "k" ? "" : e) + "}" : typeof o == "object" ? r += Vn(o, e ? e.replace(/([^,])+/g, l => s.replace(/([^,]*:\S+\([^)]*\))|([^,])+/g, a => /&/.test(a) ? a.replace(/&/g, l) : l ? l + " " + a : a)) : s) : o != null && (s = /^--/.test(s) ? s : s.replace(/[A-Z]/g, "-$&").toLowerCase(), i += Vn.p ? Vn.p(s, o) : s + ":" + o + ";") } return n + (e && i ? e + "{" + i + "}" : i) + r }, rn = {}, u0 = t => { if (typeof t == "object") { let e = ""; for (let n in t) e += n + u0(t[n]); return e } return t }, Q_ = (t, e, n, r, i) => { let s = u0(t), o = rn[s] || (rn[s] = (a => { let c = 0, u = 11; for (; c < a.length;)u = 101 * u + a.charCodeAt(c++) >>> 0; return "go" + u })(s)); if (!rn[o]) { let a = s !== t ? t : (c => { let u, f, h = [{}]; for (; u = J_.exec(c.replace(X_, ""));)u[4] ? h.shift() : u[3] ? (f = u[3].replace(um, " ").trim(), h.unshift(h[0][f] = h[0][f] || {})) : h[0][u[1]] = u[2].replace(um, " ").trim(); return h[0] })(t); rn[o] = Vn(i ? { ["@keyframes " + o]: a } : a, n ? "" : "." + o) } let l = n && rn.g ? rn.g : null; return n && (rn.g = rn[o]), ((a, c, u, f) => { f ? c.data = c.data.replace(f, a) : c.data.indexOf(a) === -1 && (c.data = u ? a + c.data : c.data + a) })(rn[o], e, r, l), o }, Z_ = (t, e, n) => t.reduce((r, i, s) => { let o = e[s]; if (o && o.call) { let l = o(n), a = l && l.props && l.props.className || /^go/.test(l) && l; o = a ? "." + a : l && typeof l == "object" ? l.props ? "" : Vn(l, "") : l === !1 ? "" : l } return r + i + (o ?? "") }, ""); function zl(t) { let e = this || {}, n = t.call ? t(e.p) : t; return Q_(n.unshift ? n.raw ? Z_(n, [].slice.call(arguments, 1), e.p) : n.reduce((r, i) => Object.assign(r, i && i.call ? i(e.p) : i), {}) : n, Y_(e.target), e.g, e.o, e.k) } let d0, nd, rd; zl.bind({ g: 1 }); let Cn = zl.bind({ k: 1 }); function e2(t, e, n, r) { Vn.p = e, d0 = t, nd = n, rd = r } function mr(t, e) { let n = this || {}; return function () { let r = arguments; function i(s, o) { let l = Object.assign({}, s), a = l.className || i.className; n.p = Object.assign({ theme: nd && nd() }, l), n.o = / *go\d+/.test(a), l.className = zl.apply(n, r) + (a ? " " + a : ""); let c = t; return t[0] && (c = l.as || t, delete l.as), rd && c[0] && rd(l), d0(c, l) } return i } } var t2 = t => typeof t == "function", ol = (t, e) => t2(t) ? t(e) : t, n2 = (() => { let t = 0; return () => (++t).toString() })(), f0 = (() => { let t; return () => { if (t === void 0 && typeof window < "u") { let e = matchMedia("(prefers-reduced-motion: reduce)"); t = !e || e.matches } return t } })(), r2 = 20, ma = new Map, i2 = 1e3, dm = t => { if (ma.has(t)) return; let e = setTimeout(() => { ma.delete(t), Yr({ type: 4, toastId: t }) }, i2); ma.set(t, e) }, s2 = t => { let e = ma.get(t); e && clearTimeout(e) }, id = (t, e) => { switch (e.type) { case 0: return { ...t, toasts: [e.toast, ...t.toasts].slice(0, r2) }; case 1: return e.toast.id && s2(e.toast.id), { ...t, toasts: t.toasts.map(s => s.id === e.toast.id ? { ...s, ...e.toast } : s) }; case 2: let { toast: n } = e; return t.toasts.find(s => s.id === n.id) ? id(t, { type: 1, toast: n }) : id(t, { type: 0, toast: n }); case 3: let { toastId: r } = e; return r ? dm(r) : t.toasts.forEach(s => { dm(s.id) }), { ...t, toasts: t.toasts.map(s => s.id === r || r === void 0 ? { ...s, visible: !1 } : s) }; case 4: return e.toastId === void 0 ? { ...t, toasts: [] } : { ...t, toasts: t.toasts.filter(s => s.id !== e.toastId) }; case 5: return { ...t, pausedAt: e.time }; case 6: let i = e.time - (t.pausedAt || 0); return { ...t, pausedAt: void 0, toasts: t.toasts.map(s => ({ ...s, pauseDuration: s.pauseDuration + i })) } } }, ga = [], va = { toasts: [], pausedAt: void 0 }, Yr = t => { va = id(va, t), ga.forEach(e => { e(va) }) }, o2 = { blank: 4e3, error: 4e3, success: 2e3, loading: 1 / 0, custom: 4e3 }, a2 = (t = {}) => { let [e, n] = b.useState(va); b.useEffect(() => (ga.push(n), () => { let i = ga.indexOf(n); i > -1 && ga.splice(i, 1) }), [e]); let r = e.toasts.map(i => { var s, o; return { ...t, ...t[i.type], ...i, duration: i.duration || ((s = t[i.type]) == null ? void 0 : s.duration) || (t == null ? void 0 : t.duration) || o2[i.type], style: { ...t.style, ...(o = t[i.type]) == null ? void 0 : o.style, ...i.style } } }); return { ...e, toasts: r } }, l2 = (t, e = "blank", n) => ({ createdAt: Date.now(), visible: !0, type: e, ariaProps: { role: "status", "aria-live": "polite" }, message: t, pauseDuration: 0, ...n, id: (n == null ? void 0 : n.id) || n2() }), wo = t => (e, n) => { let r = l2(e, t, n); return Yr({ type: 2, toast: r }), r.id }, ze = (t, e) => wo("blank")(t, e); ze.error = wo("error"); ze.success = wo("success"); ze.loading = wo("loading"); ze.custom = wo("custom"); ze.dismiss = t => { Yr({ type: 3, toastId: t }) }; ze.remove = t => Yr({ type: 4, toastId: t }); ze.promise = (t, e, n) => { let r = ze.loading(e.loading, { ...n, ...n == null ? void 0 : n.loading }); return t.then(i => (ze.success(ol(e.success, i), { id: r, ...n, ...n == null ? void 0 : n.success }), i)).catch(i => { ze.error(ol(e.error, i), { id: r, ...n, ...n == null ? void 0 : n.error }) }), t }; var c2 = (t, e) => { Yr({ type: 1, toast: { id: t, height: e } }) }, u2 = () => { Yr({ type: 5, time: Date.now() }) }, d2 = t => { let { toasts: e, pausedAt: n } = a2(t); b.useEffect(() => { if (n) return; let s = Date.now(), o = e.map(l => { if (l.duration === 1 / 0) return; let a = (l.duration || 0) + l.pauseDuration - (s - l.createdAt); if (a < 0) { l.visible && ze.dismiss(l.id); return } return setTimeout(() => ze.dismiss(l.id), a) }); return () => { o.forEach(l => l && clearTimeout(l)) } }, [e, n]); let r = b.useCallback(() => { n && Yr({ type: 6, time: Date.now() }) }, [n]), i = b.useCallback((s, o) => { let { reverseOrder: l = !1, gutter: a = 8, defaultPosition: c } = o || {}, u = e.filter(y => (y.position || c) === (s.position || c) && y.height), f = u.findIndex(y => y.id === s.id), h = u.filter((y, g) => g < f && y.visible).length; return u.filter(y => y.visible).slice(...l ? [h + 1] : [0, h]).reduce((y, g) => y + (g.height || 0) + a, 0) }, [e]); return { toasts: e, handlers: { updateHeight: c2, startPause: u2, endPause: r, calculateOffset: i } } }, f2 = Cn`
from {
  transform: scale(0) rotate(45deg);
	opacity: 0;
}
to {
 transform: scale(1) rotate(45deg);
  opacity: 1;
}`, p2 = Cn`
from {
  transform: scale(0);
  opacity: 0;
}
to {
  transform: scale(1);
  opacity: 1;
}`, h2 = Cn`
from {
  transform: scale(0) rotate(90deg);
	opacity: 0;
}
to {
  transform: scale(1) rotate(90deg);
	opacity: 1;
}`, m2 = mr("div")`
  width: 20px;
  opacity: 0;
  height: 20px;
  border-radius: 10px;
  background: ${t => t.primary || "#ff4b4b"};
  position: relative;
  transform: rotate(45deg);

  animation: ${f2} 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275)
    forwards;
  animation-delay: 100ms;

  &:after,
  &:before {
    content: '';
    animation: ${p2} 0.15s ease-out forwards;
    animation-delay: 150ms;
    position: absolute;
    border-radius: 3px;
    opacity: 0;
    background: ${t => t.secondary || "#fff"};
    bottom: 9px;
    left: 4px;
    height: 2px;
    width: 12px;
  }

  &:before {
    animation: ${h2} 0.15s ease-out forwards;
    animation-delay: 180ms;
    transform: rotate(90deg);
  }
`, g2 = Cn`
  from {
    transform: rotate(0deg);
  }
  to {
    transform: rotate(360deg);
  }
`, v2 = mr("div")`
  width: 12px;
  height: 12px;
  box-sizing: border-box;
  border: 2px solid;
  border-radius: 100%;
  border-color: ${t => t.secondary || "#e0e0e0"};
  border-right-color: ${t => t.primary || "#616161"};
  animation: ${g2} 1s linear infinite;
`, y2 = Cn`
from {
  transform: scale(0) rotate(45deg);
	opacity: 0;
}
to {
  transform: scale(1) rotate(45deg);
	opacity: 1;
}`, w2 = Cn`
0% {
	height: 0;
	width: 0;
	opacity: 0;
}
40% {
  height: 0;
	width: 6px;
	opacity: 1;
}
100% {
  opacity: 1;
  height: 10px;
}`, x2 = mr("div")`
  width: 20px;
  opacity: 0;
  height: 20px;
  border-radius: 10px;
  background: ${t => t.primary || "#61d345"};
  position: relative;
  transform: rotate(45deg);

  animation: ${y2} 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275)
    forwards;
  animation-delay: 100ms;
  &:after {
    content: '';
    box-sizing: border-box;
    animation: ${w2} 0.2s ease-out forwards;
    opacity: 0;
    animation-delay: 200ms;
    position: absolute;
    border-right: 2px solid;
    border-bottom: 2px solid;
    border-color: ${t => t.secondary || "#fff"};
    bottom: 6px;
    left: 6px;
    height: 10px;
    width: 6px;
  }
`, S2 = mr("div")`
  position: absolute;
`, E2 = mr("div")`
  position: relative;
  display: flex;
  justify-content: center;
  align-items: center;
  min-width: 20px;
  min-height: 20px;
`, b2 = Cn`
from {
  transform: scale(0.6);
  opacity: 0.4;
}
to {
  transform: scale(1);
  opacity: 1;
}`, T2 = mr("div")`
  position: relative;
  transform: scale(0.6);
  opacity: 0.4;
  min-width: 20px;
  animation: ${b2} 0.3s 0.12s cubic-bezier(0.175, 0.885, 0.32, 1.275)
    forwards;
`, C2 = ({ toast: t }) => { let { icon: e, type: n, iconTheme: r } = t; return e !== void 0 ? typeof e == "string" ? b.createElement(T2, null, e) : e : n === "blank" ? null : b.createElement(E2, null, b.createElement(v2, { ...r }), n !== "loading" && b.createElement(S2, null, n === "error" ? b.createElement(m2, { ...r }) : b.createElement(x2, { ...r }))) }, _2 = t => `
0% {transform: translate3d(0,${t * -200}%,0) scale(.6); opacity:.5;}
100% {transform: translate3d(0,0,0) scale(1); opacity:1;}
`, P2 = t => `
0% {transform: translate3d(0,0,-1px) scale(1); opacity:1;}
100% {transform: translate3d(0,${t * -150}%,-1px) scale(.6); opacity:0;}
`, I2 = "0%{opacity:0;} 100%{opacity:1;}", k2 = "0%{opacity:1;} 100%{opacity:0;}", N2 = mr("div")`
  display: flex;
  align-items: center;
  background: #fff;
  color: #363636;
  line-height: 1.3;
  will-change: transform;
  box-shadow: 0 3px 10px rgba(0, 0, 0, 0.1), 0 3px 3px rgba(0, 0, 0, 0.05);
  max-width: 350px;
  pointer-events: auto;
  padding: 8px 10px;
  border-radius: 8px;
`, R2 = mr("div")`
  display: flex;
  justify-content: center;
  margin: 4px 10px;
  color: inherit;
  flex: 1 1 auto;
  white-space: pre-line;
`, O2 = (t, e) => { let n = t.includes("top") ? 1 : -1, [r, i] = f0() ? [I2, k2] : [_2(n), P2(n)]; return { animation: e ? `${Cn(r)} 0.35s cubic-bezier(.21,1.02,.73,1) forwards` : `${Cn(i)} 0.4s forwards cubic-bezier(.06,.71,.55,1)` } }, j2 = b.memo(({ toast: t, position: e, style: n, children: r }) => { let i = t.height ? O2(t.position || e || "top-center", t.visible) : { opacity: 0 }, s = b.createElement(C2, { toast: t }), o = b.createElement(R2, { ...t.ariaProps }, ol(t.message, t)); return b.createElement(N2, { className: t.className, style: { ...i, ...n, ...t.style } }, typeof r == "function" ? r({ icon: s, message: o }) : b.createElement(b.Fragment, null, s, o)) }); e2(b.createElement); var A2 = ({ id: t, className: e, style: n, onHeightUpdate: r, children: i }) => { let s = b.useCallback(o => { if (o) { let l = () => { let a = o.getBoundingClientRect().height; r(t, a) }; l(), new MutationObserver(l).observe(o, { subtree: !0, childList: !0, characterData: !0 }) } }, [t, r]); return b.createElement("div", { ref: s, className: e, style: n }, i) }, L2 = (t, e) => { let n = t.includes("top"), r = n ? { top: 0 } : { bottom: 0 }, i = t.includes("center") ? { justifyContent: "center" } : t.includes("right") ? { justifyContent: "flex-end" } : {}; return { left: 0, right: 0, display: "flex", position: "absolute", transition: f0() ? void 0 : "all 230ms cubic-bezier(.21,1.02,.73,1)", transform: `translateY(${e * (n ? 1 : -1)}px)`, ...r, ...i } }, D2 = zl`
  z-index: 9999;
  > * {
    pointer-events: auto;
  }
`, Ko = 16, M2 = ({ reverseOrder: t, position: e = "top-center", toastOptions: n, gutter: r, children: i, containerStyle: s, containerClassName: o }) => { let { toasts: l, handlers: a } = d2(n); return b.createElement("div", { style: { position: "fixed", zIndex: 9999, top: Ko, left: Ko, right: Ko, bottom: Ko, pointerEvents: "none", ...s }, className: o, onMouseEnter: a.startPause, onMouseLeave: a.endPause }, l.map(c => { let u = c.position || e, f = a.calculateOffset(c, { reverseOrder: t, gutter: r, defaultPosition: e }), h = L2(u, f); return b.createElement(A2, { id: c.id, key: c.id, onHeightUpdate: a.updateHeight, className: c.visible ? D2 : "", style: h }, c.type === "custom" ? ol(c.message, c) : i ? i(c) : b.createElement(j2, { toast: c, position: u })) })) }, Br = ze; const F2 = () => { const t = qr(), { signIn: e, signInWithGoogle: n } = b.useContext(Ke), r = async () => { try { await n(), ze.success("Signin Successful"), t("/") } catch (s) { console.log(s), ze.error(s == null ? void 0 : s.message) } }, i = async s => { s.preventDefault(); const o = s.target, l = o.email.value, a = o.password.value; console.log({ email: l, pass: a }); try { const c = await e(l, a); console.log(c), t("/"), ze.success("Signin Successful") } catch (c) { console.log(c), ze.error("No Account Found Please Sign Up") } }; return d.jsx("div", { className: "flex justify-center items-center min-h-[calc(100vh-306px)] my-12", children: d.jsxs("div", { className: "flex w-full max-w-sm mx-auto overflow-hidden bg-white rounded-lg shadow-lg  lg:max-w-4xl ", children: [d.jsx("div", { className: "hidden bg-cover bg-center lg:block lg:w-1/2", style: { backgroundImage: `url(${K_})` } }), d.jsxs("div", { className: "w-full px-6 py-8 md:px-8 lg:w-1/2", children: [d.jsx("div", { className: "flex justify-center mx-auto", children: d.jsx("img", { className: "w-auto h-7 sm:h-8", src: Dl, alt: "" }) }), d.jsx("p", { className: "mt-3 text-xl text-center text-gray-600 ", children: "Welcome back!" }), d.jsxs("div", { onClick: r, className: "flex cursor-pointer items-center justify-center mt-4 text-gray-600 transition-colors duration-300 transform border rounded-lg   hover:bg-gray-50 ", children: [d.jsx("div", { className: "px-4 py-2", children: d.jsxs("svg", { className: "w-6 h-6", viewBox: "0 0 40 40", children: [d.jsx("path", { d: "M36.3425 16.7358H35V16.6667H20V23.3333H29.4192C28.045 27.2142 24.3525 30 20 30C14.4775 30 10 25.5225 10 20C10 14.4775 14.4775 9.99999 20 9.99999C22.5492 9.99999 24.8683 10.9617 26.6342 12.5325L31.3483 7.81833C28.3717 5.04416 24.39 3.33333 20 3.33333C10.7958 3.33333 3.33335 10.7958 3.33335 20C3.33335 29.2042 10.7958 36.6667 20 36.6667C29.2042 36.6667 36.6667 29.2042 36.6667 20C36.6667 18.8825 36.5517 17.7917 36.3425 16.7358Z", fill: "#FFC107" }), d.jsx("path", { d: "M5.25497 12.2425L10.7308 16.2583C12.2125 12.59 15.8008 9.99999 20 9.99999C22.5491 9.99999 24.8683 10.9617 26.6341 12.5325L31.3483 7.81833C28.3716 5.04416 24.39 3.33333 20 3.33333C13.5983 3.33333 8.04663 6.94749 5.25497 12.2425Z", fill: "#FF3D00" }), d.jsx("path", { d: "M20 36.6667C24.305 36.6667 28.2167 35.0192 31.1742 32.34L26.0159 27.975C24.3425 29.2425 22.2625 30 20 30C15.665 30 11.9842 27.2359 10.5975 23.3784L5.16254 27.5659C7.92087 32.9634 13.5225 36.6667 20 36.6667Z", fill: "#4CAF50" }), d.jsx("path", { d: "M36.3425 16.7358H35V16.6667H20V23.3333H29.4192C28.7592 25.1975 27.56 26.805 26.0133 27.9758C26.0142 27.975 26.015 27.975 26.0158 27.9742L31.1742 32.3392C30.8092 32.6708 36.6667 28.3333 36.6667 20C36.6667 18.8825 36.5517 17.7917 36.3425 16.7358Z", fill: "#1976D2" })] }) }), d.jsx("span", { className: "w-5/6 px-4 py-3 font-bold text-center", children: "Sign in with Google" })] }), d.jsxs("div", { className: "flex items-center justify-between mt-4", children: [d.jsx("span", { className: "w-1/5 border-b  lg:w-1/4" }), d.jsx("div", { className: "text-xs text-center text-gray-500 uppercase  hover:underline", children: "or login with email" }), d.jsx("span", { className: "w-1/5 border-b dark:border-gray-400 lg:w-1/4" })] }), d.jsxs("form", { onSubmit: i, children: [d.jsxs("div", { className: "mt-4", children: [d.jsx("label", { className: "block mb-2 text-sm font-medium text-gray-600 ", htmlFor: "LoggingEmailAddress", children: "Email Address" }), d.jsx("input", { id: "LoggingEmailAddress", autoComplete: "email", name: "email", className: "block w-full px-4 py-2 text-gray-700 bg-white border rounded-lg    focus:border-blue-400 focus:ring-opacity-40  focus:outline-none focus:ring focus:ring-blue-300", type: "email" })] }), d.jsxs("div", { className: "mt-4", children: [d.jsx("div", { className: "flex justify-between", children: d.jsx("label", { className: "block mb-2 text-sm font-medium text-gray-600 ", htmlFor: "loggingPassword", children: "Password" }) }), d.jsx("input", { id: "loggingPassword", autoComplete: "current-password", name: "password", className: "block w-full px-4 py-2 text-gray-700 bg-white border rounded-lg    focus:border-blue-400 focus:ring-opacity-40  focus:outline-none focus:ring focus:ring-blue-300", type: "password" })] }), d.jsx("div", { className: "mt-6", children: d.jsx("button", { type: "submit", className: "w-full px-6 py-3 text-sm font-medium tracking-wide text-white capitalize transition-colors duration-300 transform bg-gray-800 rounded-lg hover:bg-gray-700 focus:outline-none focus:ring focus:ring-gray-300 focus:ring-opacity-50", children: "Sign In" }) })] }), d.jsxs("div", { className: "flex items-center justify-between mt-4", children: [d.jsx("span", { className: "w-1/5 border-b  md:w-1/4" }), d.jsx(dr, { to: "/register", className: "text-xs text-gray-500 uppercase  hover:underline", children: "or sign up" }), d.jsx("span", { className: "w-1/5 border-b  md:w-1/4" })] })] })] }) }) }; function fm(t) { return t !== null && typeof t == "object" && "constructor" in t && t.constructor === Object } function Ff(t, e) { t === void 0 && (t = {}), e === void 0 && (e = {}), Object.keys(e).forEach(n => { typeof t[n] > "u" ? t[n] = e[n] : fm(e[n]) && fm(t[n]) && Object.keys(e[n]).length > 0 && Ff(t[n], e[n]) }) } const p0 = { body: {}, addEventListener() { }, removeEventListener() { }, activeElement: { blur() { }, nodeName: "" }, querySelector() { return null }, querySelectorAll() { return [] }, getElementById() { return null }, createEvent() { return { initEvent() { } } }, createElement() { return { children: [], childNodes: [], style: {}, setAttribute() { }, getElementsByTagName() { return [] } } }, createElementNS() { return {} }, importNode() { return null }, location: { hash: "", host: "", hostname: "", href: "", origin: "", pathname: "", protocol: "", search: "" } }; function vn() { const t = typeof document < "u" ? document : {}; return Ff(t, p0), t } const U2 = { document: p0, navigator: { userAgent: "" }, location: { hash: "", host: "", hostname: "", href: "", origin: "", pathname: "", protocol: "", search: "" }, history: { replaceState() { }, pushState() { }, go() { }, back() { } }, CustomEvent: function () { return this }, addEventListener() { }, removeEventListener() { }, getComputedStyle() { return { getPropertyValue() { return "" } } }, Image() { }, Date() { }, screen: {}, setTimeout() { }, clearTimeout() { }, matchMedia() { return {} }, requestAnimationFrame(t) { return typeof setTimeout > "u" ? (t(), null) : setTimeout(t, 0) }, cancelAnimationFrame(t) { typeof setTimeout > "u" || clearTimeout(t) } }; function wt() { const t = typeof window < "u" ? window : {}; return Ff(t, U2), t } function z2(t) { return t === void 0 && (t = ""), t.trim().split(" ").filter(e => !!e.trim()) } function $2(t) { const e = t; Object.keys(e).forEach(n => { try { e[n] = null } catch { } try { delete e[n] } catch { } }) } function sd(t, e) { return e === void 0 && (e = 0), setTimeout(t, e) } function al() { return Date.now() } function B2(t) { const e = wt(); let n; return e.getComputedStyle && (n = e.getComputedStyle(t, null)), !n && t.currentStyle && (n = t.currentStyle), n || (n = t.style), n } function H2(t, e) { e === void 0 && (e = "x"); const n = wt(); let r, i, s; const o = B2(t); return n.WebKitCSSMatrix ? (i = o.transform || o.webkitTransform, i.split(",").length > 6 && (i = i.split(", ").map(l => l.replace(",", ".")).join(", ")), s = new n.WebKitCSSMatrix(i === "none" ? "" : i)) : (s = o.MozTransform || o.OTransform || o.MsTransform || o.msTransform || o.transform || o.getPropertyValue("transform").replace("translate(", "matrix(1, 0, 0, 1,"), r = s.toString().split(",")), e === "x" && (n.WebKitCSSMatrix ? i = s.m41 : r.length === 16 ? i = parseFloat(r[12]) : i = parseFloat(r[4])), e === "y" && (n.WebKitCSSMatrix ? i = s.m42 : r.length === 16 ? i = parseFloat(r[13]) : i = parseFloat(r[5])), i || 0 } function qo(t) { return typeof t == "object" && t !== null && t.constructor && Object.prototype.toString.call(t).slice(8, -1) === "Object" } function V2(t) { return typeof window < "u" && typeof window.HTMLElement < "u" ? t instanceof HTMLElement : t && (t.nodeType === 1 || t.nodeType === 11) } function ft() { const t = Object(arguments.length <= 0 ? void 0 : arguments[0]), e = ["__proto__", "constructor", "prototype"]; for (let n = 1; n < arguments.length; n += 1) { const r = n < 0 || arguments.length <= n ? void 0 : arguments[n]; if (r != null && !V2(r)) { const i = Object.keys(Object(r)).filter(s => e.indexOf(s) < 0); for (let s = 0, o = i.length; s < o; s += 1) { const l = i[s], a = Object.getOwnPropertyDescriptor(r, l); a !== void 0 && a.enumerable && (qo(t[l]) && qo(r[l]) ? r[l].__swiper__ ? t[l] = r[l] : ft(t[l], r[l]) : !qo(t[l]) && qo(r[l]) ? (t[l] = {}, r[l].__swiper__ ? t[l] = r[l] : ft(t[l], r[l])) : t[l] = r[l]) } } } return t } function Yo(t, e, n) { t.style.setProperty(e, n) } function h0(t) { let { swiper: e, targetPosition: n, side: r } = t; const i = wt(), s = -e.translate; let o = null, l; const a = e.params.speed; e.wrapperEl.style.scrollSnapType = "none", i.cancelAnimationFrame(e.cssModeFrameID); const c = n > s ? "next" : "prev", u = (h, y) => c === "next" && h >= y || c === "prev" && h <= y, f = () => { l = new Date().getTime(), o === null && (o = l); const h = Math.max(Math.min((l - o) / a, 1), 0), y = .5 - Math.cos(h * Math.PI) / 2; let g = s + y * (n - s); if (u(g, n) && (g = n), e.wrapperEl.scrollTo({ [r]: g }), u(g, n)) { e.wrapperEl.style.overflow = "hidden", e.wrapperEl.style.scrollSnapType = "", setTimeout(() => { e.wrapperEl.style.overflow = "", e.wrapperEl.scrollTo({ [r]: g }) }), i.cancelAnimationFrame(e.cssModeFrameID); return } e.cssModeFrameID = i.requestAnimationFrame(f) }; f() } function qt(t, e) { e === void 0 && (e = ""); const n = [...t.children]; return t instanceof HTMLSlotElement && n.push(...t.assignedElements()), e ? n.filter(r => r.matches(e)) : n } function W2(t, e) { const n = e.contains(t); return !n && e instanceof HTMLSlotElement ? [...e.assignedElements()].includes(t) : n } function ll(t) { try { console.warn(t); return } catch { } } function cl(t, e) { e === void 0 && (e = []); const n = document.createElement(t); return n.classList.add(...Array.isArray(e) ? e : z2(e)), n } function G2(t, e) { const n = []; for (; t.previousElementSibling;) { const r = t.previousElementSibling; e ? r.matches(e) && n.push(r) : n.push(r), t = r } return n } function K2(t, e) { const n = []; for (; t.nextElementSibling;) { const r = t.nextElementSibling; e ? r.matches(e) && n.push(r) : n.push(r), t = r } return n } function qn(t, e) { return wt().getComputedStyle(t, null).getPropertyValue(e) } function ul(t) { let e = t, n; if (e) { for (n = 0; (e = e.previousSibling) !== null;)e.nodeType === 1 && (n += 1); return n } } function m0(t, e) { const n = []; let r = t.parentElement; for (; r;)e ? r.matches(e) && n.push(r) : n.push(r), r = r.parentElement; return n } function od(t, e, n) { const r = wt(); return t[e === "width" ? "offsetWidth" : "offsetHeight"] + parseFloat(r.getComputedStyle(t, null).getPropertyValue(e === "width" ? "margin-right" : "margin-top")) + parseFloat(r.getComputedStyle(t, null).getPropertyValue(e === "width" ? "margin-left" : "margin-bottom")) } function Ae(t) { return (Array.isArray(t) ? t : [t]).filter(e => !!e) } let Ac; function q2() { const t = wt(), e = vn(); return { smoothScroll: e.documentElement && e.documentElement.style && "scrollBehavior" in e.documentElement.style, touch: !!("ontouchstart" in t || t.DocumentTouch && e instanceof t.DocumentTouch) } } function g0() { return Ac || (Ac = q2()), Ac } let Lc; function Y2(t) { let { userAgent: e } = t === void 0 ? {} : t; const n = g0(), r = wt(), i = r.navigator.platform, s = e || r.navigator.userAgent, o = { ios: !1, android: !1 }, l = r.screen.width, a = r.screen.height, c = s.match(/(Android);?[\s\/]+([\d.]+)?/); let u = s.match(/(iPad).*OS\s([\d_]+)/); const f = s.match(/(iPod)(.*OS\s([\d_]+))?/), h = !u && s.match(/(iPhone\sOS|iOS)\s([\d_]+)/), y = i === "Win32"; let g = i === "MacIntel"; const w = ["1024x1366", "1366x1024", "834x1194", "1194x834", "834x1112", "1112x834", "768x1024", "1024x768", "820x1180", "1180x820", "810x1080", "1080x810"]; return !u && g && n.touch && w.indexOf(`${l}x${a}`) >= 0 && (u = s.match(/(Version)\/([\d.]+)/), u || (u = [0, 1, "13_0_0"]), g = !1), c && !y && (o.os = "android", o.android = !0), (u || h || f) && (o.os = "ios", o.ios = !0), o } function v0(t) { return t === void 0 && (t = {}), Lc || (Lc = Y2(t)), Lc } let Dc; function J2() { const t = wt(), e = v0(); let n = !1; function r() { const l = t.navigator.userAgent.toLowerCase(); return l.indexOf("safari") >= 0 && l.indexOf("chrome") < 0 && l.indexOf("android") < 0 } if (r()) { const l = String(t.navigator.userAgent); if (l.includes("Version/")) { const [a, c] = l.split("Version/")[1].split(" ")[0].split(".").map(u => Number(u)); n = a < 16 || a === 16 && c < 2 } } const i = /(iPhone|iPod|iPad).*AppleWebKit(?!.*Safari)/i.test(t.navigator.userAgent), s = r(), o = s || i && e.ios; return { isSafari: n || s, needPerspectiveFix: n, need3dFix: o, isWebView: i } } function X2() { return Dc || (Dc = J2()), Dc } function Q2(t) { let { swiper: e, on: n, emit: r } = t; const i = wt(); let s = null, o = null; const l = () => { !e || e.destroyed || !e.initialized || (r("beforeResize"), r("resize")) }, a = () => { !e || e.destroyed || !e.initialized || (s = new ResizeObserver(f => { o = i.requestAnimationFrame(() => { const { width: h, height: y } = e; let g = h, w = y; f.forEach(E => { let { contentBoxSize: v, contentRect: p, target: m } = E; m && m !== e.el || (g = p ? p.width : (v[0] || v).inlineSize, w = p ? p.height : (v[0] || v).blockSize) }), (g !== h || w !== y) && l() }) }), s.observe(e.el)) }, c = () => { o && i.cancelAnimationFrame(o), s && s.unobserve && e.el && (s.unobserve(e.el), s = null) }, u = () => { !e || e.destroyed || !e.initialized || r("orientationchange") }; n("init", () => { if (e.params.resizeObserver && typeof i.ResizeObserver < "u") { a(); return } i.addEventListener("resize", l), i.addEventListener("orientationchange", u) }), n("destroy", () => { c(), i.removeEventListener("resize", l), i.removeEventListener("orientationchange", u) }) } function Z2(t) { let { swiper: e, extendParams: n, on: r, emit: i } = t; const s = [], o = wt(), l = function (u, f) { f === void 0 && (f = {}); const h = o.MutationObserver || o.WebkitMutationObserver, y = new h(g => { if (e.__preventObserver__) return; if (g.length === 1) { i("observerUpdate", g[0]); return } const w = function () { i("observerUpdate", g[0]) }; o.requestAnimationFrame ? o.requestAnimationFrame(w) : o.setTimeout(w, 0) }); y.observe(u, { attributes: typeof f.attributes > "u" ? !0 : f.attributes, childList: e.isElement || (typeof f.childList > "u" ? !0 : f).childList, characterData: typeof f.characterData > "u" ? !0 : f.characterData }), s.push(y) }, a = () => { if (e.params.observer) { if (e.params.observeParents) { const u = m0(e.hostEl); for (let f = 0; f < u.length; f += 1)l(u[f]) } l(e.hostEl, { childList: e.params.observeSlideChildren }), l(e.wrapperEl, { attributes: !1 }) } }, c = () => { s.forEach(u => { u.disconnect() }), s.splice(0, s.length) }; n({ observer: !1, observeParents: !1, observeSlideChildren: !1 }), r("init", a), r("destroy", c) } var eP = { on(t, e, n) { const r = this; if (!r.eventsListeners || r.destroyed || typeof e != "function") return r; const i = n ? "unshift" : "push"; return t.split(" ").forEach(s => { r.eventsListeners[s] || (r.eventsListeners[s] = []), r.eventsListeners[s][i](e) }), r }, once(t, e, n) { const r = this; if (!r.eventsListeners || r.destroyed || typeof e != "function") return r; function i() { r.off(t, i), i.__emitterProxy && delete i.__emitterProxy; for (var s = arguments.length, o = new Array(s), l = 0; l < s; l++)o[l] = arguments[l]; e.apply(r, o) } return i.__emitterProxy = e, r.on(t, i, n) }, onAny(t, e) { const n = this; if (!n.eventsListeners || n.destroyed || typeof t != "function") return n; const r = e ? "unshift" : "push"; return n.eventsAnyListeners.indexOf(t) < 0 && n.eventsAnyListeners[r](t), n }, offAny(t) { const e = this; if (!e.eventsListeners || e.destroyed || !e.eventsAnyListeners) return e; const n = e.eventsAnyListeners.indexOf(t); return n >= 0 && e.eventsAnyListeners.splice(n, 1), e }, off(t, e) { const n = this; return !n.eventsListeners || n.destroyed || !n.eventsListeners || t.split(" ").forEach(r => { typeof e > "u" ? n.eventsListeners[r] = [] : n.eventsListeners[r] && n.eventsListeners[r].forEach((i, s) => { (i === e || i.__emitterProxy && i.__emitterProxy === e) && n.eventsListeners[r].splice(s, 1) }) }), n }, emit() { const t = this; if (!t.eventsListeners || t.destroyed || !t.eventsListeners) return t; let e, n, r; for (var i = arguments.length, s = new Array(i), o = 0; o < i; o++)s[o] = arguments[o]; return typeof s[0] == "string" || Array.isArray(s[0]) ? (e = s[0], n = s.slice(1, s.length), r = t) : (e = s[0].events, n = s[0].data, r = s[0].context || t), n.unshift(r), (Array.isArray(e) ? e : e.split(" ")).forEach(a => { t.eventsAnyListeners && t.eventsAnyListeners.length && t.eventsAnyListeners.forEach(c => { c.apply(r, [a, ...n]) }), t.eventsListeners && t.eventsListeners[a] && t.eventsListeners[a].forEach(c => { c.apply(r, n) }) }), t } }; function tP() { const t = this; let e, n; const r = t.el; typeof t.params.width < "u" && t.params.width !== null ? e = t.params.width : e = r.clientWidth, typeof t.params.height < "u" && t.params.height !== null ? n = t.params.height : n = r.clientHeight, !(e === 0 && t.isHorizontal() || n === 0 && t.isVertical()) && (e = e - parseInt(qn(r, "padding-left") || 0, 10) - parseInt(qn(r, "padding-right") || 0, 10), n = n - parseInt(qn(r, "padding-top") || 0, 10) - parseInt(qn(r, "padding-bottom") || 0, 10), Number.isNaN(e) && (e = 0), Number.isNaN(n) && (n = 0), Object.assign(t, { width: e, height: n, size: t.isHorizontal() ? e : n })) } function nP() { const t = this; function e(k, j) { return parseFloat(k.getPropertyValue(t.getDirectionLabel(j)) || 0) } const n = t.params, { wrapperEl: r, slidesEl: i, size: s, rtlTranslate: o, wrongRTL: l } = t, a = t.virtual && n.virtual.enabled, c = a ? t.virtual.slides.length : t.slides.length, u = qt(i, `.${t.params.slideClass}, swiper-slide`), f = a ? t.virtual.slides.length : u.length; let h = []; const y = [], g = []; let w = n.slidesOffsetBefore; typeof w == "function" && (w = n.slidesOffsetBefore.call(t)); let E = n.slidesOffsetAfter; typeof E == "function" && (E = n.slidesOffsetAfter.call(t)); const v = t.snapGrid.length, p = t.slidesGrid.length; let m = n.spaceBetween, S = -w, T = 0, x = 0; if (typeof s > "u") return; typeof m == "string" && m.indexOf("%") >= 0 ? m = parseFloat(m.replace("%", "")) / 100 * s : typeof m == "string" && (m = parseFloat(m)), t.virtualSize = -m, u.forEach(k => { o ? k.style.marginLeft = "" : k.style.marginRight = "", k.style.marginBottom = "", k.style.marginTop = "" }), n.centeredSlides && n.cssMode && (Yo(r, "--swiper-centered-offset-before", ""), Yo(r, "--swiper-centered-offset-after", "")); const P = n.grid && n.grid.rows > 1 && t.grid; P ? t.grid.initSlides(u) : t.grid && t.grid.unsetSlides(); let I; const N = n.slidesPerView === "auto" && n.breakpoints && Object.keys(n.breakpoints).filter(k => typeof n.breakpoints[k].slidesPerView < "u").length > 0; for (let k = 0; k < f; k += 1) { I = 0; let j; if (u[k] && (j = u[k]), P && t.grid.updateSlide(k, j, u), !(u[k] && qn(j, "display") === "none")) { if (n.slidesPerView === "auto") { N && (u[k].style[t.getDirectionLabel("width")] = ""); const F = getComputedStyle(j), D = j.style.transform, B = j.style.webkitTransform; if (D && (j.style.transform = "none"), B && (j.style.webkitTransform = "none"), n.roundLengths) I = t.isHorizontal() ? od(j, "width") : od(j, "height"); else { const J = e(F, "width"), de = e(F, "padding-left"), pe = e(F, "padding-right"), A = e(F, "margin-left"), U = e(F, "margin-right"), z = F.getPropertyValue("box-sizing"); if (z && z === "border-box") I = J + A + U; else { const { clientWidth: Z, offsetWidth: le } = j; I = J + de + pe + A + U + (le - Z) } } D && (j.style.transform = D), B && (j.style.webkitTransform = B), n.roundLengths && (I = Math.floor(I)) } else I = (s - (n.slidesPerView - 1) * m) / n.slidesPerView, n.roundLengths && (I = Math.floor(I)), u[k] && (u[k].style[t.getDirectionLabel("width")] = `${I}px`); u[k] && (u[k].swiperSlideSize = I), g.push(I), n.centeredSlides ? (S = S + I / 2 + T / 2 + m, T === 0 && k !== 0 && (S = S - s / 2 - m), k === 0 && (S = S - s / 2 - m), Math.abs(S) < 1 / 1e3 && (S = 0), n.roundLengths && (S = Math.floor(S)), x % n.slidesPerGroup === 0 && h.push(S), y.push(S)) : (n.roundLengths && (S = Math.floor(S)), (x - Math.min(t.params.slidesPerGroupSkip, x)) % t.params.slidesPerGroup === 0 && h.push(S), y.push(S), S = S + I + m), t.virtualSize += I + m, T = I, x += 1 } } if (t.virtualSize = Math.max(t.virtualSize, s) + E, o && l && (n.effect === "slide" || n.effect === "coverflow") && (r.style.width = `${t.virtualSize + m}px`), n.setWrapperSize && (r.style[t.getDirectionLabel("width")] = `${t.virtualSize + m}px`), P && t.grid.updateWrapperSize(I, h), !n.centeredSlides) { const k = []; for (let j = 0; j < h.length; j += 1) { let F = h[j]; n.roundLengths && (F = Math.floor(F)), h[j] <= t.virtualSize - s && k.push(F) } h = k, Math.floor(t.virtualSize - s) - Math.floor(h[h.length - 1]) > 1 && h.push(t.virtualSize - s) } if (a && n.loop) { const k = g[0] + m; if (n.slidesPerGroup > 1) { const j = Math.ceil((t.virtual.slidesBefore + t.virtual.slidesAfter) / n.slidesPerGroup), F = k * n.slidesPerGroup; for (let D = 0; D < j; D += 1)h.push(h[h.length - 1] + F) } for (let j = 0; j < t.virtual.slidesBefore + t.virtual.slidesAfter; j += 1)n.slidesPerGroup === 1 && h.push(h[h.length - 1] + k), y.push(y[y.length - 1] + k), t.virtualSize += k } if (h.length === 0 && (h = [0]), m !== 0) { const k = t.isHorizontal() && o ? "marginLeft" : t.getDirectionLabel("marginRight"); u.filter((j, F) => !n.cssMode || n.loop ? !0 : F !== u.length - 1).forEach(j => { j.style[k] = `${m}px` }) } if (n.centeredSlides && n.centeredSlidesBounds) { let k = 0; g.forEach(F => { k += F + (m || 0) }), k -= m; const j = k > s ? k - s : 0; h = h.map(F => F <= 0 ? -w : F > j ? j + E : F) } if (n.centerInsufficientSlides) { let k = 0; g.forEach(F => { k += F + (m || 0) }), k -= m; const j = (n.slidesOffsetBefore || 0) + (n.slidesOffsetAfter || 0); if (k + j < s) { const F = (s - k - j) / 2; h.forEach((D, B) => { h[B] = D - F }), y.forEach((D, B) => { y[B] = D + F }) } } if (Object.assign(t, { slides: u, snapGrid: h, slidesGrid: y, slidesSizesGrid: g }), n.centeredSlides && n.cssMode && !n.centeredSlidesBounds) { Yo(r, "--swiper-centered-offset-before", `${-h[0]}px`), Yo(r, "--swiper-centered-offset-after", `${t.size / 2 - g[g.length - 1] / 2}px`); const k = -t.snapGrid[0], j = -t.slidesGrid[0]; t.snapGrid = t.snapGrid.map(F => F + k), t.slidesGrid = t.slidesGrid.map(F => F + j) } if (f !== c && t.emit("slidesLengthChange"), h.length !== v && (t.params.watchOverflow && t.checkOverflow(), t.emit("snapGridLengthChange")), y.length !== p && t.emit("slidesGridLengthChange"), n.watchSlidesProgress && t.updateSlidesOffset(), t.emit("slidesUpdated"), !a && !n.cssMode && (n.effect === "slide" || n.effect === "fade")) { const k = `${n.containerModifierClass}backface-hidden`, j = t.el.classList.contains(k); f <= n.maxBackfaceHiddenSlides ? j || t.el.classList.add(k) : j && t.el.classList.remove(k) } } function rP(t) { const e = this, n = [], r = e.virtual && e.params.virtual.enabled; let i = 0, s; typeof t == "number" ? e.setTransition(t) : t === !0 && e.setTransition(e.params.speed); const o = l => r ? e.slides[e.getSlideIndexByData(l)] : e.slides[l]; if (e.params.slidesPerView !== "auto" && e.params.slidesPerView > 1) if (e.params.centeredSlides) (e.visibleSlides || []).forEach(l => { n.push(l) }); else for (s = 0; s < Math.ceil(e.params.slidesPerView); s += 1) { const l = e.activeIndex + s; if (l > e.slides.length && !r) break; n.push(o(l)) } else n.push(o(e.activeIndex)); for (s = 0; s < n.length; s += 1)if (typeof n[s] < "u") { const l = n[s].offsetHeight; i = l > i ? l : i } (i || i === 0) && (e.wrapperEl.style.height = `${i}px`) } function iP() { const t = this, e = t.slides, n = t.isElement ? t.isHorizontal() ? t.wrapperEl.offsetLeft : t.wrapperEl.offsetTop : 0; for (let r = 0; r < e.length; r += 1)e[r].swiperSlideOffset = (t.isHorizontal() ? e[r].offsetLeft : e[r].offsetTop) - n - t.cssOverflowAdjustment() } const pm = (t, e, n) => { e && !t.classList.contains(n) ? t.classList.add(n) : !e && t.classList.contains(n) && t.classList.remove(n) }; function sP(t) { t === void 0 && (t = this && this.translate || 0); const e = this, n = e.params, { slides: r, rtlTranslate: i, snapGrid: s } = e; if (r.length === 0) return; typeof r[0].swiperSlideOffset > "u" && e.updateSlidesOffset(); let o = -t; i && (o = t), e.visibleSlidesIndexes = [], e.visibleSlides = []; let l = n.spaceBetween; typeof l == "string" && l.indexOf("%") >= 0 ? l = parseFloat(l.replace("%", "")) / 100 * e.size : typeof l == "string" && (l = parseFloat(l)); for (let a = 0; a < r.length; a += 1) { const c = r[a]; let u = c.swiperSlideOffset; n.cssMode && n.centeredSlides && (u -= r[0].swiperSlideOffset); const f = (o + (n.centeredSlides ? e.minTranslate() : 0) - u) / (c.swiperSlideSize + l), h = (o - s[0] + (n.centeredSlides ? e.minTranslate() : 0) - u) / (c.swiperSlideSize + l), y = -(o - u), g = y + e.slidesSizesGrid[a], w = y >= 0 && y <= e.size - e.slidesSizesGrid[a], E = y >= 0 && y < e.size - 1 || g > 1 && g <= e.size || y <= 0 && g >= e.size; E && (e.visibleSlides.push(c), e.visibleSlidesIndexes.push(a)), pm(c, E, n.slideVisibleClass), pm(c, w, n.slideFullyVisibleClass), c.progress = i ? -f : f, c.originalProgress = i ? -h : h } } function oP(t) { const e = this; if (typeof t > "u") { const u = e.rtlTranslate ? -1 : 1; t = e && e.translate && e.translate * u || 0 } const n = e.params, r = e.maxTranslate() - e.minTranslate(); let { progress: i, isBeginning: s, isEnd: o, progressLoop: l } = e; const a = s, c = o; if (r === 0) i = 0, s = !0, o = !0; else { i = (t - e.minTranslate()) / r; const u = Math.abs(t - e.minTranslate()) < 1, f = Math.abs(t - e.maxTranslate()) < 1; s = u || i <= 0, o = f || i >= 1, u && (i = 0), f && (i = 1) } if (n.loop) { const u = e.getSlideIndexByData(0), f = e.getSlideIndexByData(e.slides.length - 1), h = e.slidesGrid[u], y = e.slidesGrid[f], g = e.slidesGrid[e.slidesGrid.length - 1], w = Math.abs(t); w >= h ? l = (w - h) / g : l = (w + g - y) / g, l > 1 && (l -= 1) } Object.assign(e, { progress: i, progressLoop: l, isBeginning: s, isEnd: o }), (n.watchSlidesProgress || n.centeredSlides && n.autoHeight) && e.updateSlidesProgress(t), s && !a && e.emit("reachBeginning toEdge"), o && !c && e.emit("reachEnd toEdge"), (a && !s || c && !o) && e.emit("fromEdge"), e.emit("progress", i) } const Mc = (t, e, n) => { e && !t.classList.contains(n) ? t.classList.add(n) : !e && t.classList.contains(n) && t.classList.remove(n) }; function aP() { const t = this, { slides: e, params: n, slidesEl: r, activeIndex: i } = t, s = t.virtual && n.virtual.enabled, o = t.grid && n.grid && n.grid.rows > 1, l = f => qt(r, `.${n.slideClass}${f}, swiper-slide${f}`)[0]; let a, c, u; if (s) if (n.loop) { let f = i - t.virtual.slidesBefore; f < 0 && (f = t.virtual.slides.length + f), f >= t.virtual.slides.length && (f -= t.virtual.slides.length), a = l(`[data-swiper-slide-index="${f}"]`) } else a = l(`[data-swiper-slide-index="${i}"]`); else o ? (a = e.filter(f => f.column === i)[0], u = e.filter(f => f.column === i + 1)[0], c = e.filter(f => f.column === i - 1)[0]) : a = e[i]; a && (o || (u = K2(a, `.${n.slideClass}, swiper-slide`)[0], n.loop && !u && (u = e[0]), c = G2(a, `.${n.slideClass}, swiper-slide`)[0], n.loop && !c === 0 && (c = e[e.length - 1]))), e.forEach(f => { Mc(f, f === a, n.slideActiveClass), Mc(f, f === u, n.slideNextClass), Mc(f, f === c, n.slidePrevClass) }), t.emitSlidesClasses() } const ya = (t, e) => { if (!t || t.destroyed || !t.params) return; const n = () => t.isElement ? "swiper-slide" : `.${t.params.slideClass}`, r = e.closest(n()); if (r) { let i = r.querySelector(`.${t.params.lazyPreloaderClass}`); !i && t.isElement && (r.shadowRoot ? i = r.shadowRoot.querySelector(`.${t.params.lazyPreloaderClass}`) : requestAnimationFrame(() => { r.shadowRoot && (i = r.shadowRoot.querySelector(`.${t.params.lazyPreloaderClass}`), i && i.remove()) })), i && i.remove() } }, Fc = (t, e) => { if (!t.slides[e]) return; const n = t.slides[e].querySelector('[loading="lazy"]'); n && n.removeAttribute("loading") }, ad = t => { if (!t || t.destroyed || !t.params) return; let e = t.params.lazyPreloadPrevNext; const n = t.slides.length; if (!n || !e || e < 0) return; e = Math.min(e, n); const r = t.params.slidesPerView === "auto" ? t.slidesPerViewDynamic() : Math.ceil(t.params.slidesPerView), i = t.activeIndex; if (t.params.grid && t.params.grid.rows > 1) { const o = i, l = [o - e]; l.push(...Array.from({ length: e }).map((a, c) => o + r + c)), t.slides.forEach((a, c) => { l.includes(a.column) && Fc(t, c) }); return } const s = i + r - 1; if (t.params.rewind || t.params.loop) for (let o = i - e; o <= s + e; o += 1) { const l = (o % n + n) % n; (l < i || l > s) && Fc(t, l) } else for (let o = Math.max(i - e, 0); o <= Math.min(s + e, n - 1); o += 1)o !== i && (o > s || o < i) && Fc(t, o) }; function lP(t) { const { slidesGrid: e, params: n } = t, r = t.rtlTranslate ? t.translate : -t.translate; let i; for (let s = 0; s < e.length; s += 1)typeof e[s + 1] < "u" ? r >= e[s] && r < e[s + 1] - (e[s + 1] - e[s]) / 2 ? i = s : r >= e[s] && r < e[s + 1] && (i = s + 1) : r >= e[s] && (i = s); return n.normalizeSlideIndex && (i < 0 || typeof i > "u") && (i = 0), i } function cP(t) { const e = this, n = e.rtlTranslate ? e.translate : -e.translate, { snapGrid: r, params: i, activeIndex: s, realIndex: o, snapIndex: l } = e; let a = t, c; const u = y => { let g = y - e.virtual.slidesBefore; return g < 0 && (g = e.virtual.slides.length + g), g >= e.virtual.slides.length && (g -= e.virtual.slides.length), g }; if (typeof a > "u" && (a = lP(e)), r.indexOf(n) >= 0) c = r.indexOf(n); else { const y = Math.min(i.slidesPerGroupSkip, a); c = y + Math.floor((a - y) / i.slidesPerGroup) } if (c >= r.length && (c = r.length - 1), a === s && !e.params.loop) { c !== l && (e.snapIndex = c, e.emit("snapIndexChange")); return } if (a === s && e.params.loop && e.virtual && e.params.virtual.enabled) { e.realIndex = u(a); return } const f = e.grid && i.grid && i.grid.rows > 1; let h; if (e.virtual && i.virtual.enabled && i.loop) h = u(a); else if (f) { const y = e.slides.filter(w => w.column === a)[0]; let g = parseInt(y.getAttribute("data-swiper-slide-index"), 10); Number.isNaN(g) && (g = Math.max(e.slides.indexOf(y), 0)), h = Math.floor(g / i.grid.rows) } else if (e.slides[a]) { const y = e.slides[a].getAttribute("data-swiper-slide-index"); y ? h = parseInt(y, 10) : h = a } else h = a; Object.assign(e, { previousSnapIndex: l, snapIndex: c, previousRealIndex: o, realIndex: h, previousIndex: s, activeIndex: a }), e.initialized && ad(e), e.emit("activeIndexChange"), e.emit("snapIndexChange"), (e.initialized || e.params.runCallbacksOnInit) && (o !== h && e.emit("realIndexChange"), e.emit("slideChange")) } function uP(t, e) { const n = this, r = n.params; let i = t.closest(`.${r.slideClass}, swiper-slide`); !i && n.isElement && e && e.length > 1 && e.includes(t) && [...e.slice(e.indexOf(t) + 1, e.length)].forEach(l => { !i && l.matches && l.matches(`.${r.slideClass}, swiper-slide`) && (i = l) }); let s = !1, o; if (i) { for (let l = 0; l < n.slides.length; l += 1)if (n.slides[l] === i) { s = !0, o = l; break } } if (i && s) n.clickedSlide = i, n.virtual && n.params.virtual.enabled ? n.clickedIndex = parseInt(i.getAttribute("data-swiper-slide-index"), 10) : n.clickedIndex = o; else { n.clickedSlide = void 0, n.clickedIndex = void 0; return } r.slideToClickedSlide && n.clickedIndex !== void 0 && n.clickedIndex !== n.activeIndex && n.slideToClickedSlide() } var dP = { updateSize: tP, updateSlides: nP, updateAutoHeight: rP, updateSlidesOffset: iP, updateSlidesProgress: sP, updateProgress: oP, updateSlidesClasses: aP, updateActiveIndex: cP, updateClickedSlide: uP }; function fP(t) { t === void 0 && (t = this.isHorizontal() ? "x" : "y"); const e = this, { params: n, rtlTranslate: r, translate: i, wrapperEl: s } = e; if (n.virtualTranslate) return r ? -i : i; if (n.cssMode) return i; let o = H2(s, t); return o += e.cssOverflowAdjustment(), r && (o = -o), o || 0 } function pP(t, e) { const n = this, { rtlTranslate: r, params: i, wrapperEl: s, progress: o } = n; let l = 0, a = 0; const c = 0; n.isHorizontal() ? l = r ? -t : t : a = t, i.roundLengths && (l = Math.floor(l), a = Math.floor(a)), n.previousTranslate = n.translate, n.translate = n.isHorizontal() ? l : a, i.cssMode ? s[n.isHorizontal() ? "scrollLeft" : "scrollTop"] = n.isHorizontal() ? -l : -a : i.virtualTranslate || (n.isHorizontal() ? l -= n.cssOverflowAdjustment() : a -= n.cssOverflowAdjustment(), s.style.transform = `translate3d(${l}px, ${a}px, ${c}px)`); let u; const f = n.maxTranslate() - n.minTranslate(); f === 0 ? u = 0 : u = (t - n.minTranslate()) / f, u !== o && n.updateProgress(t), n.emit("setTranslate", n.translate, e) } function hP() { return -this.snapGrid[0] } function mP() { return -this.snapGrid[this.snapGrid.length - 1] } function gP(t, e, n, r, i) { t === void 0 && (t = 0), e === void 0 && (e = this.params.speed), n === void 0 && (n = !0), r === void 0 && (r = !0); const s = this, { params: o, wrapperEl: l } = s; if (s.animating && o.preventInteractionOnTransition) return !1; const a = s.minTranslate(), c = s.maxTranslate(); let u; if (r && t > a ? u = a : r && t < c ? u = c : u = t, s.updateProgress(u), o.cssMode) { const f = s.isHorizontal(); if (e === 0) l[f ? "scrollLeft" : "scrollTop"] = -u; else { if (!s.support.smoothScroll) return h0({ swiper: s, targetPosition: -u, side: f ? "left" : "top" }), !0; l.scrollTo({ [f ? "left" : "top"]: -u, behavior: "smooth" }) } return !0 } return e === 0 ? (s.setTransition(0), s.setTranslate(u), n && (s.emit("beforeTransitionStart", e, i), s.emit("transitionEnd"))) : (s.setTransition(e), s.setTranslate(u), n && (s.emit("beforeTransitionStart", e, i), s.emit("transitionStart")), s.animating || (s.animating = !0, s.onTranslateToWrapperTransitionEnd || (s.onTranslateToWrapperTransitionEnd = function (h) { !s || s.destroyed || h.target === this && (s.wrapperEl.removeEventListener("transitionend", s.onTranslateToWrapperTransitionEnd), s.onTranslateToWrapperTransitionEnd = null, delete s.onTranslateToWrapperTransitionEnd, s.animating = !1, n && s.emit("transitionEnd")) }), s.wrapperEl.addEventListener("transitionend", s.onTranslateToWrapperTransitionEnd))), !0 } var vP = { getTranslate: fP, setTranslate: pP, minTranslate: hP, maxTranslate: mP, translateTo: gP }; function yP(t, e) { const n = this; n.params.cssMode || (n.wrapperEl.style.transitionDuration = `${t}ms`, n.wrapperEl.style.transitionDelay = t === 0 ? "0ms" : ""), n.emit("setTransition", t, e) } function y0(t) { let { swiper: e, runCallbacks: n, direction: r, step: i } = t; const { activeIndex: s, previousIndex: o } = e; let l = r; if (l || (s > o ? l = "next" : s < o ? l = "prev" : l = "reset"), e.emit(`transition${i}`), n && s !== o) { if (l === "reset") { e.emit(`slideResetTransition${i}`); return } e.emit(`slideChangeTransition${i}`), l === "next" ? e.emit(`slideNextTransition${i}`) : e.emit(`slidePrevTransition${i}`) } } function wP(t, e) { t === void 0 && (t = !0); const n = this, { params: r } = n; r.cssMode || (r.autoHeight && n.updateAutoHeight(), y0({ swiper: n, runCallbacks: t, direction: e, step: "Start" })) } function xP(t, e) { t === void 0 && (t = !0); const n = this, { params: r } = n; n.animating = !1, !r.cssMode && (n.setTransition(0), y0({ swiper: n, runCallbacks: t, direction: e, step: "End" })) } var SP = { setTransition: yP, transitionStart: wP, transitionEnd: xP }; function EP(t, e, n, r, i) { t === void 0 && (t = 0), n === void 0 && (n = !0), typeof t == "string" && (t = parseInt(t, 10)); const s = this; let o = t; o < 0 && (o = 0); const { params: l, snapGrid: a, slidesGrid: c, previousIndex: u, activeIndex: f, rtlTranslate: h, wrapperEl: y, enabled: g } = s; if (!g && !r && !i || s.destroyed || s.animating && l.preventInteractionOnTransition) return !1; typeof e > "u" && (e = s.params.speed); const w = Math.min(s.params.slidesPerGroupSkip, o); let E = w + Math.floor((o - w) / s.params.slidesPerGroup); E >= a.length && (E = a.length - 1); const v = -a[E]; if (l.normalizeSlideIndex) for (let T = 0; T < c.length; T += 1) { const x = -Math.floor(v * 100), P = Math.floor(c[T] * 100), I = Math.floor(c[T + 1] * 100); typeof c[T + 1] < "u" ? x >= P && x < I - (I - P) / 2 ? o = T : x >= P && x < I && (o = T + 1) : x >= P && (o = T) } if (s.initialized && o !== f && (!s.allowSlideNext && (h ? v > s.translate && v > s.minTranslate() : v < s.translate && v < s.minTranslate()) || !s.allowSlidePrev && v > s.translate && v > s.maxTranslate() && (f || 0) !== o)) return !1; o !== (u || 0) && n && s.emit("beforeSlideChangeStart"), s.updateProgress(v); let p; o > f ? p = "next" : o < f ? p = "prev" : p = "reset"; const m = s.virtual && s.params.virtual.enabled; if (!(m && i) && (h && -v === s.translate || !h && v === s.translate)) return s.updateActiveIndex(o), l.autoHeight && s.updateAutoHeight(), s.updateSlidesClasses(), l.effect !== "slide" && s.setTranslate(v), p !== "reset" && (s.transitionStart(n, p), s.transitionEnd(n, p)), !1; if (l.cssMode) { const T = s.isHorizontal(), x = h ? v : -v; if (e === 0) m && (s.wrapperEl.style.scrollSnapType = "none", s._immediateVirtual = !0), m && !s._cssModeVirtualInitialSet && s.params.initialSlide > 0 ? (s._cssModeVirtualInitialSet = !0, requestAnimationFrame(() => { y[T ? "scrollLeft" : "scrollTop"] = x })) : y[T ? "scrollLeft" : "scrollTop"] = x, m && requestAnimationFrame(() => { s.wrapperEl.style.scrollSnapType = "", s._immediateVirtual = !1 }); else { if (!s.support.smoothScroll) return h0({ swiper: s, targetPosition: x, side: T ? "left" : "top" }), !0; y.scrollTo({ [T ? "left" : "top"]: x, behavior: "smooth" }) } return !0 } return s.setTransition(e), s.setTranslate(v), s.updateActiveIndex(o), s.updateSlidesClasses(), s.emit("beforeTransitionStart", e, r), s.transitionStart(n, p), e === 0 ? s.transitionEnd(n, p) : s.animating || (s.animating = !0, s.onSlideToWrapperTransitionEnd || (s.onSlideToWrapperTransitionEnd = function (x) { !s || s.destroyed || x.target === this && (s.wrapperEl.removeEventListener("transitionend", s.onSlideToWrapperTransitionEnd), s.onSlideToWrapperTransitionEnd = null, delete s.onSlideToWrapperTransitionEnd, s.transitionEnd(n, p)) }), s.wrapperEl.addEventListener("transitionend", s.onSlideToWrapperTransitionEnd)), !0 } function bP(t, e, n, r) { t === void 0 && (t = 0), n === void 0 && (n = !0), typeof t == "string" && (t = parseInt(t, 10)); const i = this; if (i.destroyed) return; typeof e > "u" && (e = i.params.speed); const s = i.grid && i.params.grid && i.params.grid.rows > 1; let o = t; if (i.params.loop) if (i.virtual && i.params.virtual.enabled) o = o + i.virtual.slidesBefore; else { let l; if (s) { const h = o * i.params.grid.rows; l = i.slides.filter(y => y.getAttribute("data-swiper-slide-index") * 1 === h)[0].column } else l = i.getSlideIndexByData(o); const a = s ? Math.ceil(i.slides.length / i.params.grid.rows) : i.slides.length, { centeredSlides: c } = i.params; let u = i.params.slidesPerView; u === "auto" ? u = i.slidesPerViewDynamic() : (u = Math.ceil(parseFloat(i.params.slidesPerView, 10)), c && u % 2 === 0 && (u = u + 1)); let f = a - l < u; if (c && (f = f || l < Math.ceil(u / 2)), r && c && i.params.slidesPerView !== "auto" && !s && (f = !1), f) { const h = c ? l < i.activeIndex ? "prev" : "next" : l - i.activeIndex - 1 < i.params.slidesPerView ? "next" : "prev"; i.loopFix({ direction: h, slideTo: !0, activeSlideIndex: h === "next" ? l + 1 : l - a + 1, slideRealIndex: h === "next" ? i.realIndex : void 0 }) } if (s) { const h = o * i.params.grid.rows; o = i.slides.filter(y => y.getAttribute("data-swiper-slide-index") * 1 === h)[0].column } else o = i.getSlideIndexByData(o) } return requestAnimationFrame(() => { i.slideTo(o, e, n, r) }), i } function TP(t, e, n) { e === void 0 && (e = !0); const r = this, { enabled: i, params: s, animating: o } = r; if (!i || r.destroyed) return r; typeof t > "u" && (t = r.params.speed); let l = s.slidesPerGroup; s.slidesPerView === "auto" && s.slidesPerGroup === 1 && s.slidesPerGroupAuto && (l = Math.max(r.slidesPerViewDynamic("current", !0), 1)); const a = r.activeIndex < s.slidesPerGroupSkip ? 1 : l, c = r.virtual && s.virtual.enabled; if (s.loop) { if (o && !c && s.loopPreventsSliding) return !1; if (r.loopFix({ direction: "next" }), r._clientLeft = r.wrapperEl.clientLeft, r.activeIndex === r.slides.length - 1 && s.cssMode) return requestAnimationFrame(() => { r.slideTo(r.activeIndex + a, t, e, n) }), !0 } return s.rewind && r.isEnd ? r.slideTo(0, t, e, n) : r.slideTo(r.activeIndex + a, t, e, n) } function CP(t, e, n) { e === void 0 && (e = !0); const r = this, { params: i, snapGrid: s, slidesGrid: o, rtlTranslate: l, enabled: a, animating: c } = r; if (!a || r.destroyed) return r; typeof t > "u" && (t = r.params.speed); const u = r.virtual && i.virtual.enabled; if (i.loop) { if (c && !u && i.loopPreventsSliding) return !1; r.loopFix({ direction: "prev" }), r._clientLeft = r.wrapperEl.clientLeft } const f = l ? r.translate : -r.translate; function h(v) { return v < 0 ? -Math.floor(Math.abs(v)) : Math.floor(v) } const y = h(f), g = s.map(v => h(v)); let w = s[g.indexOf(y) - 1]; if (typeof w > "u" && i.cssMode) { let v; s.forEach((p, m) => { y >= p && (v = m) }), typeof v < "u" && (w = s[v > 0 ? v - 1 : v]) } let E = 0; if (typeof w < "u" && (E = o.indexOf(w), E < 0 && (E = r.activeIndex - 1), i.slidesPerView === "auto" && i.slidesPerGroup === 1 && i.slidesPerGroupAuto && (E = E - r.slidesPerViewDynamic("previous", !0) + 1, E = Math.max(E, 0))), i.rewind && r.isBeginning) { const v = r.params.virtual && r.params.virtual.enabled && r.virtual ? r.virtual.slides.length - 1 : r.slides.length - 1; return r.slideTo(v, t, e, n) } else if (i.loop && r.activeIndex === 0 && i.cssMode) return requestAnimationFrame(() => { r.slideTo(E, t, e, n) }), !0; return r.slideTo(E, t, e, n) } function _P(t, e, n) { e === void 0 && (e = !0); const r = this; if (!r.destroyed) return typeof t > "u" && (t = r.params.speed), r.slideTo(r.activeIndex, t, e, n) } function PP(t, e, n, r) { e === void 0 && (e = !0), r === void 0 && (r = .5); const i = this; if (i.destroyed) return; typeof t > "u" && (t = i.params.speed); let s = i.activeIndex; const o = Math.min(i.params.slidesPerGroupSkip, s), l = o + Math.floor((s - o) / i.params.slidesPerGroup), a = i.rtlTranslate ? i.translate : -i.translate; if (a >= i.snapGrid[l]) { const c = i.snapGrid[l], u = i.snapGrid[l + 1]; a - c > (u - c) * r && (s += i.params.slidesPerGroup) } else { const c = i.snapGrid[l - 1], u = i.snapGrid[l]; a - c <= (u - c) * r && (s -= i.params.slidesPerGroup) } return s = Math.max(s, 0), s = Math.min(s, i.slidesGrid.length - 1), i.slideTo(s, t, e, n) } function IP() { const t = this; if (t.destroyed) return; const { params: e, slidesEl: n } = t, r = e.slidesPerView === "auto" ? t.slidesPerViewDynamic() : e.slidesPerView; let i = t.clickedIndex, s; const o = t.isElement ? "swiper-slide" : `.${e.slideClass}`; if (e.loop) { if (t.animating) return; s = parseInt(t.clickedSlide.getAttribute("data-swiper-slide-index"), 10), e.centeredSlides ? i < t.loopedSlides - r / 2 || i > t.slides.length - t.loopedSlides + r / 2 ? (t.loopFix(), i = t.getSlideIndex(qt(n, `${o}[data-swiper-slide-index="${s}"]`)[0]), sd(() => { t.slideTo(i) })) : t.slideTo(i) : i > t.slides.length - r ? (t.loopFix(), i = t.getSlideIndex(qt(n, `${o}[data-swiper-slide-index="${s}"]`)[0]), sd(() => { t.slideTo(i) })) : t.slideTo(i) } else t.slideTo(i) } var kP = { slideTo: EP, slideToLoop: bP, slideNext: TP, slidePrev: CP, slideReset: _P, slideToClosest: PP, slideToClickedSlide: IP }; function NP(t) { const e = this, { params: n, slidesEl: r } = e; if (!n.loop || e.virtual && e.params.virtual.enabled) return; const i = () => { qt(r, `.${n.slideClass}, swiper-slide`).forEach((f, h) => { f.setAttribute("data-swiper-slide-index", h) }) }, s = e.grid && n.grid && n.grid.rows > 1, o = n.slidesPerGroup * (s ? n.grid.rows : 1), l = e.slides.length % o !== 0, a = s && e.slides.length % n.grid.rows !== 0, c = u => { for (let f = 0; f < u; f += 1) { const h = e.isElement ? cl("swiper-slide", [n.slideBlankClass]) : cl("div", [n.slideClass, n.slideBlankClass]); e.slidesEl.append(h) } }; if (l) { if (n.loopAddBlankSlides) { const u = o - e.slides.length % o; c(u), e.recalcSlides(), e.updateSlides() } else ll("Swiper Loop Warning: The number of slides is not even to slidesPerGroup, loop mode may not function properly. You need to add more slides (or make duplicates, or empty slides)"); i() } else if (a) { if (n.loopAddBlankSlides) { const u = n.grid.rows - e.slides.length % n.grid.rows; c(u), e.recalcSlides(), e.updateSlides() } else ll("Swiper Loop Warning: The number of slides is not even to grid.rows, loop mode may not function properly. You need to add more slides (or make duplicates, or empty slides)"); i() } else i(); e.loopFix({ slideRealIndex: t, direction: n.centeredSlides ? void 0 : "next" }) } function RP(t) { let { slideRealIndex: e, slideTo: n = !0, direction: r, setTranslate: i, activeSlideIndex: s, byController: o, byMousewheel: l } = t === void 0 ? {} : t; const a = this; if (!a.params.loop) return; a.emit("beforeLoopFix"); const { slides: c, allowSlidePrev: u, allowSlideNext: f, slidesEl: h, params: y } = a, { centeredSlides: g } = y; if (a.allowSlidePrev = !0, a.allowSlideNext = !0, a.virtual && y.virtual.enabled) { n && (!y.centeredSlides && a.snapIndex === 0 ? a.slideTo(a.virtual.slides.length, 0, !1, !0) : y.centeredSlides && a.snapIndex < y.slidesPerView ? a.slideTo(a.virtual.slides.length + a.snapIndex, 0, !1, !0) : a.snapIndex === a.snapGrid.length - 1 && a.slideTo(a.virtual.slidesBefore, 0, !1, !0)), a.allowSlidePrev = u, a.allowSlideNext = f, a.emit("loopFix"); return } let w = y.slidesPerView; w === "auto" ? w = a.slidesPerViewDynamic() : (w = Math.ceil(parseFloat(y.slidesPerView, 10)), g && w % 2 === 0 && (w = w + 1)); const E = y.slidesPerGroupAuto ? w : y.slidesPerGroup; let v = E; v % E !== 0 && (v += E - v % E), v += y.loopAdditionalSlides, a.loopedSlides = v; const p = a.grid && y.grid && y.grid.rows > 1; c.length < w + v ? ll("Swiper Loop Warning: The number of slides is not enough for loop mode, it will be disabled and not function properly. You need to add more slides (or make duplicates) or lower the values of slidesPerView and slidesPerGroup parameters") : p && y.grid.fill === "row" && ll("Swiper Loop Warning: Loop mode is not compatible with grid.fill = `row`"); const m = [], S = []; let T = a.activeIndex; typeof s > "u" ? s = a.getSlideIndex(c.filter(D => D.classList.contains(y.slideActiveClass))[0]) : T = s; const x = r === "next" || !r, P = r === "prev" || !r; let I = 0, N = 0; const k = p ? Math.ceil(c.length / y.grid.rows) : c.length, F = (p ? c[s].column : s) + (g && typeof i > "u" ? -w / 2 + .5 : 0); if (F < v) { I = Math.max(v - F, E); for (let D = 0; D < v - F; D += 1) { const B = D - Math.floor(D / k) * k; if (p) { const J = k - B - 1; for (let de = c.length - 1; de >= 0; de -= 1)c[de].column === J && m.push(de) } else m.push(k - B - 1) } } else if (F + w > k - v) { N = Math.max(F - (k - v * 2), E); for (let D = 0; D < N; D += 1) { const B = D - Math.floor(D / k) * k; p ? c.forEach((J, de) => { J.column === B && S.push(de) }) : S.push(B) } } if (a.__preventObserver__ = !0, requestAnimationFrame(() => { a.__preventObserver__ = !1 }), P && m.forEach(D => { c[D].swiperLoopMoveDOM = !0, h.prepend(c[D]), c[D].swiperLoopMoveDOM = !1 }), x && S.forEach(D => { c[D].swiperLoopMoveDOM = !0, h.append(c[D]), c[D].swiperLoopMoveDOM = !1 }), a.recalcSlides(), y.slidesPerView === "auto" ? a.updateSlides() : p && (m.length > 0 && P || S.length > 0 && x) && a.slides.forEach((D, B) => { a.grid.updateSlide(B, D, a.slides) }), y.watchSlidesProgress && a.updateSlidesOffset(), n) { if (m.length > 0 && P) { if (typeof e > "u") { const D = a.slidesGrid[T], J = a.slidesGrid[T + I] - D; l ? a.setTranslate(a.translate - J) : (a.slideTo(T + Math.ceil(I), 0, !1, !0), i && (a.touchEventsData.startTranslate = a.touchEventsData.startTranslate - J, a.touchEventsData.currentTranslate = a.touchEventsData.currentTranslate - J)) } else if (i) { const D = p ? m.length / y.grid.rows : m.length; a.slideTo(a.activeIndex + D, 0, !1, !0), a.touchEventsData.currentTranslate = a.translate } } else if (S.length > 0 && x) if (typeof e > "u") { const D = a.slidesGrid[T], J = a.slidesGrid[T - N] - D; l ? a.setTranslate(a.translate - J) : (a.slideTo(T - N, 0, !1, !0), i && (a.touchEventsData.startTranslate = a.touchEventsData.startTranslate - J, a.touchEventsData.currentTranslate = a.touchEventsData.currentTranslate - J)) } else { const D = p ? S.length / y.grid.rows : S.length; a.slideTo(a.activeIndex - D, 0, !1, !0) } } if (a.allowSlidePrev = u, a.allowSlideNext = f, a.controller && a.controller.control && !o) { const D = { slideRealIndex: e, direction: r, setTranslate: i, activeSlideIndex: s, byController: !0 }; Array.isArray(a.controller.control) ? a.controller.control.forEach(B => { !B.destroyed && B.params.loop && B.loopFix({ ...D, slideTo: B.params.slidesPerView === y.slidesPerView ? n : !1 }) }) : a.controller.control instanceof a.constructor && a.controller.control.params.loop && a.controller.control.loopFix({ ...D, slideTo: a.controller.control.params.slidesPerView === y.slidesPerView ? n : !1 }) } a.emit("loopFix") } function OP() { const t = this, { params: e, slidesEl: n } = t; if (!e.loop || t.virtual && t.params.virtual.enabled) return; t.recalcSlides(); const r = []; t.slides.forEach(i => { const s = typeof i.swiperSlideIndex > "u" ? i.getAttribute("data-swiper-slide-index") * 1 : i.swiperSlideIndex; r[s] = i }), t.slides.forEach(i => { i.removeAttribute("data-swiper-slide-index") }), r.forEach(i => { n.append(i) }), t.recalcSlides(), t.slideTo(t.realIndex, 0) } var jP = { loopCreate: NP, loopFix: RP, loopDestroy: OP }; function AP(t) { const e = this; if (!e.params.simulateTouch || e.params.watchOverflow && e.isLocked || e.params.cssMode) return; const n = e.params.touchEventsTarget === "container" ? e.el : e.wrapperEl; e.isElement && (e.__preventObserver__ = !0), n.style.cursor = "move", n.style.cursor = t ? "grabbing" : "grab", e.isElement && requestAnimationFrame(() => { e.__preventObserver__ = !1 }) } function LP() { const t = this; t.params.watchOverflow && t.isLocked || t.params.cssMode || (t.isElement && (t.__preventObserver__ = !0), t[t.params.touchEventsTarget === "container" ? "el" : "wrapperEl"].style.cursor = "", t.isElement && requestAnimationFrame(() => { t.__preventObserver__ = !1 })) } var DP = { setGrabCursor: AP, unsetGrabCursor: LP }; function MP(t, e) { e === void 0 && (e = this); function n(r) { if (!r || r === vn() || r === wt()) return null; r.assignedSlot && (r = r.assignedSlot); const i = r.closest(t); return !i && !r.getRootNode ? null : i || n(r.getRootNode().host) } return n(e) } function hm(t, e, n) { const r = wt(), { params: i } = t, s = i.edgeSwipeDetection, o = i.edgeSwipeThreshold; return s && (n <= o || n >= r.innerWidth - o) ? s === "prevent" ? (e.preventDefault(), !0) : !1 : !0 } function FP(t) { const e = this, n = vn(); let r = t; r.originalEvent && (r = r.originalEvent); const i = e.touchEventsData; if (r.type === "pointerdown") { if (i.pointerId !== null && i.pointerId !== r.pointerId) return; i.pointerId = r.pointerId } else r.type === "touchstart" && r.targetTouches.length === 1 && (i.touchId = r.targetTouches[0].identifier); if (r.type === "touchstart") { hm(e, r, r.targetTouches[0].pageX); return } const { params: s, touches: o, enabled: l } = e; if (!l || !s.simulateTouch && r.pointerType === "mouse" || e.animating && s.preventInteractionOnTransition) return; !e.animating && s.cssMode && s.loop && e.loopFix(); let a = r.target; if (s.touchEventsTarget === "wrapper" && !W2(a, e.wrapperEl) || "which" in r && r.which === 3 || "button" in r && r.button > 0 || i.isTouched && i.isMoved) return; const c = !!s.noSwipingClass && s.noSwipingClass !== "", u = r.composedPath ? r.composedPath() : r.path; c && r.target && r.target.shadowRoot && u && (a = u[0]); const f = s.noSwipingSelector ? s.noSwipingSelector : `.${s.noSwipingClass}`, h = !!(r.target && r.target.shadowRoot); if (s.noSwiping && (h ? MP(f, a) : a.closest(f))) { e.allowClick = !0; return } if (s.swipeHandler && !a.closest(s.swipeHandler)) return; o.currentX = r.pageX, o.currentY = r.pageY; const y = o.currentX, g = o.currentY; if (!hm(e, r, y)) return; Object.assign(i, { isTouched: !0, isMoved: !1, allowTouchCallbacks: !0, isScrolling: void 0, startMoving: void 0 }), o.startX = y, o.startY = g, i.touchStartTime = al(), e.allowClick = !0, e.updateSize(), e.swipeDirection = void 0, s.threshold > 0 && (i.allowThresholdMove = !1); let w = !0; a.matches(i.focusableElements) && (w = !1, a.nodeName === "SELECT" && (i.isTouched = !1)), n.activeElement && n.activeElement.matches(i.focusableElements) && n.activeElement !== a && (r.pointerType === "mouse" || r.pointerType !== "mouse" && !a.matches(i.focusableElements)) && n.activeElement.blur(); const E = w && e.allowTouchMove && s.touchStartPreventDefault; (s.touchStartForcePreventDefault || E) && !a.isContentEditable && r.preventDefault(), s.freeMode && s.freeMode.enabled && e.freeMode && e.animating && !s.cssMode && e.freeMode.onTouchStart(), e.emit("touchStart", r) } function UP(t) { const e = vn(), n = this, r = n.touchEventsData, { params: i, touches: s, rtlTranslate: o, enabled: l } = n; if (!l || !i.simulateTouch && t.pointerType === "mouse") return; let a = t; if (a.originalEvent && (a = a.originalEvent), a.type === "pointermove" && (r.touchId !== null || a.pointerId !== r.pointerId)) return; let c; if (a.type === "touchmove") { if (c = [...a.changedTouches].filter(x => x.identifier === r.touchId)[0], !c || c.identifier !== r.touchId) return } else c = a; if (!r.isTouched) { r.startMoving && r.isScrolling && n.emit("touchMoveOpposite", a); return } const u = c.pageX, f = c.pageY; if (a.preventedByNestedSwiper) { s.startX = u, s.startY = f; return } if (!n.allowTouchMove) { a.target.matches(r.focusableElements) || (n.allowClick = !1), r.isTouched && (Object.assign(s, { startX: u, startY: f, currentX: u, currentY: f }), r.touchStartTime = al()); return } if (i.touchReleaseOnEdges && !i.loop) { if (n.isVertical()) { if (f < s.startY && n.translate <= n.maxTranslate() || f > s.startY && n.translate >= n.minTranslate()) { r.isTouched = !1, r.isMoved = !1; return } } else if (u < s.startX && n.translate <= n.maxTranslate() || u > s.startX && n.translate >= n.minTranslate()) return } if (e.activeElement && e.activeElement.matches(r.focusableElements) && e.activeElement !== a.target && a.pointerType !== "mouse" && e.activeElement.blur(), e.activeElement && a.target === e.activeElement && a.target.matches(r.focusableElements)) { r.isMoved = !0, n.allowClick = !1; return } r.allowTouchCallbacks && n.emit("touchMove", a), s.previousX = s.currentX, s.previousY = s.currentY, s.currentX = u, s.currentY = f; const h = s.currentX - s.startX, y = s.currentY - s.startY; if (n.params.threshold && Math.sqrt(h ** 2 + y ** 2) < n.params.threshold) return; if (typeof r.isScrolling > "u") { let x; n.isHorizontal() && s.currentY === s.startY || n.isVertical() && s.currentX === s.startX ? r.isScrolling = !1 : h * h + y * y >= 25 && (x = Math.atan2(Math.abs(y), Math.abs(h)) * 180 / Math.PI, r.isScrolling = n.isHorizontal() ? x > i.touchAngle : 90 - x > i.touchAngle) } if (r.isScrolling && n.emit("touchMoveOpposite", a), typeof r.startMoving > "u" && (s.currentX !== s.startX || s.currentY !== s.startY) && (r.startMoving = !0), r.isScrolling || a.type === "touchmove" && r.preventTouchMoveFromPointerMove) { r.isTouched = !1; return } if (!r.startMoving) return; n.allowClick = !1, !i.cssMode && a.cancelable && a.preventDefault(), i.touchMoveStopPropagation && !i.nested && a.stopPropagation(); let g = n.isHorizontal() ? h : y, w = n.isHorizontal() ? s.currentX - s.previousX : s.currentY - s.previousY; i.oneWayMovement && (g = Math.abs(g) * (o ? 1 : -1), w = Math.abs(w) * (o ? 1 : -1)), s.diff = g, g *= i.touchRatio, o && (g = -g, w = -w); const E = n.touchesDirection; n.swipeDirection = g > 0 ? "prev" : "next", n.touchesDirection = w > 0 ? "prev" : "next"; const v = n.params.loop && !i.cssMode, p = n.touchesDirection === "next" && n.allowSlideNext || n.touchesDirection === "prev" && n.allowSlidePrev; if (!r.isMoved) { if (v && p && n.loopFix({ direction: n.swipeDirection }), r.startTranslate = n.getTranslate(), n.setTransition(0), n.animating) { const x = new window.CustomEvent("transitionend", { bubbles: !0, cancelable: !0, detail: { bySwiperTouchMove: !0 } }); n.wrapperEl.dispatchEvent(x) } r.allowMomentumBounce = !1, i.grabCursor && (n.allowSlideNext === !0 || n.allowSlidePrev === !0) && n.setGrabCursor(!0), n.emit("sliderFirstMove", a) } let m; if (new Date().getTime(), r.isMoved && r.allowThresholdMove && E !== n.touchesDirection && v && p && Math.abs(g) >= 1) { Object.assign(s, { startX: u, startY: f, currentX: u, currentY: f, startTranslate: r.currentTranslate }), r.loopSwapReset = !0, r.startTranslate = r.currentTranslate; return } n.emit("sliderMove", a), r.isMoved = !0, r.currentTranslate = g + r.startTranslate; let S = !0, T = i.resistanceRatio; if (i.touchReleaseOnEdges && (T = 0), g > 0 ? (v && p && !m && r.allowThresholdMove && r.currentTranslate > (i.centeredSlides ? n.minTranslate() - n.slidesSizesGrid[n.activeIndex + 1] - (i.slidesPerView !== "auto" && n.slides.length - i.slidesPerView >= 2 ? n.slidesSizesGrid[n.activeIndex + 1] + n.params.spaceBetween : 0) - n.params.spaceBetween : n.minTranslate()) && n.loopFix({ direction: "prev", setTranslate: !0, activeSlideIndex: 0 }), r.currentTranslate > n.minTranslate() && (S = !1, i.resistance && (r.currentTranslate = n.minTranslate() - 1 + (-n.minTranslate() + r.startTranslate + g) ** T))) : g < 0 && (v && p && !m && r.allowThresholdMove && r.currentTranslate < (i.centeredSlides ? n.maxTranslate() + n.slidesSizesGrid[n.slidesSizesGrid.length - 1] + n.params.spaceBetween + (i.slidesPerView !== "auto" && n.slides.length - i.slidesPerView >= 2 ? n.slidesSizesGrid[n.slidesSizesGrid.length - 1] + n.params.spaceBetween : 0) : n.maxTranslate()) && n.loopFix({ direction: "next", setTranslate: !0, activeSlideIndex: n.slides.length - (i.slidesPerView === "auto" ? n.slidesPerViewDynamic() : Math.ceil(parseFloat(i.slidesPerView, 10))) }), r.currentTranslate < n.maxTranslate() && (S = !1, i.resistance && (r.currentTranslate = n.maxTranslate() + 1 - (n.maxTranslate() - r.startTranslate - g) ** T))), S && (a.preventedByNestedSwiper = !0), !n.allowSlideNext && n.swipeDirection === "next" && r.currentTranslate < r.startTranslate && (r.currentTranslate = r.startTranslate), !n.allowSlidePrev && n.swipeDirection === "prev" && r.currentTranslate > r.startTranslate && (r.currentTranslate = r.startTranslate), !n.allowSlidePrev && !n.allowSlideNext && (r.currentTranslate = r.startTranslate), i.threshold > 0) if (Math.abs(g) > i.threshold || r.allowThresholdMove) { if (!r.allowThresholdMove) { r.allowThresholdMove = !0, s.startX = s.currentX, s.startY = s.currentY, r.currentTranslate = r.startTranslate, s.diff = n.isHorizontal() ? s.currentX - s.startX : s.currentY - s.startY; return } } else { r.currentTranslate = r.startTranslate; return } !i.followFinger || i.cssMode || ((i.freeMode && i.freeMode.enabled && n.freeMode || i.watchSlidesProgress) && (n.updateActiveIndex(), n.updateSlidesClasses()), i.freeMode && i.freeMode.enabled && n.freeMode && n.freeMode.onTouchMove(), n.updateProgress(r.currentTranslate), n.setTranslate(r.currentTranslate)) } function zP(t) { const e = this, n = e.touchEventsData; let r = t; r.originalEvent && (r = r.originalEvent); let i; if (r.type === "touchend" || r.type === "touchcancel") { if (i = [...r.changedTouches].filter(T => T.identifier === n.touchId)[0], !i || i.identifier !== n.touchId) return } else { if (n.touchId !== null || r.pointerId !== n.pointerId) return; i = r } if (["pointercancel", "pointerout", "pointerleave", "contextmenu"].includes(r.type) && !(["pointercancel", "contextmenu"].includes(r.type) && (e.browser.isSafari || e.browser.isWebView))) return; n.pointerId = null, n.touchId = null; const { params: o, touches: l, rtlTranslate: a, slidesGrid: c, enabled: u } = e; if (!u || !o.simulateTouch && r.pointerType === "mouse") return; if (n.allowTouchCallbacks && e.emit("touchEnd", r), n.allowTouchCallbacks = !1, !n.isTouched) { n.isMoved && o.grabCursor && e.setGrabCursor(!1), n.isMoved = !1, n.startMoving = !1; return } o.grabCursor && n.isMoved && n.isTouched && (e.allowSlideNext === !0 || e.allowSlidePrev === !0) && e.setGrabCursor(!1); const f = al(), h = f - n.touchStartTime; if (e.allowClick) { const T = r.path || r.composedPath && r.composedPath(); e.updateClickedSlide(T && T[0] || r.target, T), e.emit("tap click", r), h < 300 && f - n.lastClickTime < 300 && e.emit("doubleTap doubleClick", r) } if (n.lastClickTime = al(), sd(() => { e.destroyed || (e.allowClick = !0) }), !n.isTouched || !n.isMoved || !e.swipeDirection || l.diff === 0 && !n.loopSwapReset || n.currentTranslate === n.startTranslate && !n.loopSwapReset) { n.isTouched = !1, n.isMoved = !1, n.startMoving = !1; return } n.isTouched = !1, n.isMoved = !1, n.startMoving = !1; let y; if (o.followFinger ? y = a ? e.translate : -e.translate : y = -n.currentTranslate, o.cssMode) return; if (o.freeMode && o.freeMode.enabled) { e.freeMode.onTouchEnd({ currentPos: y }); return } const g = y >= -e.maxTranslate() && !e.params.loop; let w = 0, E = e.slidesSizesGrid[0]; for (let T = 0; T < c.length; T += T < o.slidesPerGroupSkip ? 1 : o.slidesPerGroup) { const x = T < o.slidesPerGroupSkip - 1 ? 1 : o.slidesPerGroup; typeof c[T + x] < "u" ? (g || y >= c[T] && y < c[T + x]) && (w = T, E = c[T + x] - c[T]) : (g || y >= c[T]) && (w = T, E = c[c.length - 1] - c[c.length - 2]) } let v = null, p = null; o.rewind && (e.isBeginning ? p = o.virtual && o.virtual.enabled && e.virtual ? e.virtual.slides.length - 1 : e.slides.length - 1 : e.isEnd && (v = 0)); const m = (y - c[w]) / E, S = w < o.slidesPerGroupSkip - 1 ? 1 : o.slidesPerGroup; if (h > o.longSwipesMs) { if (!o.longSwipes) { e.slideTo(e.activeIndex); return } e.swipeDirection === "next" && (m >= o.longSwipesRatio ? e.slideTo(o.rewind && e.isEnd ? v : w + S) : e.slideTo(w)), e.swipeDirection === "prev" && (m > 1 - o.longSwipesRatio ? e.slideTo(w + S) : p !== null && m < 0 && Math.abs(m) > o.longSwipesRatio ? e.slideTo(p) : e.slideTo(w)) } else { if (!o.shortSwipes) { e.slideTo(e.activeIndex); return } e.navigation && (r.target === e.navigation.nextEl || r.target === e.navigation.prevEl) ? r.target === e.navigation.nextEl ? e.slideTo(w + S) : e.slideTo(w) : (e.swipeDirection === "next" && e.slideTo(v !== null ? v : w + S), e.swipeDirection === "prev" && e.slideTo(p !== null ? p : w)) } } function mm() { const t = this, { params: e, el: n } = t; if (n && n.offsetWidth === 0) return; e.breakpoints && t.setBreakpoint(); const { allowSlideNext: r, allowSlidePrev: i, snapGrid: s } = t, o = t.virtual && t.params.virtual.enabled; t.allowSlideNext = !0, t.allowSlidePrev = !0, t.updateSize(), t.updateSlides(), t.updateSlidesClasses(); const l = o && e.loop; (e.slidesPerView === "auto" || e.slidesPerView > 1) && t.isEnd && !t.isBeginning && !t.params.centeredSlides && !l ? t.slideTo(t.slides.length - 1, 0, !1, !0) : t.params.loop && !o ? t.slideToLoop(t.realIndex, 0, !1, !0) : t.slideTo(t.activeIndex, 0, !1, !0), t.autoplay && t.autoplay.running && t.autoplay.paused && (clearTimeout(t.autoplay.resizeTimeout), t.autoplay.resizeTimeout = setTimeout(() => { t.autoplay && t.autoplay.running && t.autoplay.paused && t.autoplay.resume() }, 500)), t.allowSlidePrev = i, t.allowSlideNext = r, t.params.watchOverflow && s !== t.snapGrid && t.checkOverflow() } function $P(t) { const e = this; e.enabled && (e.allowClick || (e.params.preventClicks && t.preventDefault(), e.params.preventClicksPropagation && e.animating && (t.stopPropagation(), t.stopImmediatePropagation()))) } function BP() { const t = this, { wrapperEl: e, rtlTranslate: n, enabled: r } = t; if (!r) return; t.previousTranslate = t.translate, t.isHorizontal() ? t.translate = -e.scrollLeft : t.translate = -e.scrollTop, t.translate === 0 && (t.translate = 0), t.updateActiveIndex(), t.updateSlidesClasses(); let i; const s = t.maxTranslate() - t.minTranslate(); s === 0 ? i = 0 : i = (t.translate - t.minTranslate()) / s, i !== t.progress && t.updateProgress(n ? -t.translate : t.translate), t.emit("setTranslate", t.translate, !1) } function HP(t) { const e = this; ya(e, t.target), !(e.params.cssMode || e.params.slidesPerView !== "auto" && !e.params.autoHeight) && e.update() } function VP() { const t = this; t.documentTouchHandlerProceeded || (t.documentTouchHandlerProceeded = !0, t.params.touchReleaseOnEdges && (t.el.style.touchAction = "auto")) } const w0 = (t, e) => { const n = vn(), { params: r, el: i, wrapperEl: s, device: o } = t, l = !!r.nested, a = e === "on" ? "addEventListener" : "removeEventListener", c = e; !i || typeof i == "string" || (n[a]("touchstart", t.onDocumentTouchStart, { passive: !1, capture: l }), i[a]("touchstart", t.onTouchStart, { passive: !1 }), i[a]("pointerdown", t.onTouchStart, { passive: !1 }), n[a]("touchmove", t.onTouchMove, { passive: !1, capture: l }), n[a]("pointermove", t.onTouchMove, { passive: !1, capture: l }), n[a]("touchend", t.onTouchEnd, { passive: !0 }), n[a]("pointerup", t.onTouchEnd, { passive: !0 }), n[a]("pointercancel", t.onTouchEnd, { passive: !0 }), n[a]("touchcancel", t.onTouchEnd, { passive: !0 }), n[a]("pointerout", t.onTouchEnd, { passive: !0 }), n[a]("pointerleave", t.onTouchEnd, { passive: !0 }), n[a]("contextmenu", t.onTouchEnd, { passive: !0 }), (r.preventClicks || r.preventClicksPropagation) && i[a]("click", t.onClick, !0), r.cssMode && s[a]("scroll", t.onScroll), r.updateOnWindowResize ? t[c](o.ios || o.android ? "resize orientationchange observerUpdate" : "resize observerUpdate", mm, !0) : t[c]("observerUpdate", mm, !0), i[a]("load", t.onLoad, { capture: !0 })) }; function WP() { const t = this, { params: e } = t; t.onTouchStart = FP.bind(t), t.onTouchMove = UP.bind(t), t.onTouchEnd = zP.bind(t), t.onDocumentTouchStart = VP.bind(t), e.cssMode && (t.onScroll = BP.bind(t)), t.onClick = $P.bind(t), t.onLoad = HP.bind(t), w0(t, "on") } function GP() { w0(this, "off") } var KP = { attachEvents: WP, detachEvents: GP }; const gm = (t, e) => t.grid && e.grid && e.grid.rows > 1; function qP() { const t = this, { realIndex: e, initialized: n, params: r, el: i } = t, s = r.breakpoints; if (!s || s && Object.keys(s).length === 0) return; const o = t.getBreakpoint(s, t.params.breakpointsBase, t.el); if (!o || t.currentBreakpoint === o) return; const a = (o in s ? s[o] : void 0) || t.originalParams, c = gm(t, r), u = gm(t, a), f = t.params.grabCursor, h = a.grabCursor, y = r.enabled; c && !u ? (i.classList.remove(`${r.containerModifierClass}grid`, `${r.containerModifierClass}grid-column`), t.emitContainerClasses()) : !c && u && (i.classList.add(`${r.containerModifierClass}grid`), (a.grid.fill && a.grid.fill === "column" || !a.grid.fill && r.grid.fill === "column") && i.classList.add(`${r.containerModifierClass}grid-column`), t.emitContainerClasses()), f && !h ? t.unsetGrabCursor() : !f && h && t.setGrabCursor(), ["navigation", "pagination", "scrollbar"].forEach(m => { if (typeof a[m] > "u") return; const S = r[m] && r[m].enabled, T = a[m] && a[m].enabled; S && !T && t[m].disable(), !S && T && t[m].enable() }); const g = a.direction && a.direction !== r.direction, w = r.loop && (a.slidesPerView !== r.slidesPerView || g), E = r.loop; g && n && t.changeDirection(), ft(t.params, a); const v = t.params.enabled, p = t.params.loop; Object.assign(t, { allowTouchMove: t.params.allowTouchMove, allowSlideNext: t.params.allowSlideNext, allowSlidePrev: t.params.allowSlidePrev }), y && !v ? t.disable() : !y && v && t.enable(), t.currentBreakpoint = o, t.emit("_beforeBreakpoint", a), n && (w ? (t.loopDestroy(), t.loopCreate(e), t.updateSlides()) : !E && p ? (t.loopCreate(e), t.updateSlides()) : E && !p && t.loopDestroy()), t.emit("breakpoint", a) } function YP(t, e, n) { if (e === void 0 && (e = "window"), !t || e === "container" && !n) return; let r = !1; const i = wt(), s = e === "window" ? i.innerHeight : n.clientHeight, o = Object.keys(t).map(l => { if (typeof l == "string" && l.indexOf("@") === 0) { const a = parseFloat(l.substr(1)); return { value: s * a, point: l } } return { value: l, point: l } }); o.sort((l, a) => parseInt(l.value, 10) - parseInt(a.value, 10)); for (let l = 0; l < o.length; l += 1) { const { point: a, value: c } = o[l]; e === "window" ? i.matchMedia(`(min-width: ${c}px)`).matches && (r = a) : c <= n.clientWidth && (r = a) } return r || "max" } var JP = { setBreakpoint: qP, getBreakpoint: YP }; function XP(t, e) { const n = []; return t.forEach(r => { typeof r == "object" ? Object.keys(r).forEach(i => { r[i] && n.push(e + i) }) : typeof r == "string" && n.push(e + r) }), n } function QP() { const t = this, { classNames: e, params: n, rtl: r, el: i, device: s } = t, o = XP(["initialized", n.direction, { "free-mode": t.params.freeMode && n.freeMode.enabled }, { autoheight: n.autoHeight }, { rtl: r }, { grid: n.grid && n.grid.rows > 1 }, { "grid-column": n.grid && n.grid.rows > 1 && n.grid.fill === "column" }, { android: s.android }, { ios: s.ios }, { "css-mode": n.cssMode }, { centered: n.cssMode && n.centeredSlides }, { "watch-progress": n.watchSlidesProgress }], n.containerModifierClass); e.push(...o), i.classList.add(...e), t.emitContainerClasses() } function ZP() { const t = this, { el: e, classNames: n } = t; !e || typeof e == "string" || (e.classList.remove(...n), t.emitContainerClasses()) } var eI = { addClasses: QP, removeClasses: ZP }; function tI() { const t = this, { isLocked: e, params: n } = t, { slidesOffsetBefore: r } = n; if (r) { const i = t.slides.length - 1, s = t.slidesGrid[i] + t.slidesSizesGrid[i] + r * 2; t.isLocked = t.size > s } else t.isLocked = t.snapGrid.length === 1; n.allowSlideNext === !0 && (t.allowSlideNext = !t.isLocked), n.allowSlidePrev === !0 && (t.allowSlidePrev = !t.isLocked), e && e !== t.isLocked && (t.isEnd = !1), e !== t.isLocked && t.emit(t.isLocked ? "lock" : "unlock") } var nI = { checkOverflow: tI }, ld = { init: !0, direction: "horizontal", oneWayMovement: !1, swiperElementNodeName: "SWIPER-CONTAINER", touchEventsTarget: "wrapper", initialSlide: 0, speed: 300, cssMode: !1, updateOnWindowResize: !0, resizeObserver: !0, nested: !1, createElements: !1, eventsPrefix: "swiper", enabled: !0, focusableElements: "input, select, option, textarea, button, video, label", width: null, height: null, preventInteractionOnTransition: !1, userAgent: null, url: null, edgeSwipeDetection: !1, edgeSwipeThreshold: 20, autoHeight: !1, setWrapperSize: !1, virtualTranslate: !1, effect: "slide", breakpoints: void 0, breakpointsBase: "window", spaceBetween: 0, slidesPerView: 1, slidesPerGroup: 1, slidesPerGroupSkip: 0, slidesPerGroupAuto: !1, centeredSlides: !1, centeredSlidesBounds: !1, slidesOffsetBefore: 0, slidesOffsetAfter: 0, normalizeSlideIndex: !0, centerInsufficientSlides: !1, watchOverflow: !0, roundLengths: !1, touchRatio: 1, touchAngle: 45, simulateTouch: !0, shortSwipes: !0, longSwipes: !0, longSwipesRatio: .5, longSwipesMs: 300, followFinger: !0, allowTouchMove: !0, threshold: 5, touchMoveStopPropagation: !1, touchStartPreventDefault: !0, touchStartForcePreventDefault: !1, touchReleaseOnEdges: !1, uniqueNavElements: !0, resistance: !0, resistanceRatio: .85, watchSlidesProgress: !1, grabCursor: !1, preventClicks: !0, preventClicksPropagation: !0, slideToClickedSlide: !1, loop: !1, loopAddBlankSlides: !0, loopAdditionalSlides: 0, loopPreventsSliding: !0, rewind: !1, allowSlidePrev: !0, allowSlideNext: !0, swipeHandler: null, noSwiping: !0, noSwipingClass: "swiper-no-swiping", noSwipingSelector: null, passiveListeners: !0, maxBackfaceHiddenSlides: 10, containerModifierClass: "swiper-", slideClass: "swiper-slide", slideBlankClass: "swiper-slide-blank", slideActiveClass: "swiper-slide-active", slideVisibleClass: "swiper-slide-visible", slideFullyVisibleClass: "swiper-slide-fully-visible", slideNextClass: "swiper-slide-next", slidePrevClass: "swiper-slide-prev", wrapperClass: "swiper-wrapper", lazyPreloaderClass: "swiper-lazy-preloader", lazyPreloadPrevNext: 0, runCallbacksOnInit: !0, _emitClasses: !1 }; function rI(t, e) { return function (r) { r === void 0 && (r = {}); const i = Object.keys(r)[0], s = r[i]; if (typeof s != "object" || s === null) { ft(e, r); return } if (t[i] === !0 && (t[i] = { enabled: !0 }), i === "navigation" && t[i] && t[i].enabled && !t[i].prevEl && !t[i].nextEl && (t[i].auto = !0), ["pagination", "scrollbar"].indexOf(i) >= 0 && t[i] && t[i].enabled && !t[i].el && (t[i].auto = !0), !(i in t && "enabled" in s)) { ft(e, r); return } typeof t[i] == "object" && !("enabled" in t[i]) && (t[i].enabled = !0), t[i] || (t[i] = { enabled: !1 }), ft(e, r) } } const Uc = { eventsEmitter: eP, update: dP, translate: vP, transition: SP, slide: kP, loop: jP, grabCursor: DP, events: KP, breakpoints: JP, checkOverflow: nI, classes: eI }, zc = {}; let Uf = class sn { constructor() { let e, n; for (var r = arguments.length, i = new Array(r), s = 0; s < r; s++)i[s] = arguments[s]; i.length === 1 && i[0].constructor && Object.prototype.toString.call(i[0]).slice(8, -1) === "Object" ? n = i[0] : [e, n] = i, n || (n = {}), n = ft({}, n), e && !n.el && (n.el = e); const o = vn(); if (n.el && typeof n.el == "string" && o.querySelectorAll(n.el).length > 1) { const u = []; return o.querySelectorAll(n.el).forEach(f => { const h = ft({}, n, { el: f }); u.push(new sn(h)) }), u } const l = this; l.__swiper__ = !0, l.support = g0(), l.device = v0({ userAgent: n.userAgent }), l.browser = X2(), l.eventsListeners = {}, l.eventsAnyListeners = [], l.modules = [...l.__modules__], n.modules && Array.isArray(n.modules) && l.modules.push(...n.modules); const a = {}; l.modules.forEach(u => { u({ params: n, swiper: l, extendParams: rI(n, a), on: l.on.bind(l), once: l.once.bind(l), off: l.off.bind(l), emit: l.emit.bind(l) }) }); const c = ft({}, ld, a); return l.params = ft({}, c, zc, n), l.originalParams = ft({}, l.params), l.passedParams = ft({}, n), l.params && l.params.on && Object.keys(l.params.on).forEach(u => { l.on(u, l.params.on[u]) }), l.params && l.params.onAny && l.onAny(l.params.onAny), Object.assign(l, { enabled: l.params.enabled, el: e, classNames: [], slides: [], slidesGrid: [], snapGrid: [], slidesSizesGrid: [], isHorizontal() { return l.params.direction === "horizontal" }, isVertical() { return l.params.direction === "vertical" }, activeIndex: 0, realIndex: 0, isBeginning: !0, isEnd: !1, translate: 0, previousTranslate: 0, progress: 0, velocity: 0, animating: !1, cssOverflowAdjustment() { return Math.trunc(this.translate / 2 ** 23) * 2 ** 23 }, allowSlideNext: l.params.allowSlideNext, allowSlidePrev: l.params.allowSlidePrev, touchEventsData: { isTouched: void 0, isMoved: void 0, allowTouchCallbacks: void 0, touchStartTime: void 0, isScrolling: void 0, currentTranslate: void 0, startTranslate: void 0, allowThresholdMove: void 0, focusableElements: l.params.focusableElements, lastClickTime: 0, clickTimeout: void 0, velocities: [], allowMomentumBounce: void 0, startMoving: void 0, pointerId: null, touchId: null }, allowClick: !0, allowTouchMove: l.params.allowTouchMove, touches: { startX: 0, startY: 0, currentX: 0, currentY: 0, diff: 0 }, imagesToLoad: [], imagesLoaded: 0 }), l.emit("_swiper"), l.params.init && l.init(), l } getDirectionLabel(e) { return this.isHorizontal() ? e : { width: "height", "margin-top": "margin-left", "margin-bottom ": "margin-right", "margin-left": "margin-top", "margin-right": "margin-bottom", "padding-left": "padding-top", "padding-right": "padding-bottom", marginRight: "marginBottom" }[e] } getSlideIndex(e) { const { slidesEl: n, params: r } = this, i = qt(n, `.${r.slideClass}, swiper-slide`), s = ul(i[0]); return ul(e) - s } getSlideIndexByData(e) { return this.getSlideIndex(this.slides.filter(n => n.getAttribute("data-swiper-slide-index") * 1 === e)[0]) } recalcSlides() { const e = this, { slidesEl: n, params: r } = e; e.slides = qt(n, `.${r.slideClass}, swiper-slide`) } enable() { const e = this; e.enabled || (e.enabled = !0, e.params.grabCursor && e.setGrabCursor(), e.emit("enable")) } disable() { const e = this; e.enabled && (e.enabled = !1, e.params.grabCursor && e.unsetGrabCursor(), e.emit("disable")) } setProgress(e, n) { const r = this; e = Math.min(Math.max(e, 0), 1); const i = r.minTranslate(), o = (r.maxTranslate() - i) * e + i; r.translateTo(o, typeof n > "u" ? 0 : n), r.updateActiveIndex(), r.updateSlidesClasses() } emitContainerClasses() { const e = this; if (!e.params._emitClasses || !e.el) return; const n = e.el.className.split(" ").filter(r => r.indexOf("swiper") === 0 || r.indexOf(e.params.containerModifierClass) === 0); e.emit("_containerClasses", n.join(" ")) } getSlideClasses(e) { const n = this; return n.destroyed ? "" : e.className.split(" ").filter(r => r.indexOf("swiper-slide") === 0 || r.indexOf(n.params.slideClass) === 0).join(" ") } emitSlidesClasses() { const e = this; if (!e.params._emitClasses || !e.el) return; const n = []; e.slides.forEach(r => { const i = e.getSlideClasses(r); n.push({ slideEl: r, classNames: i }), e.emit("_slideClass", r, i) }), e.emit("_slideClasses", n) } slidesPerViewDynamic(e, n) { e === void 0 && (e = "current"), n === void 0 && (n = !1); const r = this, { params: i, slides: s, slidesGrid: o, slidesSizesGrid: l, size: a, activeIndex: c } = r; let u = 1; if (typeof i.slidesPerView == "number") return i.slidesPerView; if (i.centeredSlides) { let f = s[c] ? Math.ceil(s[c].swiperSlideSize) : 0, h; for (let y = c + 1; y < s.length; y += 1)s[y] && !h && (f += Math.ceil(s[y].swiperSlideSize), u += 1, f > a && (h = !0)); for (let y = c - 1; y >= 0; y -= 1)s[y] && !h && (f += s[y].swiperSlideSize, u += 1, f > a && (h = !0)) } else if (e === "current") for (let f = c + 1; f < s.length; f += 1)(n ? o[f] + l[f] - o[c] < a : o[f] - o[c] < a) && (u += 1); else for (let f = c - 1; f >= 0; f -= 1)o[c] - o[f] < a && (u += 1); return u } update() { const e = this; if (!e || e.destroyed) return; const { snapGrid: n, params: r } = e; r.breakpoints && e.setBreakpoint(), [...e.el.querySelectorAll('[loading="lazy"]')].forEach(o => { o.complete && ya(e, o) }), e.updateSize(), e.updateSlides(), e.updateProgress(), e.updateSlidesClasses(); function i() { const o = e.rtlTranslate ? e.translate * -1 : e.translate, l = Math.min(Math.max(o, e.maxTranslate()), e.minTranslate()); e.setTranslate(l), e.updateActiveIndex(), e.updateSlidesClasses() } let s; if (r.freeMode && r.freeMode.enabled && !r.cssMode) i(), r.autoHeight && e.updateAutoHeight(); else { if ((r.slidesPerView === "auto" || r.slidesPerView > 1) && e.isEnd && !r.centeredSlides) { const o = e.virtual && r.virtual.enabled ? e.virtual.slides : e.slides; s = e.slideTo(o.length - 1, 0, !1, !0) } else s = e.slideTo(e.activeIndex, 0, !1, !0); s || i() } r.watchOverflow && n !== e.snapGrid && e.checkOverflow(), e.emit("update") } changeDirection(e, n) { n === void 0 && (n = !0); const r = this, i = r.params.direction; return e || (e = i === "horizontal" ? "vertical" : "horizontal"), e === i || e !== "horizontal" && e !== "vertical" || (r.el.classList.remove(`${r.params.containerModifierClass}${i}`), r.el.classList.add(`${r.params.containerModifierClass}${e}`), r.emitContainerClasses(), r.params.direction = e, r.slides.forEach(s => { e === "vertical" ? s.style.width = "" : s.style.height = "" }), r.emit("changeDirection"), n && r.update()), r } changeLanguageDirection(e) { const n = this; n.rtl && e === "rtl" || !n.rtl && e === "ltr" || (n.rtl = e === "rtl", n.rtlTranslate = n.params.direction === "horizontal" && n.rtl, n.rtl ? (n.el.classList.add(`${n.params.containerModifierClass}rtl`), n.el.dir = "rtl") : (n.el.classList.remove(`${n.params.containerModifierClass}rtl`), n.el.dir = "ltr"), n.update()) } mount(e) { const n = this; if (n.mounted) return !0; let r = e || n.params.el; if (typeof r == "string" && (r = document.querySelector(r)), !r) return !1; r.swiper = n, r.parentNode && r.parentNode.host && r.parentNode.host.nodeName === n.params.swiperElementNodeName.toUpperCase() && (n.isElement = !0); const i = () => `.${(n.params.wrapperClass || "").trim().split(" ").join(".")}`; let o = r && r.shadowRoot && r.shadowRoot.querySelector ? r.shadowRoot.querySelector(i()) : qt(r, i())[0]; return !o && n.params.createElements && (o = cl("div", n.params.wrapperClass), r.append(o), qt(r, `.${n.params.slideClass}`).forEach(l => { o.append(l) })), Object.assign(n, { el: r, wrapperEl: o, slidesEl: n.isElement && !r.parentNode.host.slideSlots ? r.parentNode.host : o, hostEl: n.isElement ? r.parentNode.host : r, mounted: !0, rtl: r.dir.toLowerCase() === "rtl" || qn(r, "direction") === "rtl", rtlTranslate: n.params.direction === "horizontal" && (r.dir.toLowerCase() === "rtl" || qn(r, "direction") === "rtl"), wrongRTL: qn(o, "display") === "-webkit-box" }), !0 } init(e) { const n = this; if (n.initialized || n.mount(e) === !1) return n; n.emit("beforeInit"), n.params.breakpoints && n.setBreakpoint(), n.addClasses(), n.updateSize(), n.updateSlides(), n.params.watchOverflow && n.checkOverflow(), n.params.grabCursor && n.enabled && n.setGrabCursor(), n.params.loop && n.virtual && n.params.virtual.enabled ? n.slideTo(n.params.initialSlide + n.virtual.slidesBefore, 0, n.params.runCallbacksOnInit, !1, !0) : n.slideTo(n.params.initialSlide, 0, n.params.runCallbacksOnInit, !1, !0), n.params.loop && n.loopCreate(), n.attachEvents(); const i = [...n.el.querySelectorAll('[loading="lazy"]')]; return n.isElement && i.push(...n.hostEl.querySelectorAll('[loading="lazy"]')), i.forEach(s => { s.complete ? ya(n, s) : s.addEventListener("load", o => { ya(n, o.target) }) }), ad(n), n.initialized = !0, ad(n), n.emit("init"), n.emit("afterInit"), n } destroy(e, n) { e === void 0 && (e = !0), n === void 0 && (n = !0); const r = this, { params: i, el: s, wrapperEl: o, slides: l } = r; return typeof r.params > "u" || r.destroyed || (r.emit("beforeDestroy"), r.initialized = !1, r.detachEvents(), i.loop && r.loopDestroy(), n && (r.removeClasses(), s && typeof s != "string" && s.removeAttribute("style"), o && o.removeAttribute("style"), l && l.length && l.forEach(a => { a.classList.remove(i.slideVisibleClass, i.slideFullyVisibleClass, i.slideActiveClass, i.slideNextClass, i.slidePrevClass), a.removeAttribute("style"), a.removeAttribute("data-swiper-slide-index") })), r.emit("destroy"), Object.keys(r.eventsListeners).forEach(a => { r.off(a) }), e !== !1 && (r.el && typeof r.el != "string" && (r.el.swiper = null), $2(r)), r.destroyed = !0), null } static extendDefaults(e) { ft(zc, e) } static get extendedDefaults() { return zc } static get defaults() { return ld } static installModule(e) { sn.prototype.__modules__ || (sn.prototype.__modules__ = []); const n = sn.prototype.__modules__; typeof e == "function" && n.indexOf(e) < 0 && n.push(e) } static use(e) { return Array.isArray(e) ? (e.forEach(n => sn.installModule(n)), sn) : (sn.installModule(e), sn) } }; Object.keys(Uc).forEach(t => { Object.keys(Uc[t]).forEach(e => { Uf.prototype[e] = Uc[t][e] }) }); Uf.use([Q2, Z2]); const x0 = ["eventsPrefix", "injectStyles", "injectStylesUrls", "modules", "init", "_direction", "oneWayMovement", "swiperElementNodeName", "touchEventsTarget", "initialSlide", "_speed", "cssMode", "updateOnWindowResize", "resizeObserver", "nested", "focusableElements", "_enabled", "_width", "_height", "preventInteractionOnTransition", "userAgent", "url", "_edgeSwipeDetection", "_edgeSwipeThreshold", "_freeMode", "_autoHeight", "setWrapperSize", "virtualTranslate", "_effect", "breakpoints", "breakpointsBase", "_spaceBetween", "_slidesPerView", "maxBackfaceHiddenSlides", "_grid", "_slidesPerGroup", "_slidesPerGroupSkip", "_slidesPerGroupAuto", "_centeredSlides", "_centeredSlidesBounds", "_slidesOffsetBefore", "_slidesOffsetAfter", "normalizeSlideIndex", "_centerInsufficientSlides", "_watchOverflow", "roundLengths", "touchRatio", "touchAngle", "simulateTouch", "_shortSwipes", "_longSwipes", "longSwipesRatio", "longSwipesMs", "_followFinger", "allowTouchMove", "_threshold", "touchMoveStopPropagation", "touchStartPreventDefault", "touchStartForcePreventDefault", "touchReleaseOnEdges", "uniqueNavElements", "_resistance", "_resistanceRatio", "_watchSlidesProgress", "_grabCursor", "preventClicks", "preventClicksPropagation", "_slideToClickedSlide", "_loop", "loopAdditionalSlides", "loopAddBlankSlides", "loopPreventsSliding", "_rewind", "_allowSlidePrev", "_allowSlideNext", "_swipeHandler", "_noSwiping", "noSwipingClass", "noSwipingSelector", "passiveListeners", "containerModifierClass", "slideClass", "slideActiveClass", "slideVisibleClass", "slideFullyVisibleClass", "slideNextClass", "slidePrevClass", "slideBlankClass", "wrapperClass", "lazyPreloaderClass", "lazyPreloadPrevNext", "runCallbacksOnInit", "observer", "observeParents", "observeSlideChildren", "a11y", "_autoplay", "_controller", "coverflowEffect", "cubeEffect", "fadeEffect", "flipEffect", "creativeEffect", "cardsEffect", "hashNavigation", "history", "keyboard", "mousewheel", "_navigation", "_pagination", "parallax", "_scrollbar", "_thumbs", "virtual", "zoom", "control"]; function Hr(t) { return typeof t == "object" && t !== null && t.constructor && Object.prototype.toString.call(t).slice(8, -1) === "Object" && !t.__swiper__ } function Pi(t, e) { const n = ["__proto__", "constructor", "prototype"]; Object.keys(e).filter(r => n.indexOf(r) < 0).forEach(r => { typeof t[r] > "u" ? t[r] = e[r] : Hr(e[r]) && Hr(t[r]) && Object.keys(e[r]).length > 0 ? e[r].__swiper__ ? t[r] = e[r] : Pi(t[r], e[r]) : t[r] = e[r] }) } function S0(t) { return t === void 0 && (t = {}), t.navigation && typeof t.navigation.nextEl > "u" && typeof t.navigation.prevEl > "u" } function E0(t) { return t === void 0 && (t = {}), t.pagination && typeof t.pagination.el > "u" } function b0(t) { return t === void 0 && (t = {}), t.scrollbar && typeof t.scrollbar.el > "u" } function T0(t) { t === void 0 && (t = ""); const e = t.split(" ").map(r => r.trim()).filter(r => !!r), n = []; return e.forEach(r => { n.indexOf(r) < 0 && n.push(r) }), n.join(" ") } function iI(t) { return t === void 0 && (t = ""), t ? t.includes("swiper-wrapper") ? t : `swiper-wrapper ${t}` : "swiper-wrapper" } function sI(t) { let { swiper: e, slides: n, passedParams: r, changedParams: i, nextEl: s, prevEl: o, scrollbarEl: l, paginationEl: a } = t; const c = i.filter(N => N !== "children" && N !== "direction" && N !== "wrapperClass"), { params: u, pagination: f, navigation: h, scrollbar: y, virtual: g, thumbs: w } = e; let E, v, p, m, S, T, x, P; i.includes("thumbs") && r.thumbs && r.thumbs.swiper && !r.thumbs.swiper.destroyed && u.thumbs && (!u.thumbs.swiper || u.thumbs.swiper.destroyed) && (E = !0), i.includes("controller") && r.controller && r.controller.control && u.controller && !u.controller.control && (v = !0), i.includes("pagination") && r.pagination && (r.pagination.el || a) && (u.pagination || u.pagination === !1) && f && !f.el && (p = !0), i.includes("scrollbar") && r.scrollbar && (r.scrollbar.el || l) && (u.scrollbar || u.scrollbar === !1) && y && !y.el && (m = !0), i.includes("navigation") && r.navigation && (r.navigation.prevEl || o) && (r.navigation.nextEl || s) && (u.navigation || u.navigation === !1) && h && !h.prevEl && !h.nextEl && (S = !0); const I = N => { e[N] && (e[N].destroy(), N === "navigation" ? (e.isElement && (e[N].prevEl.remove(), e[N].nextEl.remove()), u[N].prevEl = void 0, u[N].nextEl = void 0, e[N].prevEl = void 0, e[N].nextEl = void 0) : (e.isElement && e[N].el.remove(), u[N].el = void 0, e[N].el = void 0)) }; i.includes("loop") && e.isElement && (u.loop && !r.loop ? T = !0 : !u.loop && r.loop ? x = !0 : P = !0), c.forEach(N => { if (Hr(u[N]) && Hr(r[N])) Object.assign(u[N], r[N]), (N === "navigation" || N === "pagination" || N === "scrollbar") && "enabled" in r[N] && !r[N].enabled && I(N); else { const k = r[N]; (k === !0 || k === !1) && (N === "navigation" || N === "pagination" || N === "scrollbar") ? k === !1 && I(N) : u[N] = r[N] } }), c.includes("controller") && !v && e.controller && e.controller.control && u.controller && u.controller.control && (e.controller.control = u.controller.control), i.includes("children") && n && g && u.virtual.enabled ? (g.slides = n, g.update(!0)) : i.includes("virtual") && g && u.virtual.enabled && (n && (g.slides = n), g.update(!0)), i.includes("children") && n && u.loop && (P = !0), E && w.init() && w.update(!0), v && (e.controller.control = u.controller.control), p && (e.isElement && (!a || typeof a == "string") && (a = document.createElement("div"), a.classList.add("swiper-pagination"), a.part.add("pagination"), e.el.appendChild(a)), a && (u.pagination.el = a), f.init(), f.render(), f.update()), m && (e.isElement && (!l || typeof l == "string") && (l = document.createElement("div"), l.classList.add("swiper-scrollbar"), l.part.add("scrollbar"), e.el.appendChild(l)), l && (u.scrollbar.el = l), y.init(), y.updateSize(), y.setTranslate()), S && (e.isElement && ((!s || typeof s == "string") && (s = document.createElement("div"), s.classList.add("swiper-button-next"), s.innerHTML = e.hostEl.constructor.nextButtonSvg, s.part.add("button-next"), e.el.appendChild(s)), (!o || typeof o == "string") && (o = document.createElement("div"), o.classList.add("swiper-button-prev"), o.innerHTML = e.hostEl.constructor.prevButtonSvg, o.part.add("button-prev"), e.el.appendChild(o))), s && (u.navigation.nextEl = s), o && (u.navigation.prevEl = o), h.init(), h.update()), i.includes("allowSlideNext") && (e.allowSlideNext = r.allowSlideNext), i.includes("allowSlidePrev") && (e.allowSlidePrev = r.allowSlidePrev), i.includes("direction") && e.changeDirection(r.direction, !1), (T || P) && e.loopDestroy(), (x || P) && e.loopCreate(), e.update() } function oI(t, e) { t === void 0 && (t = {}), e === void 0 && (e = !0); const n = { on: {} }, r = {}, i = {}; Pi(n, ld), n._emitClasses = !0, n.init = !1; const s = {}, o = x0.map(a => a.replace(/_/, "")), l = Object.assign({}, t); return Object.keys(l).forEach(a => { typeof t[a] > "u" || (o.indexOf(a) >= 0 ? Hr(t[a]) ? (n[a] = {}, i[a] = {}, Pi(n[a], t[a]), Pi(i[a], t[a])) : (n[a] = t[a], i[a] = t[a]) : a.search(/on[A-Z]/) === 0 && typeof t[a] == "function" ? e ? r[`${a[2].toLowerCase()}${a.substr(3)}`] = t[a] : n.on[`${a[2].toLowerCase()}${a.substr(3)}`] = t[a] : s[a] = t[a]) }), ["navigation", "pagination", "scrollbar"].forEach(a => { n[a] === !0 && (n[a] = {}), n[a] === !1 && delete n[a] }), { params: n, passedParams: i, rest: s, events: r } } function aI(t, e) { let { el: n, nextEl: r, prevEl: i, paginationEl: s, scrollbarEl: o, swiper: l } = t; S0(e) && r && i && (l.params.navigation.nextEl = r, l.originalParams.navigation.nextEl = r, l.params.navigation.prevEl = i, l.originalParams.navigation.prevEl = i), E0(e) && s && (l.params.pagination.el = s, l.originalParams.pagination.el = s), b0(e) && o && (l.params.scrollbar.el = o, l.originalParams.scrollbar.el = o), l.init(n) } function lI(t, e, n, r, i) { const s = []; if (!e) return s; const o = a => { s.indexOf(a) < 0 && s.push(a) }; if (n && r) { const a = r.map(i), c = n.map(i); a.join("") !== c.join("") && o("children"), r.length !== n.length && o("children") } return x0.filter(a => a[0] === "_").map(a => a.replace(/_/, "")).forEach(a => { if (a in t && a in e) if (Hr(t[a]) && Hr(e[a])) { const c = Object.keys(t[a]), u = Object.keys(e[a]); c.length !== u.length ? o(a) : (c.forEach(f => { t[a][f] !== e[a][f] && o(a) }), u.forEach(f => { t[a][f] !== e[a][f] && o(a) })) } else t[a] !== e[a] && o(a) }), s } const cI = t => { !t || t.destroyed || !t.params.virtual || t.params.virtual && !t.params.virtual.enabled || (t.updateSlides(), t.updateProgress(), t.updateSlidesClasses(), t.parallax && t.params.parallax && t.params.parallax.enabled && t.parallax.setTranslate()) }; function dl() { return dl = Object.assign ? Object.assign.bind() : function (t) { for (var e = 1; e < arguments.length; e++) { var n = arguments[e]; for (var r in n) Object.prototype.hasOwnProperty.call(n, r) && (t[r] = n[r]) } return t }, dl.apply(this, arguments) } function C0(t) { return t.type && t.type.displayName && t.type.displayName.includes("SwiperSlide") } function _0(t) { const e = []; return ce.Children.toArray(t).forEach(n => { C0(n) ? e.push(n) : n.props && n.props.children && _0(n.props.children).forEach(r => e.push(r)) }), e } function uI(t) { const e = [], n = { "container-start": [], "container-end": [], "wrapper-start": [], "wrapper-end": [] }; return ce.Children.toArray(t).forEach(r => { if (C0(r)) e.push(r); else if (r.props && r.props.slot && n[r.props.slot]) n[r.props.slot].push(r); else if (r.props && r.props.children) { const i = _0(r.props.children); i.length > 0 ? i.forEach(s => e.push(s)) : n["container-end"].push(r) } else n["container-end"].push(r) }), { slides: e, slots: n } } function dI(t, e, n) { if (!n) return null; const r = u => { let f = u; return u < 0 ? f = e.length + u : f >= e.length && (f = f - e.length), f }, i = t.isHorizontal() ? { [t.rtlTranslate ? "right" : "left"]: `${n.offset}px` } : { top: `${n.offset}px` }, { from: s, to: o } = n, l = t.params.loop ? -e.length : 0, a = t.params.loop ? e.length * 2 : e.length, c = []; for (let u = l; u < a; u += 1)u >= s && u <= o && c.push(e[r(u)]); return c.map((u, f) => ce.cloneElement(u, { swiper: t, style: i, key: u.props.virtualIndex || u.key || `slide-${f}` })) } function js(t, e) { return typeof window > "u" ? b.useEffect(t, e) : b.useLayoutEffect(t, e) } const vm = b.createContext(null), fI = b.createContext(null), P0 = b.forwardRef(function (t, e) { let { className: n, tag: r = "div", wrapperTag: i = "div", children: s, onSwiper: o, ...l } = t === void 0 ? {} : t, a = !1; const [c, u] = b.useState("swiper"), [f, h] = b.useState(null), [y, g] = b.useState(!1), w = b.useRef(!1), E = b.useRef(null), v = b.useRef(null), p = b.useRef(null), m = b.useRef(null), S = b.useRef(null), T = b.useRef(null), x = b.useRef(null), P = b.useRef(null), { params: I, passedParams: N, rest: k, events: j } = oI(l), { slides: F, slots: D } = uI(s), B = () => { g(!y) }; Object.assign(I.on, { _containerClasses(U, z) { u(z) } }); const J = () => { Object.assign(I.on, j), a = !0; const U = { ...I }; if (delete U.wrapperClass, v.current = new Uf(U), v.current.virtual && v.current.params.virtual.enabled) { v.current.virtual.slides = F; const z = { cache: !1, slides: F, renderExternal: h, renderExternalUpdate: !1 }; Pi(v.current.params.virtual, z), Pi(v.current.originalParams.virtual, z) } }; E.current || J(), v.current && v.current.on("_beforeBreakpoint", B); const de = () => { a || !j || !v.current || Object.keys(j).forEach(U => { v.current.on(U, j[U]) }) }, pe = () => { !j || !v.current || Object.keys(j).forEach(U => { v.current.off(U, j[U]) }) }; b.useEffect(() => () => { v.current && v.current.off("_beforeBreakpoint", B) }), b.useEffect(() => { !w.current && v.current && (v.current.emitSlidesClasses(), w.current = !0) }), js(() => { if (e && (e.current = E.current), !!E.current) return v.current.destroyed && J(), aI({ el: E.current, nextEl: S.current, prevEl: T.current, paginationEl: x.current, scrollbarEl: P.current, swiper: v.current }, I), o && !v.current.destroyed && o(v.current), () => { v.current && !v.current.destroyed && v.current.destroy(!0, !1) } }, []), js(() => { de(); const U = lI(N, p.current, F, m.current, z => z.key); return p.current = N, m.current = F, U.length && v.current && !v.current.destroyed && sI({ swiper: v.current, slides: F, passedParams: N, changedParams: U, nextEl: S.current, prevEl: T.current, scrollbarEl: P.current, paginationEl: x.current }), () => { pe() } }), js(() => { cI(v.current) }, [f]); function A() { return I.virtual ? dI(v.current, F, f) : F.map((U, z) => ce.cloneElement(U, { swiper: v.current, swiperSlideIndex: z })) } return ce.createElement(r, dl({ ref: E, className: T0(`${c}${n ? ` ${n}` : ""}`) }, k), ce.createElement(fI.Provider, { value: v.current }, D["container-start"], ce.createElement(i, { className: iI(I.wrapperClass) }, D["wrapper-start"], A(), D["wrapper-end"]), S0(I) && ce.createElement(ce.Fragment, null, ce.createElement("div", { ref: T, className: "swiper-button-prev" }), ce.createElement("div", { ref: S, className: "swiper-button-next" })), b0(I) && ce.createElement("div", { ref: P, className: "swiper-scrollbar" }), E0(I) && ce.createElement("div", { ref: x, className: "swiper-pagination" }), D["container-end"])) }); P0.displayName = "Swiper"; const wa = b.forwardRef(function (t, e) { let { tag: n = "div", children: r, className: i = "", swiper: s, zoom: o, lazy: l, virtualIndex: a, swiperSlideIndex: c, ...u } = t === void 0 ? {} : t; const f = b.useRef(null), [h, y] = b.useState("swiper-slide"), [g, w] = b.useState(!1); function E(S, T, x) { T === f.current && y(x) } js(() => { if (typeof c < "u" && (f.current.swiperSlideIndex = c), e && (e.current = f.current), !(!f.current || !s)) { if (s.destroyed) { h !== "swiper-slide" && y("swiper-slide"); return } return s.on("_slideClass", E), () => { s && s.off("_slideClass", E) } } }), js(() => { s && f.current && !s.destroyed && y(s.getSlideClasses(f.current)) }, [s]); const v = { isActive: h.indexOf("swiper-slide-active") >= 0, isVisible: h.indexOf("swiper-slide-visible") >= 0, isPrev: h.indexOf("swiper-slide-prev") >= 0, isNext: h.indexOf("swiper-slide-next") >= 0 }, p = () => typeof r == "function" ? r(v) : r, m = () => { w(!0) }; return ce.createElement(n, dl({ ref: f, className: T0(`${h}${i ? ` ${i}` : ""}`), "data-swiper-slide-index": a, onLoad: m }, u), o && ce.createElement(vm.Provider, { value: v }, ce.createElement("div", { className: "swiper-zoom-container", "data-swiper-zoom": typeof o == "number" ? o : void 0 }, p(), l && !g && ce.createElement("div", { className: "swiper-lazy-preloader" }))), !o && ce.createElement(vm.Provider, { value: v }, p(), l && !g && ce.createElement("div", { className: "swiper-lazy-preloader" }))) }); wa.displayName = "SwiperSlide"; const pI = "/assets/3-Ciy6-tv-.jpg", hI = "/assets/2-mevjjqVR.jpg", mI = "/assets/1-chf1ZcbW.jpg"; function I0(t, e, n, r) { return t.params.createElements && Object.keys(r).forEach(i => { if (!n[i] && n.auto === !0) { let s = qt(t.el, `.${r[i]}`)[0]; s || (s = cl("div", r[i]), s.className = r[i], t.el.append(s)), n[i] = s, e[i] = s } }), n } function gI(t) { let { swiper: e, extendParams: n, on: r, emit: i } = t; n({ navigation: { nextEl: null, prevEl: null, hideOnClick: !1, disabledClass: "swiper-button-disabled", hiddenClass: "swiper-button-hidden", lockClass: "swiper-button-lock", navigationDisabledClass: "swiper-navigation-disabled" } }), e.navigation = { nextEl: null, prevEl: null }; function s(g) { let w; return g && typeof g == "string" && e.isElement && (w = e.el.querySelector(g) || e.hostEl.querySelector(g), w) ? w : (g && (typeof g == "string" && (w = [...document.querySelectorAll(g)]), e.params.uniqueNavElements && typeof g == "string" && w && w.length > 1 && e.el.querySelectorAll(g).length === 1 ? w = e.el.querySelector(g) : w && w.length === 1 && (w = w[0])), g && !w ? g : w) } function o(g, w) { const E = e.params.navigation; g = Ae(g), g.forEach(v => { v && (v.classList[w ? "add" : "remove"](...E.disabledClass.split(" ")), v.tagName === "BUTTON" && (v.disabled = w), e.params.watchOverflow && e.enabled && v.classList[e.isLocked ? "add" : "remove"](E.lockClass)) }) } function l() { const { nextEl: g, prevEl: w } = e.navigation; if (e.params.loop) { o(w, !1), o(g, !1); return } o(w, e.isBeginning && !e.params.rewind), o(g, e.isEnd && !e.params.rewind) } function a(g) { g.preventDefault(), !(e.isBeginning && !e.params.loop && !e.params.rewind) && (e.slidePrev(), i("navigationPrev")) } function c(g) { g.preventDefault(), !(e.isEnd && !e.params.loop && !e.params.rewind) && (e.slideNext(), i("navigationNext")) } function u() { const g = e.params.navigation; if (e.params.navigation = I0(e, e.originalParams.navigation, e.params.navigation, { nextEl: "swiper-button-next", prevEl: "swiper-button-prev" }), !(g.nextEl || g.prevEl)) return; let w = s(g.nextEl), E = s(g.prevEl); Object.assign(e.navigation, { nextEl: w, prevEl: E }), w = Ae(w), E = Ae(E); const v = (p, m) => { p && p.addEventListener("click", m === "next" ? c : a), !e.enabled && p && p.classList.add(...g.lockClass.split(" ")) }; w.forEach(p => v(p, "next")), E.forEach(p => v(p, "prev")) } function f() { let { nextEl: g, prevEl: w } = e.navigation; g = Ae(g), w = Ae(w); const E = (v, p) => { v.removeEventListener("click", p === "next" ? c : a), v.classList.remove(...e.params.navigation.disabledClass.split(" ")) }; g.forEach(v => E(v, "next")), w.forEach(v => E(v, "prev")) } r("init", () => { e.params.navigation.enabled === !1 ? y() : (u(), l()) }), r("toEdge fromEdge lock unlock", () => { l() }), r("destroy", () => { f() }), r("enable disable", () => { let { nextEl: g, prevEl: w } = e.navigation; if (g = Ae(g), w = Ae(w), e.enabled) { l(); return } [...g, ...w].filter(E => !!E).forEach(E => E.classList.add(e.params.navigation.lockClass)) }), r("click", (g, w) => { let { nextEl: E, prevEl: v } = e.navigation; E = Ae(E), v = Ae(v); const p = w.target; let m = v.includes(p) || E.includes(p); if (e.isElement && !m) { const S = w.path || w.composedPath && w.composedPath(); S && (m = S.find(T => E.includes(T) || v.includes(T))) } if (e.params.navigation.hideOnClick && !m) { if (e.pagination && e.params.pagination && e.params.pagination.clickable && (e.pagination.el === p || e.pagination.el.contains(p))) return; let S; E.length ? S = E[0].classList.contains(e.params.navigation.hiddenClass) : v.length && (S = v[0].classList.contains(e.params.navigation.hiddenClass)), i(S === !0 ? "navigationShow" : "navigationHide"), [...E, ...v].filter(T => !!T).forEach(T => T.classList.toggle(e.params.navigation.hiddenClass)) } }); const h = () => { e.el.classList.remove(...e.params.navigation.navigationDisabledClass.split(" ")), u(), l() }, y = () => { e.el.classList.add(...e.params.navigation.navigationDisabledClass.split(" ")), f() }; Object.assign(e.navigation, { enable: h, disable: y, update: l, init: u, destroy: f }) } function us(t) { return t === void 0 && (t = ""), `.${t.trim().replace(/([\.:!+\/])/g, "\\$1").replace(/ /g, ".")}` } function vI(t) { let { swiper: e, extendParams: n, on: r, emit: i } = t; const s = "swiper-pagination"; n({ pagination: { el: null, bulletElement: "span", clickable: !1, hideOnClick: !1, renderBullet: null, renderProgressbar: null, renderFraction: null, renderCustom: null, progressbarOpposite: !1, type: "bullets", dynamicBullets: !1, dynamicMainBullets: 1, formatFractionCurrent: p => p, formatFractionTotal: p => p, bulletClass: `${s}-bullet`, bulletActiveClass: `${s}-bullet-active`, modifierClass: `${s}-`, currentClass: `${s}-current`, totalClass: `${s}-total`, hiddenClass: `${s}-hidden`, progressbarFillClass: `${s}-progressbar-fill`, progressbarOppositeClass: `${s}-progressbar-opposite`, clickableClass: `${s}-clickable`, lockClass: `${s}-lock`, horizontalClass: `${s}-horizontal`, verticalClass: `${s}-vertical`, paginationDisabledClass: `${s}-disabled` } }), e.pagination = { el: null, bullets: [] }; let o, l = 0; function a() { return !e.params.pagination.el || !e.pagination.el || Array.isArray(e.pagination.el) && e.pagination.el.length === 0 } function c(p, m) { const { bulletActiveClass: S } = e.params.pagination; p && (p = p[`${m === "prev" ? "previous" : "next"}ElementSibling`], p && (p.classList.add(`${S}-${m}`), p = p[`${m === "prev" ? "previous" : "next"}ElementSibling`], p && p.classList.add(`${S}-${m}-${m}`))) } function u(p, m, S) { if (p = p % S, m = m % S, m === p + 1) return "next"; if (m === p - 1) return "previous" } function f(p) { const m = p.target.closest(us(e.params.pagination.bulletClass)); if (!m) return; p.preventDefault(); const S = ul(m) * e.params.slidesPerGroup; if (e.params.loop) { if (e.realIndex === S) return; const T = u(e.realIndex, S, e.slides.length); T === "next" ? e.slideNext() : T === "previous" ? e.slidePrev() : e.slideToLoop(S) } else e.slideTo(S) } function h() { const p = e.rtl, m = e.params.pagination; if (a()) return; let S = e.pagination.el; S = Ae(S); let T, x; const P = e.virtual && e.params.virtual.enabled ? e.virtual.slides.length : e.slides.length, I = e.params.loop ? Math.ceil(P / e.params.slidesPerGroup) : e.snapGrid.length; if (e.params.loop ? (x = e.previousRealIndex || 0, T = e.params.slidesPerGroup > 1 ? Math.floor(e.realIndex / e.params.slidesPerGroup) : e.realIndex) : typeof e.snapIndex < "u" ? (T = e.snapIndex, x = e.previousSnapIndex) : (x = e.previousIndex || 0, T = e.activeIndex || 0), m.type === "bullets" && e.pagination.bullets && e.pagination.bullets.length > 0) { const N = e.pagination.bullets; let k, j, F; if (m.dynamicBullets && (o = od(N[0], e.isHorizontal() ? "width" : "height"), S.forEach(D => { D.style[e.isHorizontal() ? "width" : "height"] = `${o * (m.dynamicMainBullets + 4)}px` }), m.dynamicMainBullets > 1 && x !== void 0 && (l += T - (x || 0), l > m.dynamicMainBullets - 1 ? l = m.dynamicMainBullets - 1 : l < 0 && (l = 0)), k = Math.max(T - l, 0), j = k + (Math.min(N.length, m.dynamicMainBullets) - 1), F = (j + k) / 2), N.forEach(D => { const B = [...["", "-next", "-next-next", "-prev", "-prev-prev", "-main"].map(J => `${m.bulletActiveClass}${J}`)].map(J => typeof J == "string" && J.includes(" ") ? J.split(" ") : J).flat(); D.classList.remove(...B) }), S.length > 1) N.forEach(D => { const B = ul(D); B === T ? D.classList.add(...m.bulletActiveClass.split(" ")) : e.isElement && D.setAttribute("part", "bullet"), m.dynamicBullets && (B >= k && B <= j && D.classList.add(...`${m.bulletActiveClass}-main`.split(" ")), B === k && c(D, "prev"), B === j && c(D, "next")) }); else { const D = N[T]; if (D && D.classList.add(...m.bulletActiveClass.split(" ")), e.isElement && N.forEach((B, J) => { B.setAttribute("part", J === T ? "bullet-active" : "bullet") }), m.dynamicBullets) { const B = N[k], J = N[j]; for (let de = k; de <= j; de += 1)N[de] && N[de].classList.add(...`${m.bulletActiveClass}-main`.split(" ")); c(B, "prev"), c(J, "next") } } if (m.dynamicBullets) { const D = Math.min(N.length, m.dynamicMainBullets + 4), B = (o * D - o) / 2 - F * o, J = p ? "right" : "left"; N.forEach(de => { de.style[e.isHorizontal() ? J : "top"] = `${B}px` }) } } S.forEach((N, k) => { if (m.type === "fraction" && (N.querySelectorAll(us(m.currentClass)).forEach(j => { j.textContent = m.formatFractionCurrent(T + 1) }), N.querySelectorAll(us(m.totalClass)).forEach(j => { j.textContent = m.formatFractionTotal(I) })), m.type === "progressbar") { let j; m.progressbarOpposite ? j = e.isHorizontal() ? "vertical" : "horizontal" : j = e.isHorizontal() ? "horizontal" : "vertical"; const F = (T + 1) / I; let D = 1, B = 1; j === "horizontal" ? D = F : B = F, N.querySelectorAll(us(m.progressbarFillClass)).forEach(J => { J.style.transform = `translate3d(0,0,0) scaleX(${D}) scaleY(${B})`, J.style.transitionDuration = `${e.params.speed}ms` }) } m.type === "custom" && m.renderCustom ? (N.innerHTML = m.renderCustom(e, T + 1, I), k === 0 && i("paginationRender", N)) : (k === 0 && i("paginationRender", N), i("paginationUpdate", N)), e.params.watchOverflow && e.enabled && N.classList[e.isLocked ? "add" : "remove"](m.lockClass) }) } function y() { const p = e.params.pagination; if (a()) return; const m = e.virtual && e.params.virtual.enabled ? e.virtual.slides.length : e.grid && e.params.grid.rows > 1 ? e.slides.length / Math.ceil(e.params.grid.rows) : e.slides.length; let S = e.pagination.el; S = Ae(S); let T = ""; if (p.type === "bullets") { let x = e.params.loop ? Math.ceil(m / e.params.slidesPerGroup) : e.snapGrid.length; e.params.freeMode && e.params.freeMode.enabled && x > m && (x = m); for (let P = 0; P < x; P += 1)p.renderBullet ? T += p.renderBullet.call(e, P, p.bulletClass) : T += `<${p.bulletElement} ${e.isElement ? 'part="bullet"' : ""} class="${p.bulletClass}"></${p.bulletElement}>` } p.type === "fraction" && (p.renderFraction ? T = p.renderFraction.call(e, p.currentClass, p.totalClass) : T = `<span class="${p.currentClass}"></span> / <span class="${p.totalClass}"></span>`), p.type === "progressbar" && (p.renderProgressbar ? T = p.renderProgressbar.call(e, p.progressbarFillClass) : T = `<span class="${p.progressbarFillClass}"></span>`), e.pagination.bullets = [], S.forEach(x => { p.type !== "custom" && (x.innerHTML = T || ""), p.type === "bullets" && e.pagination.bullets.push(...x.querySelectorAll(us(p.bulletClass))) }), p.type !== "custom" && i("paginationRender", S[0]) } function g() { e.params.pagination = I0(e, e.originalParams.pagination, e.params.pagination, { el: "swiper-pagination" }); const p = e.params.pagination; if (!p.el) return; let m; typeof p.el == "string" && e.isElement && (m = e.el.querySelector(p.el)), !m && typeof p.el == "string" && (m = [...document.querySelectorAll(p.el)]), m || (m = p.el), !(!m || m.length === 0) && (e.params.uniqueNavElements && typeof p.el == "string" && Array.isArray(m) && m.length > 1 && (m = [...e.el.querySelectorAll(p.el)], m.length > 1 && (m = m.filter(S => m0(S, ".swiper")[0] === e.el)[0])), Array.isArray(m) && m.length === 1 && (m = m[0]), Object.assign(e.pagination, { el: m }), m = Ae(m), m.forEach(S => { p.type === "bullets" && p.clickable && S.classList.add(...(p.clickableClass || "").split(" ")), S.classList.add(p.modifierClass + p.type), S.classList.add(e.isHorizontal() ? p.horizontalClass : p.verticalClass), p.type === "bullets" && p.dynamicBullets && (S.classList.add(`${p.modifierClass}${p.type}-dynamic`), l = 0, p.dynamicMainBullets < 1 && (p.dynamicMainBullets = 1)), p.type === "progressbar" && p.progressbarOpposite && S.classList.add(p.progressbarOppositeClass), p.clickable && S.addEventListener("click", f), e.enabled || S.classList.add(p.lockClass) })) } function w() { const p = e.params.pagination; if (a()) return; let m = e.pagination.el; m && (m = Ae(m), m.forEach(S => { S.classList.remove(p.hiddenClass), S.classList.remove(p.modifierClass + p.type), S.classList.remove(e.isHorizontal() ? p.horizontalClass : p.verticalClass), p.clickable && (S.classList.remove(...(p.clickableClass || "").split(" ")), S.removeEventListener("click", f)) })), e.pagination.bullets && e.pagination.bullets.forEach(S => S.classList.remove(...p.bulletActiveClass.split(" "))) } r("changeDirection", () => { if (!e.pagination || !e.pagination.el) return; const p = e.params.pagination; let { el: m } = e.pagination; m = Ae(m), m.forEach(S => { S.classList.remove(p.horizontalClass, p.verticalClass), S.classList.add(e.isHorizontal() ? p.horizontalClass : p.verticalClass) }) }), r("init", () => { e.params.pagination.enabled === !1 ? v() : (g(), y(), h()) }), r("activeIndexChange", () => { typeof e.snapIndex > "u" && h() }), r("snapIndexChange", () => { h() }), r("snapGridLengthChange", () => { y(), h() }), r("destroy", () => { w() }), r("enable disable", () => { let { el: p } = e.pagination; p && (p = Ae(p), p.forEach(m => m.classList[e.enabled ? "remove" : "add"](e.params.pagination.lockClass))) }), r("lock unlock", () => { h() }), r("click", (p, m) => { const S = m.target, T = Ae(e.pagination.el); if (e.params.pagination.el && e.params.pagination.hideOnClick && T && T.length > 0 && !S.classList.contains(e.params.pagination.bulletClass)) { if (e.navigation && (e.navigation.nextEl && S === e.navigation.nextEl || e.navigation.prevEl && S === e.navigation.prevEl)) return; const x = T[0].classList.contains(e.params.pagination.hiddenClass); i(x === !0 ? "paginationShow" : "paginationHide"), T.forEach(P => P.classList.toggle(e.params.pagination.hiddenClass)) } }); const E = () => { e.el.classList.remove(e.params.pagination.paginationDisabledClass); let { el: p } = e.pagination; p && (p = Ae(p), p.forEach(m => m.classList.remove(e.params.pagination.paginationDisabledClass))), g(), y(), h() }, v = () => { e.el.classList.add(e.params.pagination.paginationDisabledClass); let { el: p } = e.pagination; p && (p = Ae(p), p.forEach(m => m.classList.add(e.params.pagination.paginationDisabledClass))), w() }; Object.assign(e.pagination, { enable: E, disable: v, render: y, update: h, init: g, destroy: w }) } function yI(t) { let { swiper: e, extendParams: n, on: r, emit: i, params: s } = t; e.autoplay = { running: !1, paused: !1, timeLeft: 0 }, n({ autoplay: { enabled: !1, delay: 3e3, waitForTransition: !0, disableOnInteraction: !1, stopOnLastSlide: !1, reverseDirection: !1, pauseOnMouseEnter: !1 } }); let o, l, a = s && s.autoplay ? s.autoplay.delay : 3e3, c = s && s.autoplay ? s.autoplay.delay : 3e3, u, f = new Date().getTime(), h, y, g, w, E, v, p; function m(A) { !e || e.destroyed || !e.wrapperEl || A.target === e.wrapperEl && (e.wrapperEl.removeEventListener("transitionend", m), !(p || A.detail && A.detail.bySwiperTouchMove) && k()) } const S = () => { if (e.destroyed || !e.autoplay.running) return; e.autoplay.paused ? h = !0 : h && (c = u, h = !1); const A = e.autoplay.paused ? u : f + c - new Date().getTime(); e.autoplay.timeLeft = A, i("autoplayTimeLeft", A, A / a), l = requestAnimationFrame(() => { S() }) }, T = () => { let A; return e.virtual && e.params.virtual.enabled ? A = e.slides.filter(z => z.classList.contains("swiper-slide-active"))[0] : A = e.slides[e.activeIndex], A ? parseInt(A.getAttribute("data-swiper-autoplay"), 10) : void 0 }, x = A => { if (e.destroyed || !e.autoplay.running) return; cancelAnimationFrame(l), S(); let U = typeof A > "u" ? e.params.autoplay.delay : A; a = e.params.autoplay.delay, c = e.params.autoplay.delay; const z = T(); !Number.isNaN(z) && z > 0 && typeof A > "u" && (U = z, a = z, c = z), u = U; const Z = e.params.speed, le = () => { !e || e.destroyed || (e.params.autoplay.reverseDirection ? !e.isBeginning || e.params.loop || e.params.rewind ? (e.slidePrev(Z, !0, !0), i("autoplay")) : e.params.autoplay.stopOnLastSlide || (e.slideTo(e.slides.length - 1, Z, !0, !0), i("autoplay")) : !e.isEnd || e.params.loop || e.params.rewind ? (e.slideNext(Z, !0, !0), i("autoplay")) : e.params.autoplay.stopOnLastSlide || (e.slideTo(0, Z, !0, !0), i("autoplay")), e.params.cssMode && (f = new Date().getTime(), requestAnimationFrame(() => { x() }))) }; return U > 0 ? (clearTimeout(o), o = setTimeout(() => { le() }, U)) : requestAnimationFrame(() => { le() }), U }, P = () => { f = new Date().getTime(), e.autoplay.running = !0, x(), i("autoplayStart") }, I = () => { e.autoplay.running = !1, clearTimeout(o), cancelAnimationFrame(l), i("autoplayStop") }, N = (A, U) => { if (e.destroyed || !e.autoplay.running) return; clearTimeout(o), A || (v = !0); const z = () => { i("autoplayPause"), e.params.autoplay.waitForTransition ? e.wrapperEl.addEventListener("transitionend", m) : k() }; if (e.autoplay.paused = !0, U) { E && (u = e.params.autoplay.delay), E = !1, z(); return } u = (u || e.params.autoplay.delay) - (new Date().getTime() - f), !(e.isEnd && u < 0 && !e.params.loop) && (u < 0 && (u = 0), z()) }, k = () => { e.isEnd && u < 0 && !e.params.loop || e.destroyed || !e.autoplay.running || (f = new Date().getTime(), v ? (v = !1, x(u)) : x(), e.autoplay.paused = !1, i("autoplayResume")) }, j = () => { if (e.destroyed || !e.autoplay.running) return; const A = vn(); A.visibilityState === "hidden" && (v = !0, N(!0)), A.visibilityState === "visible" && k() }, F = A => { A.pointerType === "mouse" && (v = !0, p = !0, !(e.animating || e.autoplay.paused) && N(!0)) }, D = A => { A.pointerType === "mouse" && (p = !1, e.autoplay.paused && k()) }, B = () => { e.params.autoplay.pauseOnMouseEnter && (e.el.addEventListener("pointerenter", F), e.el.addEventListener("pointerleave", D)) }, J = () => { e.el && typeof e.el != "string" && (e.el.removeEventListener("pointerenter", F), e.el.removeEventListener("pointerleave", D)) }, de = () => { vn().addEventListener("visibilitychange", j) }, pe = () => { vn().removeEventListener("visibilitychange", j) }; r("init", () => { e.params.autoplay.enabled && (B(), de(), P()) }), r("destroy", () => { J(), pe(), e.autoplay.running && I() }), r("_freeModeStaticRelease", () => { (g || v) && k() }), r("_freeModeNoMomentumRelease", () => { e.params.autoplay.disableOnInteraction ? I() : N(!0, !0) }), r("beforeTransitionStart", (A, U, z) => { e.destroyed || !e.autoplay.running || (z || !e.params.autoplay.disableOnInteraction ? N(!0, !0) : I()) }), r("sliderFirstMove", () => { if (!(e.destroyed || !e.autoplay.running)) { if (e.params.autoplay.disableOnInteraction) { I(); return } y = !0, g = !1, v = !1, w = setTimeout(() => { v = !0, g = !0, N(!0) }, 200) } }), r("touchEnd", () => { if (!(e.destroyed || !e.autoplay.running || !y)) { if (clearTimeout(w), clearTimeout(o), e.params.autoplay.disableOnInteraction) { g = !1, y = !1; return } g && e.params.cssMode && k(), g = !1, y = !1 } }), r("slideChange", () => { e.destroyed || !e.autoplay.running || (E = !0) }), Object.assign(e.autoplay, { start: P, stop: I, pause: N, resume: k }) } const $c = ({ image: t, text: e }) => d.jsx("div", { className: "w-full bg-center bg-cover h-[38rem]", style: { backgroundImage: `url(${t})` }, children: d.jsx("div", { className: "flex items-center justify-center w-full h-full bg-gray-900/70", children: d.jsxs("div", { className: "text-center", children: [d.jsx("h1", { className: "text-3xl font-semibold text-white lg:text-4xl", children: e }), d.jsx("br", {}), d.jsx(dr, { to: "/add-job", className: "w-full px-5 py-4 mt-4 text-sm font-medium text-white capitalize transition-colors duration-300 transform bg-gray-600 rounded-md lg:w-auto hover:bg-gray-500 focus:outline-none focus:bg-gray-500", children: "Post Job & Hire Expert" })] }) }) }); function wI() { return d.jsx("div", { className: "container px-6 py-10 mx-auto", children: d.jsxs(P0, { spaceBetween: 30, centeredSlides: !0, loop: !0, autoplay: { delay: 5e3, disableOnInteraction: !1 }, pagination: { clickable: !0 }, navigation: !0, modules: [yI, vI, gI], className: "mySwiper", children: [d.jsx(wa, { children: d.jsx($c, { image: mI, text: "Get Your Mobile Service Done in 10 minutes" }) }), d.jsx(wa, { children: d.jsx($c, { image: pI, text: "Motor Servicing Point and Retrailer" }) }), d.jsx(wa, { children: d.jsx($c, { image: hI, text: "Laptop Servicing Center" }) })] }) }) } const xI = "/assets/1-CCOeFOFR.jpg", SI = "/assets/2-B7TQqIFN.jpg", EI = "/assets/3-iHoSxfGV.jpg", bI = () => d.jsxs("div", { children: [d.jsx("h1", { className: "text-center font-bold lg:text-6xl text-3xl m-4 hover:scale-[1.05] transition-all", children: "Meet Our Team Leader" }), d.jsxs("div", { className: "grid lg:grid-cols-3 grid-cols-1 gap-8  p-8 ", children: [d.jsx("div", { className: "card border-2 shadow-2xl border-slate-950 text-center hover:scale-[1.05] transition-all border-white  ", children: d.jsxs("div", { className: "", children: [d.jsx("img", { className: "w-full h-[300px] rounded-t-2xl", src: xI, alt: "" }), d.jsx("h2", { className: "font-bold lg:text-3xl text-2xl  text-center", children: "Kumar Vattacharjee" }), d.jsx("p", { className: "lg:text-2xl text-xl font-medium", children: "Senior Engineer Of Automobile" })] }) }), d.jsx("div", { className: "card shadow-2xl text-center border-2 border-white  hover:scale-[1.05] transition-all", children: d.jsxs("div", { className: "", children: [d.jsx("img", { className: "w-full h-[300px] rounded-t-2xl", src: EI, alt: "" }), d.jsx("h2", { className: "font-bold lg:text-3xl text-2xl  text-center", children: "Alexa Victor " }), d.jsx("p", { className: "lg:text-2xl text-xl font-medium", children: "Head of Motor Department" })] }) }), d.jsx("div", { className: "card shadow-2xl text-center border-2 border-white hover:scale-[1.05] transition-all ", children: d.jsxs("div", { className: "", children: [d.jsx("img", { className: "w-full h-[300px] rounded-t-2xl", src: SI, alt: "" }), d.jsx("h2", { className: "font-bold lg:text-3xl text-2xl  text-center", children: "Rahul Mondol" }), d.jsx("p", { className: "lg:text-2xl text-xl font-medium", children: "Mechanical Engineer  " })] }) })] })] }); var TI = typeof Element < "u", CI = typeof Map == "function", _I = typeof Set == "function", PI = typeof ArrayBuffer == "function" && !!ArrayBuffer.isView; function xa(t, e) { if (t === e) return !0; if (t && e && typeof t == "object" && typeof e == "object") { if (t.constructor !== e.constructor) return !1; var n, r, i; if (Array.isArray(t)) { if (n = t.length, n != e.length) return !1; for (r = n; r-- !== 0;)if (!xa(t[r], e[r])) return !1; return !0 } var s; if (CI && t instanceof Map && e instanceof Map) { if (t.size !== e.size) return !1; for (s = t.entries(); !(r = s.next()).done;)if (!e.has(r.value[0])) return !1; for (s = t.entries(); !(r = s.next()).done;)if (!xa(r.value[1], e.get(r.value[0]))) return !1; return !0 } if (_I && t instanceof Set && e instanceof Set) { if (t.size !== e.size) return !1; for (s = t.entries(); !(r = s.next()).done;)if (!e.has(r.value[0])) return !1; return !0 } if (PI && ArrayBuffer.isView(t) && ArrayBuffer.isView(e)) { if (n = t.length, n != e.length) return !1; for (r = n; r-- !== 0;)if (t[r] !== e[r]) return !1; return !0 } if (t.constructor === RegExp) return t.source === e.source && t.flags === e.flags; if (t.valueOf !== Object.prototype.valueOf && typeof t.valueOf == "function" && typeof e.valueOf == "function") return t.valueOf() === e.valueOf(); if (t.toString !== Object.prototype.toString && typeof t.toString == "function" && typeof e.toString == "function") return t.toString() === e.toString(); if (i = Object.keys(t), n = i.length, n !== Object.keys(e).length) return !1; for (r = n; r-- !== 0;)if (!Object.prototype.hasOwnProperty.call(e, i[r])) return !1; if (TI && t instanceof Element) return !1; for (r = n; r-- !== 0;)if (!((i[r] === "_owner" || i[r] === "__v" || i[r] === "__o") && t.$$typeof) && !xa(t[i[r]], e[i[r]])) return !1; return !0 } return t !== t && e !== e } var II = function (e, n) { try { return xa(e, n) } catch (r) { if ((r.message || "").match(/stack|recursion/i)) return console.warn("react-fast-compare cannot handle circular refs"), !1; throw r } }; const kI = io(II); var NI = function (t, e, n, r, i, s, o, l) { if (!t) { var a; if (e === void 0) a = new Error("Minified exception occurred; use the non-minified dev environment for the full error message and additional helpful warnings."); else { var c = [n, r, i, s, o, l], u = 0; a = new Error(e.replace(/%s/g, function () { return c[u++] })), a.name = "Invariant Violation" } throw a.framesToPop = 1, a } }, RI = NI; const ym = io(RI); var OI = function (e, n, r, i) { var s = r ? r.call(i, e, n) : void 0; if (s !== void 0) return !!s; if (e === n) return !0; if (typeof e != "object" || !e || typeof n != "object" || !n) return !1; var o = Object.keys(e), l = Object.keys(n); if (o.length !== l.length) return !1; for (var a = Object.prototype.hasOwnProperty.bind(n), c = 0; c < o.length; c++) { var u = o[c]; if (!a(u)) return !1; var f = e[u], h = n[u]; if (s = r ? r.call(i, f, h, u) : void 0, s === !1 || s === void 0 && f !== h) return !1 } return !0 }; const jI = io(OI); var k0 = (t => (t.BASE = "base", t.BODY = "body", t.HEAD = "head", t.HTML = "html", t.LINK = "link", t.META = "meta", t.NOSCRIPT = "noscript", t.SCRIPT = "script", t.STYLE = "style", t.TITLE = "title", t.FRAGMENT = "Symbol(react.fragment)", t))(k0 || {}), Bc = { link: { rel: ["amphtml", "canonical", "alternate"] }, script: { type: ["application/ld+json"] }, meta: { charset: "", name: ["generator", "robots", "description"], property: ["og:type", "og:title", "og:url", "og:image", "og:image:alt", "og:description", "twitter:url", "twitter:title", "twitter:description", "twitter:image", "twitter:image:alt", "twitter:card", "twitter:site"] } }, wm = Object.values(k0), zf = { accesskey: "accessKey", charset: "charSet", class: "className", contenteditable: "contentEditable", contextmenu: "contextMenu", "http-equiv": "httpEquiv", itemprop: "itemProp", tabindex: "tabIndex" }, AI = Object.entries(zf).reduce((t, [e, n]) => (t[n] = e, t), {}), Dt = "data-rh", Ii = { DEFAULT_TITLE: "defaultTitle", DEFER: "defer", ENCODE_SPECIAL_CHARACTERS: "encodeSpecialCharacters", ON_CHANGE_CLIENT_STATE: "onChangeClientState", TITLE_TEMPLATE: "titleTemplate", PRIORITIZE_SEO_TAGS: "prioritizeSeoTags" }, ki = (t, e) => { for (let n = t.length - 1; n >= 0; n -= 1) { const r = t[n]; if (Object.prototype.hasOwnProperty.call(r, e)) return r[e] } return null }, LI = t => { let e = ki(t, "title"); const n = ki(t, Ii.TITLE_TEMPLATE); if (Array.isArray(e) && (e = e.join("")), n && e) return n.replace(/%s/g, () => e); const r = ki(t, Ii.DEFAULT_TITLE); return e || r || void 0 }, DI = t => ki(t, Ii.ON_CHANGE_CLIENT_STATE) || (() => { }), Hc = (t, e) => e.filter(n => typeof n[t] < "u").map(n => n[t]).reduce((n, r) => ({ ...n, ...r }), {}), MI = (t, e) => e.filter(n => typeof n.base < "u").map(n => n.base).reverse().reduce((n, r) => { if (!n.length) { const i = Object.keys(r); for (let s = 0; s < i.length; s += 1) { const l = i[s].toLowerCase(); if (t.indexOf(l) !== -1 && r[l]) return n.concat(r) } } return n }, []), FI = t => console && typeof console.warn == "function" && console.warn(t), ds = (t, e, n) => { const r = {}; return n.filter(i => Array.isArray(i[t]) ? !0 : (typeof i[t] < "u" && FI(`Helmet: ${t} should be of type "Array". Instead found type "${typeof i[t]}"`), !1)).map(i => i[t]).reverse().reduce((i, s) => { const o = {}; s.filter(a => { let c; const u = Object.keys(a); for (let h = 0; h < u.length; h += 1) { const y = u[h], g = y.toLowerCase(); e.indexOf(g) !== -1 && !(c === "rel" && a[c].toLowerCase() === "canonical") && !(g === "rel" && a[g].toLowerCase() === "stylesheet") && (c = g), e.indexOf(y) !== -1 && (y === "innerHTML" || y === "cssText" || y === "itemprop") && (c = y) } if (!c || !a[c]) return !1; const f = a[c].toLowerCase(); return r[c] || (r[c] = {}), o[c] || (o[c] = {}), r[c][f] ? !1 : (o[c][f] = !0, !0) }).reverse().forEach(a => i.push(a)); const l = Object.keys(o); for (let a = 0; a < l.length; a += 1) { const c = l[a], u = { ...r[c], ...o[c] }; r[c] = u } return i }, []).reverse() }, UI = (t, e) => { if (Array.isArray(t) && t.length) { for (let n = 0; n < t.length; n += 1)if (t[n][e]) return !0 } return !1 }, zI = t => ({ baseTag: MI(["href"], t), bodyAttributes: Hc("bodyAttributes", t), defer: ki(t, Ii.DEFER), encode: ki(t, Ii.ENCODE_SPECIAL_CHARACTERS), htmlAttributes: Hc("htmlAttributes", t), linkTags: ds("link", ["rel", "href"], t), metaTags: ds("meta", ["name", "charset", "http-equiv", "property", "itemprop"], t), noscriptTags: ds("noscript", ["innerHTML"], t), onChangeClientState: DI(t), scriptTags: ds("script", ["src", "innerHTML"], t), styleTags: ds("style", ["cssText"], t), title: LI(t), titleAttributes: Hc("titleAttributes", t), prioritizeSeoTags: UI(t, Ii.PRIORITIZE_SEO_TAGS) }), N0 = t => Array.isArray(t) ? t.join("") : t, $I = (t, e) => { const n = Object.keys(t); for (let r = 0; r < n.length; r += 1)if (e[n[r]] && e[n[r]].includes(t[n[r]])) return !0; return !1 }, Vc = (t, e) => Array.isArray(t) ? t.reduce((n, r) => ($I(r, e) ? n.priority.push(r) : n.default.push(r), n), { priority: [], default: [] }) : { default: t, priority: [] }, xm = (t, e) => ({ ...t, [e]: void 0 }), BI = ["noscript", "script", "style"], cd = (t, e = !0) => e === !1 ? String(t) : String(t).replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;").replace(/'/g, "&#x27;"), R0 = t => Object.keys(t).reduce((e, n) => { const r = typeof t[n] < "u" ? `${n}="${t[n]}"` : `${n}`; return e ? `${e} ${r}` : r }, ""), HI = (t, e, n, r) => { const i = R0(n), s = N0(e); return i ? `<${t} ${Dt}="true" ${i}>${cd(s, r)}</${t}>` : `<${t} ${Dt}="true">${cd(s, r)}</${t}>` }, VI = (t, e, n = !0) => e.reduce((r, i) => { const s = i, o = Object.keys(s).filter(c => !(c === "innerHTML" || c === "cssText")).reduce((c, u) => { const f = typeof s[u] > "u" ? u : `${u}="${cd(s[u], n)}"`; return c ? `${c} ${f}` : f }, ""), l = s.innerHTML || s.cssText || "", a = BI.indexOf(t) === -1; return `${r}<${t} ${Dt}="true" ${o}${a ? "/>" : `>${l}</${t}>`}` }, ""), O0 = (t, e = {}) => Object.keys(t).reduce((n, r) => { const i = zf[r]; return n[i || r] = t[r], n }, e), WI = (t, e, n) => { const r = { key: e, [Dt]: !0 }, i = O0(n, r); return [ce.createElement("title", i, e)] }, Sa = (t, e) => e.map((n, r) => { const i = { key: r, [Dt]: !0 }; return Object.keys(n).forEach(s => { const l = zf[s] || s; if (l === "innerHTML" || l === "cssText") { const a = n.innerHTML || n.cssText; i.dangerouslySetInnerHTML = { __html: a } } else i[l] = n[s] }), ce.createElement(t, i) }), xt = (t, e, n = !0) => { switch (t) { case "title": return { toComponent: () => WI(t, e.title, e.titleAttributes), toString: () => HI(t, e.title, e.titleAttributes, n) }; case "bodyAttributes": case "htmlAttributes": return { toComponent: () => O0(e), toString: () => R0(e) }; default: return { toComponent: () => Sa(t, e), toString: () => VI(t, e, n) } } }, GI = ({ metaTags: t, linkTags: e, scriptTags: n, encode: r }) => { const i = Vc(t, Bc.meta), s = Vc(e, Bc.link), o = Vc(n, Bc.script); return { priorityMethods: { toComponent: () => [...Sa("meta", i.priority), ...Sa("link", s.priority), ...Sa("script", o.priority)], toString: () => `${xt("meta", i.priority, r)} ${xt("link", s.priority, r)} ${xt("script", o.priority, r)}` }, metaTags: i.default, linkTags: s.default, scriptTags: o.default } }, KI = t => { const { baseTag: e, bodyAttributes: n, encode: r = !0, htmlAttributes: i, noscriptTags: s, styleTags: o, title: l = "", titleAttributes: a, prioritizeSeoTags: c } = t; let { linkTags: u, metaTags: f, scriptTags: h } = t, y = { toComponent: () => { }, toString: () => "" }; return c && ({ priorityMethods: y, linkTags: u, metaTags: f, scriptTags: h } = GI(t)), { priority: y, base: xt("base", e, r), bodyAttributes: xt("bodyAttributes", n, r), htmlAttributes: xt("htmlAttributes", i, r), link: xt("link", u, r), meta: xt("meta", f, r), noscript: xt("noscript", s, r), script: xt("script", h, r), style: xt("style", o, r), title: xt("title", { title: l, titleAttributes: a }, r) } }, ud = KI, Jo = [], j0 = !!(typeof window < "u" && window.document && window.document.createElement), dd = class { constructor(t, e) { nn(this, "instances", []); nn(this, "canUseDOM", j0); nn(this, "context"); nn(this, "value", { setHelmet: t => { this.context.helmet = t }, helmetInstances: { get: () => this.canUseDOM ? Jo : this.instances, add: t => { (this.canUseDOM ? Jo : this.instances).push(t) }, remove: t => { const e = (this.canUseDOM ? Jo : this.instances).indexOf(t); (this.canUseDOM ? Jo : this.instances).splice(e, 1) } } }); this.context = t, this.canUseDOM = e || !1, e || (t.helmet = ud({ baseTag: [], bodyAttributes: {}, encodeSpecialCharacters: !0, htmlAttributes: {}, linkTags: [], metaTags: [], noscriptTags: [], scriptTags: [], styleTags: [], title: "", titleAttributes: {} })) } }, qI = {}, A0 = ce.createContext(qI), Nr, L0 = (Nr = class extends b.Component { constructor(n) { super(n); nn(this, "helmetData"); this.helmetData = new dd(this.props.context || {}, Nr.canUseDOM) } render() { return ce.createElement(A0.Provider, { value: this.helmetData.value }, this.props.children) } }, nn(Nr, "canUseDOM", j0), Nr), ii = (t, e) => { const n = document.head || document.querySelector("head"), r = n.querySelectorAll(`${t}[${Dt}]`), i = [].slice.call(r), s = []; let o; return e && e.length && e.forEach(l => { const a = document.createElement(t); for (const c in l) if (Object.prototype.hasOwnProperty.call(l, c)) if (c === "innerHTML") a.innerHTML = l.innerHTML; else if (c === "cssText") a.styleSheet ? a.styleSheet.cssText = l.cssText : a.appendChild(document.createTextNode(l.cssText)); else { const u = c, f = typeof l[u] > "u" ? "" : l[u]; a.setAttribute(c, f) } a.setAttribute(Dt, "true"), i.some((c, u) => (o = u, a.isEqualNode(c))) ? i.splice(o, 1) : s.push(a) }), i.forEach(l => { var a; return (a = l.parentNode) == null ? void 0 : a.removeChild(l) }), s.forEach(l => n.appendChild(l)), { oldTags: i, newTags: s } }, fd = (t, e) => { const n = document.getElementsByTagName(t)[0]; if (!n) return; const r = n.getAttribute(Dt), i = r ? r.split(",") : [], s = [...i], o = Object.keys(e); for (const l of o) { const a = e[l] || ""; n.getAttribute(l) !== a && n.setAttribute(l, a), i.indexOf(l) === -1 && i.push(l); const c = s.indexOf(l); c !== -1 && s.splice(c, 1) } for (let l = s.length - 1; l >= 0; l -= 1)n.removeAttribute(s[l]); i.length === s.length ? n.removeAttribute(Dt) : n.getAttribute(Dt) !== o.join(",") && n.setAttribute(Dt, o.join(",")) }, YI = (t, e) => { typeof t < "u" && document.title !== t && (document.title = N0(t)), fd("title", e) }, Sm = (t, e) => { const { baseTag: n, bodyAttributes: r, htmlAttributes: i, linkTags: s, metaTags: o, noscriptTags: l, onChangeClientState: a, scriptTags: c, styleTags: u, title: f, titleAttributes: h } = t; fd("body", r), fd("html", i), YI(f, h); const y = { baseTag: ii("base", n), linkTags: ii("link", s), metaTags: ii("meta", o), noscriptTags: ii("noscript", l), scriptTags: ii("script", c), styleTags: ii("style", u) }, g = {}, w = {}; Object.keys(y).forEach(E => { const { newTags: v, oldTags: p } = y[E]; v.length && (g[E] = v), p.length && (w[E] = y[E].oldTags) }), e && e(), a(t, g, w) }, fs = null, JI = t => { fs && cancelAnimationFrame(fs), t.defer ? fs = requestAnimationFrame(() => { Sm(t, () => { fs = null }) }) : (Sm(t), fs = null) }, XI = JI, Em = class extends b.Component { constructor() { super(...arguments); nn(this, "rendered", !1) } shouldComponentUpdate(e) { return !jI(e, this.props) } componentDidUpdate() { this.emitChange() } componentWillUnmount() { const { helmetInstances: e } = this.props.context; e.remove(this), this.emitChange() } emitChange() { const { helmetInstances: e, setHelmet: n } = this.props.context; let r = null; const i = zI(e.get().map(s => { const o = { ...s.props }; return delete o.context, o })); L0.canUseDOM ? XI(i) : ud && (r = ud(i)), n(r) } init() { if (this.rendered) return; this.rendered = !0; const { helmetInstances: e } = this.props.context; e.add(this), this.emitChange() } render() { return this.init(), null } }, Jc, $l = (Jc = class extends b.Component { shouldComponentUpdate(t) { return !kI(xm(this.props, "helmetData"), xm(t, "helmetData")) } mapNestedChildrenToProps(t, e) { if (!e) return null; switch (t.type) { case "script": case "noscript": return { innerHTML: e }; case "style": return { cssText: e }; default: throw new Error(`<${t.type} /> elements are self-closing and can not contain children. Refer to our API for more information.`) } } flattenArrayTypeChildren(t, e, n, r) { return { ...e, [t.type]: [...e[t.type] || [], { ...n, ...this.mapNestedChildrenToProps(t, r) }] } } mapObjectTypeChildren(t, e, n, r) { switch (t.type) { case "title": return { ...e, [t.type]: r, titleAttributes: { ...n } }; case "body": return { ...e, bodyAttributes: { ...n } }; case "html": return { ...e, htmlAttributes: { ...n } }; default: return { ...e, [t.type]: { ...n } } } } mapArrayTypeChildrenToProps(t, e) { let n = { ...e }; return Object.keys(t).forEach(r => { n = { ...n, [r]: t[r] } }), n } warnOnInvalidChildren(t, e) { return ym(wm.some(n => t.type === n), typeof t.type == "function" ? "You may be attempting to nest <Helmet> components within each other, which is not allowed. Refer to our API for more information." : `Only elements types ${wm.join(", ")} are allowed. Helmet does not support rendering <${t.type}> elements. Refer to our API for more information.`), ym(!e || typeof e == "string" || Array.isArray(e) && !e.some(n => typeof n != "string"), `Helmet expects a string as a child of <${t.type}>. Did you forget to wrap your children in braces? ( <${t.type}>{\`\`}</${t.type}> ) Refer to our API for more information.`), !0 } mapChildrenToProps(t, e) { let n = {}; return ce.Children.forEach(t, r => { if (!r || !r.props) return; const { children: i, ...s } = r.props, o = Object.keys(s).reduce((a, c) => (a[AI[c] || c] = s[c], a), {}); let { type: l } = r; switch (typeof l == "symbol" ? l = l.toString() : this.warnOnInvalidChildren(r, i), l) { case "Symbol(react.fragment)": e = this.mapChildrenToProps(i, e); break; case "link": case "meta": case "noscript": case "script": case "style": n = this.flattenArrayTypeChildren(r, n, o, i); break; default: e = this.mapObjectTypeChildren(r, e, o, i); break } }), this.mapArrayTypeChildrenToProps(n, e) } render() { const { children: t, ...e } = this.props; let n = { ...e }, { helmetData: r } = e; if (t && (n = this.mapChildrenToProps(t, n)), r && !(r instanceof dd)) { const i = r; r = new dd(i.context, !0), delete n.helmetData } return r ? ce.createElement(Em, { ...n, context: r.value }) : ce.createElement(A0.Consumer, null, i => ce.createElement(Em, { ...n, context: i })) } }, nn(Jc, "defaultProps", { defer: !0, encodeSpecialCharacters: !0, prioritizeSeoTags: !1 }), Jc); const QI = () => d.jsxs("div", { children: [d.jsx("h1", { className: "text-6xl font-bold text-center my-8", children: "About Us" }), d.jsxs("details", { className: "collapse border-2 my-5", children: [d.jsx("summary", { className: "collapse-title text-xl font-medium border", children: d.jsxs("div", { className: "flex justify-between", children: [d.jsx("h1", { children: "We guarantee the highest quality of the products we sell. Click to more details......" }), d.jsx("h1", { children: " >>>> " })] }) }), d.jsx("div", { className: "collapse-content", children: d.jsx("p", { className: "text-3xl ", children: "Welcome to our online marketplace, where shopping is simplified and satisfaction is guaranteed. Browse, click, and enjoy the effortless way to shop for everything you need, right from the comfort of your home" }) })] }), d.jsxs("details", { className: "collapse border-2 my-5", children: [d.jsx("summary", { className: "collapse-title text-xl font-medium border", children: d.jsxs("div", { className: "flex justify-between", children: [d.jsx("h1", { children: "Our Shopping policy. Click to more details......" }), d.jsx("h1", { children: " >>>> " })] }) }), d.jsx("div", { className: "collapse-content", children: d.jsx("p", { className: "text-3xl ", children: "Welcome to our online marketplace, where shopping is simplified and satisfaction is guaranteed. Browse, click, and enjoy the effortless way to shop for everything you need, right from the comfort of your home" }) })] }), d.jsxs("details", { className: "collapse border-2 my-5", children: [d.jsx("summary", { className: "collapse-title text-xl font-medium border", children: d.jsxs("div", { className: "flex justify-between", children: [d.jsx("h1", { children: "Our higher policy . Click to more details......" }), d.jsx("h1", { children: " >>>> " })] }) }), d.jsx("div", { className: "collapse-content", children: d.jsx("p", { className: "text-3xl ", children: "Welcome to our online marketplace, where shopping is simplified and satisfaction is guaranteed. Browse, click, and enjoy the effortless way to shop for everything you need, right from the comfort of your home" }) })] })] }), ZI = () => d.jsxs("div", { className: "border shadow-2xl w-full mx-auto p-5 space-y-4", children: [d.jsx("h1", { className: "font-bold text-6xl text-center ", children: "Contact Us" }), d.jsx("p", { className: "text-2xl font-medium ", children: "Please Provide your information we will contact you...." }), d.jsx("h1", { className: "text-3xl ", children: "Name" }), d.jsx("input", { type: "text", className: "input shadow-sm w-full border-2 border-black ", placeholder: "Name " }), d.jsx("h1", { className: "text-3xl ", children: "Email" }), d.jsx("input", { type: "text", className: "input shadow-sm border-2 w-full border-black ", placeholder: "Email " }), d.jsx("h1", { className: "text-3xl ", children: "Phone Number" }), d.jsx("input", { type: "text", className: "input shadow-sm border-2 w-full border-black ", placeholder: "Number " }), d.jsx("button", { className: "btn w-full bg-red-400 text-white text-3xl ", children: "Subscribe" })] }), ek = () => (Ll(), d.jsxs("div", { className: "container mx-auto", children: [d.jsx($l, { children: d.jsx("title", { children: "Home" }) }), d.jsx(wI, {}), d.jsx(bI, {}), d.jsx(QI, {}), d.jsx(ZI, {})] })), $f = t => typeof t == "number" && !isNaN(t), As = t => typeof t == "string", D0 = t => typeof t == "function", tk = t => b.isValidElement(t) || As(t) || D0(t) || $f(t), Kt = new Map; let pd = []; const bm = new Set, M0 = () => Kt.size > 0; function nk(t, e) { var n; if (e) return !((n = Kt.get(e)) == null || !n.isToastActive(t)); let r = !1; return Kt.forEach(i => { i.isToastActive(t) && (r = !0) }), r } function rk(t, e) { tk(t) && (M0() || pd.push({ content: t, options: e }), Kt.forEach(n => { n.buildToast(t, e) })) } function Tm(t, e) { Kt.forEach(n => { e != null && e != null && e.containerId ? (e == null ? void 0 : e.containerId) === n.id && n.toggle(t, e == null ? void 0 : e.id) : n.toggle(t, e == null ? void 0 : e.id) }) } let ik = 1; const F0 = () => "" + ik++; function sk(t) { return t && (As(t.toastId) || $f(t.toastId)) ? t.toastId : F0() } function Ls(t, e) { return rk(t, e), e.toastId } function fl(t, e) { return { ...e, type: e && e.type || t, toastId: sk(e) } } function Xo(t) { return (e, n) => Ls(e, fl(t, n)) } function ge(t, e) { return Ls(t, fl("default", e)) } ge.loading = (t, e) => Ls(t, fl("default", { isLoading: !0, autoClose: !1, closeOnClick: !1, closeButton: !1, draggable: !1, ...e })), ge.promise = function (t, e, n) { let r, { pending: i, error: s, success: o } = e; i && (r = As(i) ? ge.loading(i, n) : ge.loading(i.render, { ...n, ...i })); const l = { isLoading: null, autoClose: null, closeOnClick: null, closeButton: null, draggable: null }, a = (u, f, h) => { if (f == null) return void ge.dismiss(r); const y = { type: u, ...l, ...n, data: h }, g = As(f) ? { render: f } : f; return r ? ge.update(r, { ...y, ...g }) : ge(g.render, { ...y, ...g }), h }, c = D0(t) ? t() : t; return c.then(u => a("success", o, u)).catch(u => a("error", s, u)), c }, ge.success = Xo("success"), ge.info = Xo("info"), ge.error = Xo("error"), ge.warning = Xo("warning"), ge.warn = ge.warning, ge.dark = (t, e) => Ls(t, fl("default", { theme: "dark", ...e })), ge.dismiss = function (t) { (function (e) { var n; if (M0()) { if (e == null || As(n = e) || $f(n)) Kt.forEach(r => { r.removeToast(e) }); else if (e && ("containerId" in e || "id" in e)) { const r = Kt.get(e.containerId); r ? r.removeToast(e.id) : Kt.forEach(i => { i.removeToast(e.id) }) } } else pd = pd.filter(r => e != null && r.options.toastId !== e) })(t) }, ge.clearWaitingQueue = function (t) { t === void 0 && (t = {}), Kt.forEach(e => { !e.props.limit || t.containerId && e.id !== t.containerId || e.clearQueue() }) }, ge.isActive = nk, ge.update = function (t, e) { e === void 0 && (e = {}); const n = ((r, i) => { var s; let { containerId: o } = i; return (s = Kt.get(o || 1)) == null ? void 0 : s.toasts.get(r) })(t, e); if (n) { const { props: r, content: i } = n, s = { delay: 100, ...r, ...e, toastId: e.toastId || t, updateId: F0() }; s.toastId !== t && (s.staleId = t); const o = s.render || i; delete s.render, Ls(o, s) } }, ge.done = t => { ge.update(t, { progress: 1 }) }, ge.onChange = function (t) { return bm.add(t), () => { bm.delete(t) } }, ge.play = t => Tm(!0, t), ge.pause = t => Tm(!1, t); function U0(t, e) { return function () { return t.apply(e, arguments) } } const { toString: ok } = Object.prototype, { getPrototypeOf: Bf } = Object, Bl = (t => e => { const n = ok.call(e); return t[n] || (t[n] = n.slice(8, -1).toLowerCase()) })(Object.create(null)), $t = t => (t = t.toLowerCase(), e => Bl(e) === t), Hl = t => e => typeof e === t, { isArray: Ki } = Array, ro = Hl("undefined"); function ak(t) { return t !== null && !ro(t) && t.constructor !== null && !ro(t.constructor) && mt(t.constructor.isBuffer) && t.constructor.isBuffer(t) } const z0 = $t("ArrayBuffer"); function lk(t) { let e; return typeof ArrayBuffer < "u" && ArrayBuffer.isView ? e = ArrayBuffer.isView(t) : e = t && t.buffer && z0(t.buffer), e } const ck = Hl("string"), mt = Hl("function"), $0 = Hl("number"), Vl = t => t !== null && typeof t == "object", uk = t => t === !0 || t === !1, Ea = t => { if (Bl(t) !== "object") return !1; const e = Bf(t); return (e === null || e === Object.prototype || Object.getPrototypeOf(e) === null) && !(Symbol.toStringTag in t) && !(Symbol.iterator in t) }, dk = $t("Date"), fk = $t("File"), pk = $t("Blob"), hk = $t("FileList"), mk = t => Vl(t) && mt(t.pipe), gk = t => { let e; return t && (typeof FormData == "function" && t instanceof FormData || mt(t.append) && ((e = Bl(t)) === "formdata" || e === "object" && mt(t.toString) && t.toString() === "[object FormData]")) }, vk = $t("URLSearchParams"), [yk, wk, xk, Sk] = ["ReadableStream", "Request", "Response", "Headers"].map($t), Ek = t => t.trim ? t.trim() : t.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, ""); function xo(t, e, { allOwnKeys: n = !1 } = {}) { if (t === null || typeof t > "u") return; let r, i; if (typeof t != "object" && (t = [t]), Ki(t)) for (r = 0, i = t.length; r < i; r++)e.call(null, t[r], r, t); else { const s = n ? Object.getOwnPropertyNames(t) : Object.keys(t), o = s.length; let l; for (r = 0; r < o; r++)l = s[r], e.call(null, t[l], l, t) } } function B0(t, e) { e = e.toLowerCase(); const n = Object.keys(t); let r = n.length, i; for (; r-- > 0;)if (i = n[r], e === i.toLowerCase()) return i; return null } const kr = typeof globalThis < "u" ? globalThis : typeof self < "u" ? self : typeof window < "u" ? window : global, H0 = t => !ro(t) && t !== kr; function hd() { const { caseless: t } = H0(this) && this || {}, e = {}, n = (r, i) => { const s = t && B0(e, i) || i; Ea(e[s]) && Ea(r) ? e[s] = hd(e[s], r) : Ea(r) ? e[s] = hd({}, r) : Ki(r) ? e[s] = r.slice() : e[s] = r }; for (let r = 0, i = arguments.length; r < i; r++)arguments[r] && xo(arguments[r], n); return e } const bk = (t, e, n, { allOwnKeys: r } = {}) => (xo(e, (i, s) => { n && mt(i) ? t[s] = U0(i, n) : t[s] = i }, { allOwnKeys: r }), t), Tk = t => (t.charCodeAt(0) === 65279 && (t = t.slice(1)), t), Ck = (t, e, n, r) => { t.prototype = Object.create(e.prototype, r), t.prototype.constructor = t, Object.defineProperty(t, "super", { value: e.prototype }), n && Object.assign(t.prototype, n) }, _k = (t, e, n, r) => { let i, s, o; const l = {}; if (e = e || {}, t == null) return e; do { for (i = Object.getOwnPropertyNames(t), s = i.length; s-- > 0;)o = i[s], (!r || r(o, t, e)) && !l[o] && (e[o] = t[o], l[o] = !0); t = n !== !1 && Bf(t) } while (t && (!n || n(t, e)) && t !== Object.prototype); return e }, Pk = (t, e, n) => { t = String(t), (n === void 0 || n > t.length) && (n = t.length), n -= e.length; const r = t.indexOf(e, n); return r !== -1 && r === n }, Ik = t => { if (!t) return null; if (Ki(t)) return t; let e = t.length; if (!$0(e)) return null; const n = new Array(e); for (; e-- > 0;)n[e] = t[e]; return n }, kk = (t => e => t && e instanceof t)(typeof Uint8Array < "u" && Bf(Uint8Array)), Nk = (t, e) => { const r = (t && t[Symbol.iterator]).call(t); let i; for (; (i = r.next()) && !i.done;) { const s = i.value; e.call(t, s[0], s[1]) } }, Rk = (t, e) => { let n; const r = []; for (; (n = t.exec(e)) !== null;)r.push(n); return r }, Ok = $t("HTMLFormElement"), jk = t => t.toLowerCase().replace(/[-_\s]([a-z\d])(\w*)/g, function (n, r, i) { return r.toUpperCase() + i }), Cm = (({ hasOwnProperty: t }) => (e, n) => t.call(e, n))(Object.prototype), Ak = $t("RegExp"), V0 = (t, e) => { const n = Object.getOwnPropertyDescriptors(t), r = {}; xo(n, (i, s) => { let o; (o = e(i, s, t)) !== !1 && (r[s] = o || i) }), Object.defineProperties(t, r) }, Lk = t => { V0(t, (e, n) => { if (mt(t) && ["arguments", "caller", "callee"].indexOf(n) !== -1) return !1; const r = t[n]; if (mt(r)) { if (e.enumerable = !1, "writable" in e) { e.writable = !1; return } e.set || (e.set = () => { throw Error("Can not rewrite read-only method '" + n + "'") }) } }) }, Dk = (t, e) => { const n = {}, r = i => { i.forEach(s => { n[s] = !0 }) }; return Ki(t) ? r(t) : r(String(t).split(e)), n }, Mk = () => { }, Fk = (t, e) => t != null && Number.isFinite(t = +t) ? t : e, Wc = "abcdefghijklmnopqrstuvwxyz", _m = "0123456789", W0 = { DIGIT: _m, ALPHA: Wc, ALPHA_DIGIT: Wc + Wc.toUpperCase() + _m }, Uk = (t = 16, e = W0.ALPHA_DIGIT) => { let n = ""; const { length: r } = e; for (; t--;)n += e[Math.random() * r | 0]; return n }; function zk(t) { return !!(t && mt(t.append) && t[Symbol.toStringTag] === "FormData" && t[Symbol.iterator]) } const $k = t => { const e = new Array(10), n = (r, i) => { if (Vl(r)) { if (e.indexOf(r) >= 0) return; if (!("toJSON" in r)) { e[i] = r; const s = Ki(r) ? [] : {}; return xo(r, (o, l) => { const a = n(o, i + 1); !ro(a) && (s[l] = a) }), e[i] = void 0, s } } return r }; return n(t, 0) }, Bk = $t("AsyncFunction"), Hk = t => t && (Vl(t) || mt(t)) && mt(t.then) && mt(t.catch), G0 = ((t, e) => t ? setImmediate : e ? ((n, r) => (kr.addEventListener("message", ({ source: i, data: s }) => { i === kr && s === n && r.length && r.shift()() }, !1), i => { r.push(i), kr.postMessage(n, "*") }))(`axios@${Math.random()}`, []) : n => setTimeout(n))(typeof setImmediate == "function", mt(kr.postMessage)), Vk = typeof queueMicrotask < "u" ? queueMicrotask.bind(kr) : typeof process < "u" && process.nextTick || G0, O = { isArray: Ki, isArrayBuffer: z0, isBuffer: ak, isFormData: gk, isArrayBufferView: lk, isString: ck, isNumber: $0, isBoolean: uk, isObject: Vl, isPlainObject: Ea, isReadableStream: yk, isRequest: wk, isResponse: xk, isHeaders: Sk, isUndefined: ro, isDate: dk, isFile: fk, isBlob: pk, isRegExp: Ak, isFunction: mt, isStream: mk, isURLSearchParams: vk, isTypedArray: kk, isFileList: hk, forEach: xo, merge: hd, extend: bk, trim: Ek, stripBOM: Tk, inherits: Ck, toFlatObject: _k, kindOf: Bl, kindOfTest: $t, endsWith: Pk, toArray: Ik, forEachEntry: Nk, matchAll: Rk, isHTMLForm: Ok, hasOwnProperty: Cm, hasOwnProp: Cm, reduceDescriptors: V0, freezeMethods: Lk, toObjectSet: Dk, toCamelCase: jk, noop: Mk, toFiniteNumber: Fk, findKey: B0, global: kr, isContextDefined: H0, ALPHABET: W0, generateString: Uk, isSpecCompliantForm: zk, toJSONObject: $k, isAsyncFn: Bk, isThenable: Hk, setImmediate: G0, asap: Vk }; function Q(t, e, n, r, i) { Error.call(this), Error.captureStackTrace ? Error.captureStackTrace(this, this.constructor) : this.stack = new Error().stack, this.message = t, this.name = "AxiosError", e && (this.code = e), n && (this.config = n), r && (this.request = r), i && (this.response = i, this.status = i.status ? i.status : null) } O.inherits(Q, Error, { toJSON: function () { return { message: this.message, name: this.name, description: this.description, number: this.number, fileName: this.fileName, lineNumber: this.lineNumber, columnNumber: this.columnNumber, stack: this.stack, config: O.toJSONObject(this.config), code: this.code, status: this.status } } }); const K0 = Q.prototype, q0 = {};["ERR_BAD_OPTION_VALUE", "ERR_BAD_OPTION", "ECONNABORTED", "ETIMEDOUT", "ERR_NETWORK", "ERR_FR_TOO_MANY_REDIRECTS", "ERR_DEPRECATED", "ERR_BAD_RESPONSE", "ERR_BAD_REQUEST", "ERR_CANCELED", "ERR_NOT_SUPPORT", "ERR_INVALID_URL"].forEach(t => { q0[t] = { value: t } }); Object.defineProperties(Q, q0); Object.defineProperty(K0, "isAxiosError", { value: !0 }); Q.from = (t, e, n, r, i, s) => { const o = Object.create(K0); return O.toFlatObject(t, o, function (a) { return a !== Error.prototype }, l => l !== "isAxiosError"), Q.call(o, t.message, e, n, r, i), o.cause = t, o.name = t.name, s && Object.assign(o, s), o }; const Wk = null; function md(t) { return O.isPlainObject(t) || O.isArray(t) } function Y0(t) { return O.endsWith(t, "[]") ? t.slice(0, -2) : t } function Pm(t, e, n) { return t ? t.concat(e).map(function (i, s) { return i = Y0(i), !n && s ? "[" + i + "]" : i }).join(n ? "." : "") : e } function Gk(t) { return O.isArray(t) && !t.some(md) } const Kk = O.toFlatObject(O, {}, null, function (e) { return /^is[A-Z]/.test(e) }); function Wl(t, e, n) { if (!O.isObject(t)) throw new TypeError("target must be an object"); e = e || new FormData, n = O.toFlatObject(n, { metaTokens: !0, dots: !1, indexes: !1 }, !1, function (w, E) { return !O.isUndefined(E[w]) }); const r = n.metaTokens, i = n.visitor || u, s = n.dots, o = n.indexes, a = (n.Blob || typeof Blob < "u" && Blob) && O.isSpecCompliantForm(e); if (!O.isFunction(i)) throw new TypeError("visitor must be a function"); function c(g) { if (g === null) return ""; if (O.isDate(g)) return g.toISOString(); if (!a && O.isBlob(g)) throw new Q("Blob is not supported. Use a Buffer instead."); return O.isArrayBuffer(g) || O.isTypedArray(g) ? a && typeof Blob == "function" ? new Blob([g]) : Buffer.from(g) : g } function u(g, w, E) { let v = g; if (g && !E && typeof g == "object") { if (O.endsWith(w, "{}")) w = r ? w : w.slice(0, -2), g = JSON.stringify(g); else if (O.isArray(g) && Gk(g) || (O.isFileList(g) || O.endsWith(w, "[]")) && (v = O.toArray(g))) return w = Y0(w), v.forEach(function (m, S) { !(O.isUndefined(m) || m === null) && e.append(o === !0 ? Pm([w], S, s) : o === null ? w : w + "[]", c(m)) }), !1 } return md(g) ? !0 : (e.append(Pm(E, w, s), c(g)), !1) } const f = [], h = Object.assign(Kk, { defaultVisitor: u, convertValue: c, isVisitable: md }); function y(g, w) { if (!O.isUndefined(g)) { if (f.indexOf(g) !== -1) throw Error("Circular reference detected in " + w.join(".")); f.push(g), O.forEach(g, function (v, p) { (!(O.isUndefined(v) || v === null) && i.call(e, v, O.isString(p) ? p.trim() : p, w, h)) === !0 && y(v, w ? w.concat(p) : [p]) }), f.pop() } } if (!O.isObject(t)) throw new TypeError("data must be an object"); return y(t), e } function Im(t) { const e = { "!": "%21", "'": "%27", "(": "%28", ")": "%29", "~": "%7E", "%20": "+", "%00": "\0" }; return encodeURIComponent(t).replace(/[!'()~]|%20|%00/g, function (r) { return e[r] }) } function Hf(t, e) { this._pairs = [], t && Wl(t, this, e) } const J0 = Hf.prototype; J0.append = function (e, n) { this._pairs.push([e, n]) }; J0.toString = function (e) { const n = e ? function (r) { return e.call(this, r, Im) } : Im; return this._pairs.map(function (i) { return n(i[0]) + "=" + n(i[1]) }, "").join("&") }; function qk(t) { return encodeURIComponent(t).replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",").replace(/%20/g, "+").replace(/%5B/gi, "[").replace(/%5D/gi, "]") } function X0(t, e, n) { if (!e) return t; const r = n && n.encode || qk, i = n && n.serialize; let s; if (i ? s = i(e, n) : s = O.isURLSearchParams(e) ? e.toString() : new Hf(e, n).toString(r), s) { const o = t.indexOf("#"); o !== -1 && (t = t.slice(0, o)), t += (t.indexOf("?") === -1 ? "?" : "&") + s } return t } class km { constructor() { this.handlers = [] } use(e, n, r) { return this.handlers.push({ fulfilled: e, rejected: n, synchronous: r ? r.synchronous : !1, runWhen: r ? r.runWhen : null }), this.handlers.length - 1 } eject(e) { this.handlers[e] && (this.handlers[e] = null) } clear() { this.handlers && (this.handlers = []) } forEach(e) { O.forEach(this.handlers, function (r) { r !== null && e(r) }) } } const Q0 = { silentJSONParsing: !0, forcedJSONParsing: !0, clarifyTimeoutError: !1 }, Yk = typeof URLSearchParams < "u" ? URLSearchParams : Hf, Jk = typeof FormData < "u" ? FormData : null, Xk = typeof Blob < "u" ? Blob : null, Qk = { isBrowser: !0, classes: { URLSearchParams: Yk, FormData: Jk, Blob: Xk }, protocols: ["http", "https", "file", "blob", "url", "data"] }, Vf = typeof window < "u" && typeof document < "u", gd = typeof navigator == "object" && navigator || void 0, Zk = Vf && (!gd || ["ReactNative", "NativeScript", "NS"].indexOf(gd.product) < 0), eN = typeof WorkerGlobalScope < "u" && self instanceof WorkerGlobalScope && typeof self.importScripts == "function", tN = Vf && window.location.href || "http://localhost", nN = Object.freeze(Object.defineProperty({ __proto__: null, hasBrowserEnv: Vf, hasStandardBrowserEnv: Zk, hasStandardBrowserWebWorkerEnv: eN, navigator: gd, origin: tN }, Symbol.toStringTag, { value: "Module" })), lt = { ...nN, ...Qk }; function rN(t, e) { return Wl(t, new lt.classes.URLSearchParams, Object.assign({ visitor: function (n, r, i, s) { return lt.isNode && O.isBuffer(n) ? (this.append(r, n.toString("base64")), !1) : s.defaultVisitor.apply(this, arguments) } }, e)) } function iN(t) { return O.matchAll(/\w+|\[(\w*)]/g, t).map(e => e[0] === "[]" ? "" : e[1] || e[0]) } function sN(t) { const e = {}, n = Object.keys(t); let r; const i = n.length; let s; for (r = 0; r < i; r++)s = n[r], e[s] = t[s]; return e } function Z0(t) { function e(n, r, i, s) { let o = n[s++]; if (o === "__proto__") return !0; const l = Number.isFinite(+o), a = s >= n.length; return o = !o && O.isArray(i) ? i.length : o, a ? (O.hasOwnProp(i, o) ? i[o] = [i[o], r] : i[o] = r, !l) : ((!i[o] || !O.isObject(i[o])) && (i[o] = []), e(n, r, i[o], s) && O.isArray(i[o]) && (i[o] = sN(i[o])), !l) } if (O.isFormData(t) && O.isFunction(t.entries)) { const n = {}; return O.forEachEntry(t, (r, i) => { e(iN(r), i, n, 0) }), n } return null } function oN(t, e, n) { if (O.isString(t)) try { return (e || JSON.parse)(t), O.trim(t) } catch (r) { if (r.name !== "SyntaxError") throw r } return (0, JSON.stringify)(t) } const So = { transitional: Q0, adapter: ["xhr", "http", "fetch"], transformRequest: [function (e, n) { const r = n.getContentType() || "", i = r.indexOf("application/json") > -1, s = O.isObject(e); if (s && O.isHTMLForm(e) && (e = new FormData(e)), O.isFormData(e)) return i ? JSON.stringify(Z0(e)) : e; if (O.isArrayBuffer(e) || O.isBuffer(e) || O.isStream(e) || O.isFile(e) || O.isBlob(e) || O.isReadableStream(e)) return e; if (O.isArrayBufferView(e)) return e.buffer; if (O.isURLSearchParams(e)) return n.setContentType("application/x-www-form-urlencoded;charset=utf-8", !1), e.toString(); let l; if (s) { if (r.indexOf("application/x-www-form-urlencoded") > -1) return rN(e, this.formSerializer).toString(); if ((l = O.isFileList(e)) || r.indexOf("multipart/form-data") > -1) { const a = this.env && this.env.FormData; return Wl(l ? { "files[]": e } : e, a && new a, this.formSerializer) } } return s || i ? (n.setContentType("application/json", !1), oN(e)) : e }], transformResponse: [function (e) { const n = this.transitional || So.transitional, r = n && n.forcedJSONParsing, i = this.responseType === "json"; if (O.isResponse(e) || O.isReadableStream(e)) return e; if (e && O.isString(e) && (r && !this.responseType || i)) { const o = !(n && n.silentJSONParsing) && i; try { return JSON.parse(e) } catch (l) { if (o) throw l.name === "SyntaxError" ? Q.from(l, Q.ERR_BAD_RESPONSE, this, null, this.response) : l } } return e }], timeout: 0, xsrfCookieName: "XSRF-TOKEN", xsrfHeaderName: "X-XSRF-TOKEN", maxContentLength: -1, maxBodyLength: -1, env: { FormData: lt.classes.FormData, Blob: lt.classes.Blob }, validateStatus: function (e) { return e >= 200 && e < 300 }, headers: { common: { Accept: "application/json, text/plain, */*", "Content-Type": void 0 } } }; O.forEach(["delete", "get", "head", "post", "put", "patch"], t => { So.headers[t] = {} }); const aN = O.toObjectSet(["age", "authorization", "content-length", "content-type", "etag", "expires", "from", "host", "if-modified-since", "if-unmodified-since", "last-modified", "location", "max-forwards", "proxy-authorization", "referer", "retry-after", "user-agent"]), lN = t => {
  const e = {}; let n, r, i; return t && t.split(`
`).forEach(function (o) { i = o.indexOf(":"), n = o.substring(0, i).trim().toLowerCase(), r = o.substring(i + 1).trim(), !(!n || e[n] && aN[n]) && (n === "set-cookie" ? e[n] ? e[n].push(r) : e[n] = [r] : e[n] = e[n] ? e[n] + ", " + r : r) }), e
}, Nm = Symbol("internals"); function ps(t) { return t && String(t).trim().toLowerCase() } function ba(t) { return t === !1 || t == null ? t : O.isArray(t) ? t.map(ba) : String(t) } function cN(t) { const e = Object.create(null), n = /([^\s,;=]+)\s*(?:=\s*([^,;]+))?/g; let r; for (; r = n.exec(t);)e[r[1]] = r[2]; return e } const uN = t => /^[-_a-zA-Z0-9^`|~,!#$%&'*+.]+$/.test(t.trim()); function Gc(t, e, n, r, i) { if (O.isFunction(r)) return r.call(this, e, n); if (i && (e = n), !!O.isString(e)) { if (O.isString(r)) return e.indexOf(r) !== -1; if (O.isRegExp(r)) return r.test(e) } } function dN(t) { return t.trim().toLowerCase().replace(/([a-z\d])(\w*)/g, (e, n, r) => n.toUpperCase() + r) } function fN(t, e) { const n = O.toCamelCase(" " + e);["get", "set", "has"].forEach(r => { Object.defineProperty(t, r + n, { value: function (i, s, o) { return this[r].call(this, e, i, s, o) }, configurable: !0 }) }) } class ct {
  constructor(e) { e && this.set(e) } set(e, n, r) { const i = this; function s(l, a, c) { const u = ps(a); if (!u) throw new Error("header name must be a non-empty string"); const f = O.findKey(i, u); (!f || i[f] === void 0 || c === !0 || c === void 0 && i[f] !== !1) && (i[f || a] = ba(l)) } const o = (l, a) => O.forEach(l, (c, u) => s(c, u, a)); if (O.isPlainObject(e) || e instanceof this.constructor) o(e, n); else if (O.isString(e) && (e = e.trim()) && !uN(e)) o(lN(e), n); else if (O.isHeaders(e)) for (const [l, a] of e.entries()) s(a, l, r); else e != null && s(n, e, r); return this } get(e, n) { if (e = ps(e), e) { const r = O.findKey(this, e); if (r) { const i = this[r]; if (!n) return i; if (n === !0) return cN(i); if (O.isFunction(n)) return n.call(this, i, r); if (O.isRegExp(n)) return n.exec(i); throw new TypeError("parser must be boolean|regexp|function") } } } has(e, n) { if (e = ps(e), e) { const r = O.findKey(this, e); return !!(r && this[r] !== void 0 && (!n || Gc(this, this[r], r, n))) } return !1 } delete(e, n) { const r = this; let i = !1; function s(o) { if (o = ps(o), o) { const l = O.findKey(r, o); l && (!n || Gc(r, r[l], l, n)) && (delete r[l], i = !0) } } return O.isArray(e) ? e.forEach(s) : s(e), i } clear(e) { const n = Object.keys(this); let r = n.length, i = !1; for (; r--;) { const s = n[r]; (!e || Gc(this, this[s], s, e, !0)) && (delete this[s], i = !0) } return i } normalize(e) { const n = this, r = {}; return O.forEach(this, (i, s) => { const o = O.findKey(r, s); if (o) { n[o] = ba(i), delete n[s]; return } const l = e ? dN(s) : String(s).trim(); l !== s && delete n[s], n[l] = ba(i), r[l] = !0 }), this } concat(...e) { return this.constructor.concat(this, ...e) } toJSON(e) { const n = Object.create(null); return O.forEach(this, (r, i) => { r != null && r !== !1 && (n[i] = e && O.isArray(r) ? r.join(", ") : r) }), n } [Symbol.iterator]() { return Object.entries(this.toJSON())[Symbol.iterator]() } toString() {
    return Object.entries(this.toJSON()).map(([e, n]) => e + ": " + n).join(`
`)
  } get [Symbol.toStringTag]() { return "AxiosHeaders" } static from(e) { return e instanceof this ? e : new this(e) } static concat(e, ...n) { const r = new this(e); return n.forEach(i => r.set(i)), r } static accessor(e) { const r = (this[Nm] = this[Nm] = { accessors: {} }).accessors, i = this.prototype; function s(o) { const l = ps(o); r[l] || (fN(i, o), r[l] = !0) } return O.isArray(e) ? e.forEach(s) : s(e), this }
} ct.accessor(["Content-Type", "Content-Length", "Accept", "Accept-Encoding", "User-Agent", "Authorization"]); O.reduceDescriptors(ct.prototype, ({ value: t }, e) => { let n = e[0].toUpperCase() + e.slice(1); return { get: () => t, set(r) { this[n] = r } } }); O.freezeMethods(ct); function Kc(t, e) { const n = this || So, r = e || n, i = ct.from(r.headers); let s = r.data; return O.forEach(t, function (l) { s = l.call(n, s, i.normalize(), e ? e.status : void 0) }), i.normalize(), s } function ew(t) { return !!(t && t.__CANCEL__) } function qi(t, e, n) { Q.call(this, t ?? "canceled", Q.ERR_CANCELED, e, n), this.name = "CanceledError" } O.inherits(qi, Q, { __CANCEL__: !0 }); function tw(t, e, n) { const r = n.config.validateStatus; !n.status || !r || r(n.status) ? t(n) : e(new Q("Request failed with status code " + n.status, [Q.ERR_BAD_REQUEST, Q.ERR_BAD_RESPONSE][Math.floor(n.status / 100) - 4], n.config, n.request, n)) } function pN(t) { const e = /^([-+\w]{1,25})(:?\/\/|:)/.exec(t); return e && e[1] || "" } function hN(t, e) { t = t || 10; const n = new Array(t), r = new Array(t); let i = 0, s = 0, o; return e = e !== void 0 ? e : 1e3, function (a) { const c = Date.now(), u = r[s]; o || (o = c), n[i] = a, r[i] = c; let f = s, h = 0; for (; f !== i;)h += n[f++], f = f % t; if (i = (i + 1) % t, i === s && (s = (s + 1) % t), c - o < e) return; const y = u && c - u; return y ? Math.round(h * 1e3 / y) : void 0 } } function mN(t, e) { let n = 0, r = 1e3 / e, i, s; const o = (c, u = Date.now()) => { n = u, i = null, s && (clearTimeout(s), s = null), t.apply(null, c) }; return [(...c) => { const u = Date.now(), f = u - n; f >= r ? o(c, u) : (i = c, s || (s = setTimeout(() => { s = null, o(i) }, r - f))) }, () => i && o(i)] } const pl = (t, e, n = 3) => { let r = 0; const i = hN(50, 250); return mN(s => { const o = s.loaded, l = s.lengthComputable ? s.total : void 0, a = o - r, c = i(a), u = o <= l; r = o; const f = { loaded: o, total: l, progress: l ? o / l : void 0, bytes: a, rate: c || void 0, estimated: c && l && u ? (l - o) / c : void 0, event: s, lengthComputable: l != null, [e ? "download" : "upload"]: !0 }; t(f) }, n) }, Rm = (t, e) => { const n = t != null; return [r => e[0]({ lengthComputable: n, total: t, loaded: r }), e[1]] }, Om = t => (...e) => O.asap(() => t(...e)), gN = lt.hasStandardBrowserEnv ? function () { const e = lt.navigator && /(msie|trident)/i.test(lt.navigator.userAgent), n = document.createElement("a"); let r; function i(s) { let o = s; return e && (n.setAttribute("href", o), o = n.href), n.setAttribute("href", o), { href: n.href, protocol: n.protocol ? n.protocol.replace(/:$/, "") : "", host: n.host, search: n.search ? n.search.replace(/^\?/, "") : "", hash: n.hash ? n.hash.replace(/^#/, "") : "", hostname: n.hostname, port: n.port, pathname: n.pathname.charAt(0) === "/" ? n.pathname : "/" + n.pathname } } return r = i(window.location.href), function (o) { const l = O.isString(o) ? i(o) : o; return l.protocol === r.protocol && l.host === r.host } }() : function () { return function () { return !0 } }(), vN = lt.hasStandardBrowserEnv ? { write(t, e, n, r, i, s) { const o = [t + "=" + encodeURIComponent(e)]; O.isNumber(n) && o.push("expires=" + new Date(n).toGMTString()), O.isString(r) && o.push("path=" + r), O.isString(i) && o.push("domain=" + i), s === !0 && o.push("secure"), document.cookie = o.join("; ") }, read(t) { const e = document.cookie.match(new RegExp("(^|;\\s*)(" + t + ")=([^;]*)")); return e ? decodeURIComponent(e[3]) : null }, remove(t) { this.write(t, "", Date.now() - 864e5) } } : { write() { }, read() { return null }, remove() { } }; function yN(t) { return /^([a-z][a-z\d+\-.]*:)?\/\//i.test(t) } function wN(t, e) { return e ? t.replace(/\/?\/$/, "") + "/" + e.replace(/^\/+/, "") : t } function nw(t, e) { return t && !yN(e) ? wN(t, e) : e } const jm = t => t instanceof ct ? { ...t } : t; function Vr(t, e) { e = e || {}; const n = {}; function r(c, u, f) { return O.isPlainObject(c) && O.isPlainObject(u) ? O.merge.call({ caseless: f }, c, u) : O.isPlainObject(u) ? O.merge({}, u) : O.isArray(u) ? u.slice() : u } function i(c, u, f) { if (O.isUndefined(u)) { if (!O.isUndefined(c)) return r(void 0, c, f) } else return r(c, u, f) } function s(c, u) { if (!O.isUndefined(u)) return r(void 0, u) } function o(c, u) { if (O.isUndefined(u)) { if (!O.isUndefined(c)) return r(void 0, c) } else return r(void 0, u) } function l(c, u, f) { if (f in e) return r(c, u); if (f in t) return r(void 0, c) } const a = { url: s, method: s, data: s, baseURL: o, transformRequest: o, transformResponse: o, paramsSerializer: o, timeout: o, timeoutMessage: o, withCredentials: o, withXSRFToken: o, adapter: o, responseType: o, xsrfCookieName: o, xsrfHeaderName: o, onUploadProgress: o, onDownloadProgress: o, decompress: o, maxContentLength: o, maxBodyLength: o, beforeRedirect: o, transport: o, httpAgent: o, httpsAgent: o, cancelToken: o, socketPath: o, responseEncoding: o, validateStatus: l, headers: (c, u) => i(jm(c), jm(u), !0) }; return O.forEach(Object.keys(Object.assign({}, t, e)), function (u) { const f = a[u] || i, h = f(t[u], e[u], u); O.isUndefined(h) && f !== l || (n[u] = h) }), n } const rw = t => { const e = Vr({}, t); let { data: n, withXSRFToken: r, xsrfHeaderName: i, xsrfCookieName: s, headers: o, auth: l } = e; e.headers = o = ct.from(o), e.url = X0(nw(e.baseURL, e.url), t.params, t.paramsSerializer), l && o.set("Authorization", "Basic " + btoa((l.username || "") + ":" + (l.password ? unescape(encodeURIComponent(l.password)) : ""))); let a; if (O.isFormData(n)) { if (lt.hasStandardBrowserEnv || lt.hasStandardBrowserWebWorkerEnv) o.setContentType(void 0); else if ((a = o.getContentType()) !== !1) { const [c, ...u] = a ? a.split(";").map(f => f.trim()).filter(Boolean) : []; o.setContentType([c || "multipart/form-data", ...u].join("; ")) } } if (lt.hasStandardBrowserEnv && (r && O.isFunction(r) && (r = r(e)), r || r !== !1 && gN(e.url))) { const c = i && s && vN.read(s); c && o.set(i, c) } return e }, xN = typeof XMLHttpRequest < "u", SN = xN && function (t) { return new Promise(function (n, r) { const i = rw(t); let s = i.data; const o = ct.from(i.headers).normalize(); let { responseType: l, onUploadProgress: a, onDownloadProgress: c } = i, u, f, h, y, g; function w() { y && y(), g && g(), i.cancelToken && i.cancelToken.unsubscribe(u), i.signal && i.signal.removeEventListener("abort", u) } let E = new XMLHttpRequest; E.open(i.method.toUpperCase(), i.url, !0), E.timeout = i.timeout; function v() { if (!E) return; const m = ct.from("getAllResponseHeaders" in E && E.getAllResponseHeaders()), T = { data: !l || l === "text" || l === "json" ? E.responseText : E.response, status: E.status, statusText: E.statusText, headers: m, config: t, request: E }; tw(function (P) { n(P), w() }, function (P) { r(P), w() }, T), E = null } "onloadend" in E ? E.onloadend = v : E.onreadystatechange = function () { !E || E.readyState !== 4 || E.status === 0 && !(E.responseURL && E.responseURL.indexOf("file:") === 0) || setTimeout(v) }, E.onabort = function () { E && (r(new Q("Request aborted", Q.ECONNABORTED, t, E)), E = null) }, E.onerror = function () { r(new Q("Network Error", Q.ERR_NETWORK, t, E)), E = null }, E.ontimeout = function () { let S = i.timeout ? "timeout of " + i.timeout + "ms exceeded" : "timeout exceeded"; const T = i.transitional || Q0; i.timeoutErrorMessage && (S = i.timeoutErrorMessage), r(new Q(S, T.clarifyTimeoutError ? Q.ETIMEDOUT : Q.ECONNABORTED, t, E)), E = null }, s === void 0 && o.setContentType(null), "setRequestHeader" in E && O.forEach(o.toJSON(), function (S, T) { E.setRequestHeader(T, S) }), O.isUndefined(i.withCredentials) || (E.withCredentials = !!i.withCredentials), l && l !== "json" && (E.responseType = i.responseType), c && ([h, g] = pl(c, !0), E.addEventListener("progress", h)), a && E.upload && ([f, y] = pl(a), E.upload.addEventListener("progress", f), E.upload.addEventListener("loadend", y)), (i.cancelToken || i.signal) && (u = m => { E && (r(!m || m.type ? new qi(null, t, E) : m), E.abort(), E = null) }, i.cancelToken && i.cancelToken.subscribe(u), i.signal && (i.signal.aborted ? u() : i.signal.addEventListener("abort", u))); const p = pN(i.url); if (p && lt.protocols.indexOf(p) === -1) { r(new Q("Unsupported protocol " + p + ":", Q.ERR_BAD_REQUEST, t)); return } E.send(s || null) }) }, EN = (t, e) => { const { length: n } = t = t ? t.filter(Boolean) : []; if (e || n) { let r = new AbortController, i; const s = function (c) { if (!i) { i = !0, l(); const u = c instanceof Error ? c : this.reason; r.abort(u instanceof Q ? u : new qi(u instanceof Error ? u.message : u)) } }; let o = e && setTimeout(() => { o = null, s(new Q(`timeout ${e} of ms exceeded`, Q.ETIMEDOUT)) }, e); const l = () => { t && (o && clearTimeout(o), o = null, t.forEach(c => { c.unsubscribe ? c.unsubscribe(s) : c.removeEventListener("abort", s) }), t = null) }; t.forEach(c => c.addEventListener("abort", s)); const { signal: a } = r; return a.unsubscribe = () => O.asap(l), a } }, bN = function* (t, e) { let n = t.byteLength; if (n < e) { yield t; return } let r = 0, i; for (; r < n;)i = r + e, yield t.slice(r, i), r = i }, TN = async function* (t, e) { for await (const n of CN(t)) yield* bN(n, e) }, CN = async function* (t) { if (t[Symbol.asyncIterator]) { yield* t; return } const e = t.getReader(); try { for (; ;) { const { done: n, value: r } = await e.read(); if (n) break; yield r } } finally { await e.cancel() } }, Am = (t, e, n, r) => { const i = TN(t, e); let s = 0, o, l = a => { o || (o = !0, r && r(a)) }; return new ReadableStream({ async pull(a) { try { const { done: c, value: u } = await i.next(); if (c) { l(), a.close(); return } let f = u.byteLength; if (n) { let h = s += f; n(h) } a.enqueue(new Uint8Array(u)) } catch (c) { throw l(c), c } }, cancel(a) { return l(a), i.return() } }, { highWaterMark: 2 }) }, Gl = typeof fetch == "function" && typeof Request == "function" && typeof Response == "function", iw = Gl && typeof ReadableStream == "function", _N = Gl && (typeof TextEncoder == "function" ? (t => e => t.encode(e))(new TextEncoder) : async t => new Uint8Array(await new Response(t).arrayBuffer())), sw = (t, ...e) => { try { return !!t(...e) } catch { return !1 } }, PN = iw && sw(() => { let t = !1; const e = new Request(lt.origin, { body: new ReadableStream, method: "POST", get duplex() { return t = !0, "half" } }).headers.has("Content-Type"); return t && !e }), Lm = 64 * 1024, vd = iw && sw(() => O.isReadableStream(new Response("").body)), hl = { stream: vd && (t => t.body) }; Gl && (t => { ["text", "arrayBuffer", "blob", "formData", "stream"].forEach(e => { !hl[e] && (hl[e] = O.isFunction(t[e]) ? n => n[e]() : (n, r) => { throw new Q(`Response type '${e}' is not supported`, Q.ERR_NOT_SUPPORT, r) }) }) })(new Response); const IN = async t => { if (t == null) return 0; if (O.isBlob(t)) return t.size; if (O.isSpecCompliantForm(t)) return (await new Request(lt.origin, { method: "POST", body: t }).arrayBuffer()).byteLength; if (O.isArrayBufferView(t) || O.isArrayBuffer(t)) return t.byteLength; if (O.isURLSearchParams(t) && (t = t + ""), O.isString(t)) return (await _N(t)).byteLength }, kN = async (t, e) => { const n = O.toFiniteNumber(t.getContentLength()); return n ?? IN(e) }, NN = Gl && (async t => { let { url: e, method: n, data: r, signal: i, cancelToken: s, timeout: o, onDownloadProgress: l, onUploadProgress: a, responseType: c, headers: u, withCredentials: f = "same-origin", fetchOptions: h } = rw(t); c = c ? (c + "").toLowerCase() : "text"; let y = EN([i, s && s.toAbortSignal()], o), g; const w = y && y.unsubscribe && (() => { y.unsubscribe() }); let E; try { if (a && PN && n !== "get" && n !== "head" && (E = await kN(u, r)) !== 0) { let T = new Request(e, { method: "POST", body: r, duplex: "half" }), x; if (O.isFormData(r) && (x = T.headers.get("content-type")) && u.setContentType(x), T.body) { const [P, I] = Rm(E, pl(Om(a))); r = Am(T.body, Lm, P, I) } } O.isString(f) || (f = f ? "include" : "omit"); const v = "credentials" in Request.prototype; g = new Request(e, { ...h, signal: y, method: n.toUpperCase(), headers: u.normalize().toJSON(), body: r, duplex: "half", credentials: v ? f : void 0 }); let p = await fetch(g); const m = vd && (c === "stream" || c === "response"); if (vd && (l || m && w)) { const T = {};["status", "statusText", "headers"].forEach(N => { T[N] = p[N] }); const x = O.toFiniteNumber(p.headers.get("content-length")), [P, I] = l && Rm(x, pl(Om(l), !0)) || []; p = new Response(Am(p.body, Lm, P, () => { I && I(), w && w() }), T) } c = c || "text"; let S = await hl[O.findKey(hl, c) || "text"](p, t); return !m && w && w(), await new Promise((T, x) => { tw(T, x, { data: S, headers: ct.from(p.headers), status: p.status, statusText: p.statusText, config: t, request: g }) }) } catch (v) { throw w && w(), v && v.name === "TypeError" && /fetch/i.test(v.message) ? Object.assign(new Q("Network Error", Q.ERR_NETWORK, t, g), { cause: v.cause || v }) : Q.from(v, v && v.code, t, g) } }), yd = { http: Wk, xhr: SN, fetch: NN }; O.forEach(yd, (t, e) => { if (t) { try { Object.defineProperty(t, "name", { value: e }) } catch { } Object.defineProperty(t, "adapterName", { value: e }) } }); const Dm = t => `- ${t}`, RN = t => O.isFunction(t) || t === null || t === !1, ow = {
  getAdapter: t => {
    t = O.isArray(t) ? t : [t]; const { length: e } = t; let n, r; const i = {}; for (let s = 0; s < e; s++) { n = t[s]; let o; if (r = n, !RN(n) && (r = yd[(o = String(n)).toLowerCase()], r === void 0)) throw new Q(`Unknown adapter '${o}'`); if (r) break; i[o || "#" + s] = r } if (!r) {
      const s = Object.entries(i).map(([l, a]) => `adapter ${l} ` + (a === !1 ? "is not supported by the environment" : "is not available in the build")); let o = e ? s.length > 1 ? `since :
`+ s.map(Dm).join(`
`) : " " + Dm(s[0]) : "as no adapter specified"; throw new Q("There is no suitable adapter to dispatch the request " + o, "ERR_NOT_SUPPORT")
    } return r
  }, adapters: yd
}; function qc(t) { if (t.cancelToken && t.cancelToken.throwIfRequested(), t.signal && t.signal.aborted) throw new qi(null, t) } function Mm(t) { return qc(t), t.headers = ct.from(t.headers), t.data = Kc.call(t, t.transformRequest), ["post", "put", "patch"].indexOf(t.method) !== -1 && t.headers.setContentType("application/x-www-form-urlencoded", !1), ow.getAdapter(t.adapter || So.adapter)(t).then(function (r) { return qc(t), r.data = Kc.call(t, t.transformResponse, r), r.headers = ct.from(r.headers), r }, function (r) { return ew(r) || (qc(t), r && r.response && (r.response.data = Kc.call(t, t.transformResponse, r.response), r.response.headers = ct.from(r.response.headers))), Promise.reject(r) }) } const aw = "1.7.7", Wf = {};["object", "boolean", "number", "function", "string", "symbol"].forEach((t, e) => { Wf[t] = function (r) { return typeof r === t || "a" + (e < 1 ? "n " : " ") + t } }); const Fm = {}; Wf.transitional = function (e, n, r) { function i(s, o) { return "[Axios v" + aw + "] Transitional option '" + s + "'" + o + (r ? ". " + r : "") } return (s, o, l) => { if (e === !1) throw new Q(i(o, " has been removed" + (n ? " in " + n : "")), Q.ERR_DEPRECATED); return n && !Fm[o] && (Fm[o] = !0, console.warn(i(o, " has been deprecated since v" + n + " and will be removed in the near future"))), e ? e(s, o, l) : !0 } }; function ON(t, e, n) { if (typeof t != "object") throw new Q("options must be an object", Q.ERR_BAD_OPTION_VALUE); const r = Object.keys(t); let i = r.length; for (; i-- > 0;) { const s = r[i], o = e[s]; if (o) { const l = t[s], a = l === void 0 || o(l, s, t); if (a !== !0) throw new Q("option " + s + " must be " + a, Q.ERR_BAD_OPTION_VALUE); continue } if (n !== !0) throw new Q("Unknown option " + s, Q.ERR_BAD_OPTION) } } const wd = { assertOptions: ON, validators: Wf }, An = wd.validators; class jr {
  constructor(e) { this.defaults = e, this.interceptors = { request: new km, response: new km } } async request(e, n) {
    try { return await this._request(e, n) } catch (r) {
      if (r instanceof Error) {
        let i; Error.captureStackTrace ? Error.captureStackTrace(i = {}) : i = new Error; const s = i.stack ? i.stack.replace(/^.+\n/, "") : ""; try {
          r.stack ? s && !String(r.stack).endsWith(s.replace(/^.+\n.+\n/, "")) && (r.stack += `
`+ s) : r.stack = s
        } catch { }
      } throw r
    }
  } _request(e, n) { typeof e == "string" ? (n = n || {}, n.url = e) : n = e || {}, n = Vr(this.defaults, n); const { transitional: r, paramsSerializer: i, headers: s } = n; r !== void 0 && wd.assertOptions(r, { silentJSONParsing: An.transitional(An.boolean), forcedJSONParsing: An.transitional(An.boolean), clarifyTimeoutError: An.transitional(An.boolean) }, !1), i != null && (O.isFunction(i) ? n.paramsSerializer = { serialize: i } : wd.assertOptions(i, { encode: An.function, serialize: An.function }, !0)), n.method = (n.method || this.defaults.method || "get").toLowerCase(); let o = s && O.merge(s.common, s[n.method]); s && O.forEach(["delete", "get", "head", "post", "put", "patch", "common"], g => { delete s[g] }), n.headers = ct.concat(o, s); const l = []; let a = !0; this.interceptors.request.forEach(function (w) { typeof w.runWhen == "function" && w.runWhen(n) === !1 || (a = a && w.synchronous, l.unshift(w.fulfilled, w.rejected)) }); const c = []; this.interceptors.response.forEach(function (w) { c.push(w.fulfilled, w.rejected) }); let u, f = 0, h; if (!a) { const g = [Mm.bind(this), void 0]; for (g.unshift.apply(g, l), g.push.apply(g, c), h = g.length, u = Promise.resolve(n); f < h;)u = u.then(g[f++], g[f++]); return u } h = l.length; let y = n; for (f = 0; f < h;) { const g = l[f++], w = l[f++]; try { y = g(y) } catch (E) { w.call(this, E); break } } try { u = Mm.call(this, y) } catch (g) { return Promise.reject(g) } for (f = 0, h = c.length; f < h;)u = u.then(c[f++], c[f++]); return u } getUri(e) { e = Vr(this.defaults, e); const n = nw(e.baseURL, e.url); return X0(n, e.params, e.paramsSerializer) }
} O.forEach(["delete", "get", "head", "options"], function (e) { jr.prototype[e] = function (n, r) { return this.request(Vr(r || {}, { method: e, url: n, data: (r || {}).data })) } }); O.forEach(["post", "put", "patch"], function (e) { function n(r) { return function (s, o, l) { return this.request(Vr(l || {}, { method: e, headers: r ? { "Content-Type": "multipart/form-data" } : {}, url: s, data: o })) } } jr.prototype[e] = n(), jr.prototype[e + "Form"] = n(!0) }); class Gf { constructor(e) { if (typeof e != "function") throw new TypeError("executor must be a function."); let n; this.promise = new Promise(function (s) { n = s }); const r = this; this.promise.then(i => { if (!r._listeners) return; let s = r._listeners.length; for (; s-- > 0;)r._listeners[s](i); r._listeners = null }), this.promise.then = i => { let s; const o = new Promise(l => { r.subscribe(l), s = l }).then(i); return o.cancel = function () { r.unsubscribe(s) }, o }, e(function (s, o, l) { r.reason || (r.reason = new qi(s, o, l), n(r.reason)) }) } throwIfRequested() { if (this.reason) throw this.reason } subscribe(e) { if (this.reason) { e(this.reason); return } this._listeners ? this._listeners.push(e) : this._listeners = [e] } unsubscribe(e) { if (!this._listeners) return; const n = this._listeners.indexOf(e); n !== -1 && this._listeners.splice(n, 1) } toAbortSignal() { const e = new AbortController, n = r => { e.abort(r) }; return this.subscribe(n), e.signal.unsubscribe = () => this.unsubscribe(n), e.signal } static source() { let e; return { token: new Gf(function (i) { e = i }), cancel: e } } } function jN(t) { return function (n) { return t.apply(null, n) } } function AN(t) { return O.isObject(t) && t.isAxiosError === !0 } const xd = { Continue: 100, SwitchingProtocols: 101, Processing: 102, EarlyHints: 103, Ok: 200, Created: 201, Accepted: 202, NonAuthoritativeInformation: 203, NoContent: 204, ResetContent: 205, PartialContent: 206, MultiStatus: 207, AlreadyReported: 208, ImUsed: 226, MultipleChoices: 300, MovedPermanently: 301, Found: 302, SeeOther: 303, NotModified: 304, UseProxy: 305, Unused: 306, TemporaryRedirect: 307, PermanentRedirect: 308, BadRequest: 400, Unauthorized: 401, PaymentRequired: 402, Forbidden: 403, NotFound: 404, MethodNotAllowed: 405, NotAcceptable: 406, ProxyAuthenticationRequired: 407, RequestTimeout: 408, Conflict: 409, Gone: 410, LengthRequired: 411, PreconditionFailed: 412, PayloadTooLarge: 413, UriTooLong: 414, UnsupportedMediaType: 415, RangeNotSatisfiable: 416, ExpectationFailed: 417, ImATeapot: 418, MisdirectedRequest: 421, UnprocessableEntity: 422, Locked: 423, FailedDependency: 424, TooEarly: 425, UpgradeRequired: 426, PreconditionRequired: 428, TooManyRequests: 429, RequestHeaderFieldsTooLarge: 431, UnavailableForLegalReasons: 451, InternalServerError: 500, NotImplemented: 501, BadGateway: 502, ServiceUnavailable: 503, GatewayTimeout: 504, HttpVersionNotSupported: 505, VariantAlsoNegotiates: 506, InsufficientStorage: 507, LoopDetected: 508, NotExtended: 510, NetworkAuthenticationRequired: 511 }; Object.entries(xd).forEach(([t, e]) => { xd[e] = t }); function lw(t) { const e = new jr(t), n = U0(jr.prototype.request, e); return O.extend(n, jr.prototype, e, { allOwnKeys: !0 }), O.extend(n, e, null, { allOwnKeys: !0 }), n.create = function (i) { return lw(Vr(t, i)) }, n } const re = lw(So); re.Axios = jr; re.CanceledError = qi; re.CancelToken = Gf; re.isCancel = ew; re.VERSION = aw; re.toFormData = Wl; re.AxiosError = Q; re.Cancel = re.CanceledError; re.all = function (e) { return Promise.all(e) }; re.spread = jN; re.isAxiosError = AN; re.mergeConfig = Vr; re.AxiosHeaders = ct; re.formToJSON = t => Z0(O.isHTMLForm(t) ? new FormData(t) : t); re.getAdapter = ow.getAdapter; re.HttpStatusCode = xd; re.default = re; const LN = () => { const t = qr(), { signInWithGoogle: e, createUser: n, user: r, logOut: i } = b.useContext(Ke), s = u => /^(?=.*[a-z])(?=.*[A-Z])(?=.*\d)(?=.*[@$!%*?&#])[A-Za-z\d@$!%*?&#]{8,}$/.test(u), [o, l] = b.useState(""), a = async u => { u.preventDefault(); const f = u.target, h = f.email.value, y = f.name.value, g = f.role.value, w = f.password.value; if (!h || !y || !g || !w) { ge.error("Please fill out all fields."); return } if (!s(w)) { l("Password must include at least 8 characters, an uppercase, a lowercase, a number, and a special character."); return } l(""), n(h, w); const E = { email: h, role: g }; await re.post("https://wave55.vercel.app/users", E), t("/"), console.log(r) }, c = async () => { try { await e(), ge.success("Signin Successful"), t("/") } catch (u) { console.log(u), ge.error(u == null ? void 0 : u.message) } }; return d.jsx("div", { className: "flex justify-center items-center min-h-[calc(100vh-306px)] my-12", children: d.jsxs("div", { className: "flex w-full max-w-sm mx-auto overflow-hidden bg-white rounded-lg shadow-lg lg:max-w-4xl", children: [d.jsxs("div", { className: "w-full px-6 py-8 md:px-8 lg:w-1/2", children: [d.jsx("div", { className: "flex justify-center mx-auto", children: d.jsx("img", { className: "w-auto h-7 sm:h-8", src: Dl, alt: "Logo" }) }), d.jsx("p", { className: "mt-3 text-xl text-center text-gray-600", children: "Get Your Free Account Now." }), d.jsxs("div", { onClick: c, className: "flex cursor-pointer items-center justify-center mt-4 text-gray-600 transition-colors duration-300 transform border rounded-lg hover:bg-gray-50", children: [d.jsx("div", { className: "px-4 py-2", children: d.jsxs("svg", { className: "w-6 h-6", viewBox: "0 0 40 40", children: [d.jsx("path", { d: "M36.3425 16.7358H35V16.6667H20V23.3333H29.4192C28.045 27.2142 24.3525 30 20 30C14.4775 30 10 25.5225 10 20C10 14.4775 14.4775 9.99999 20 9.99999C22.5492 9.99999 24.8683 10.9617 26.6342 12.5325L31.3483 7.81833C28.3717 5.04416 24.39 3.33333 20 3.33333C10.7958 3.33333 3.33335 10.7958 3.33335 20C3.33335 29.2042 10.7958 36.6667 20 36.6667C29.2042 36.6667 36.6667 29.2042 36.6667 20C36.6667 18.8825 36.5517 17.7917 36.3425 16.7358Z", fill: "#FFC107" }), d.jsx("path", { d: "M5.25497 12.2425L10.7308 16.2583C12.2125 12.59 15.8008 9.99999 20 9.99999C22.5491 9.99999 24.8683 10.9617 26.6341 12.5325L31.3483 7.81833C28.3716 5.04416 24.39 3.33333 20 3.33333C13.5983 3.33333 8.04663 6.94749 5.25497 12.2425Z", fill: "#FF3D00" }), d.jsx("path", { d: "M20 36.6667C24.305 36.6667 28.2167 35.0192 31.1742 32.34L26.0159 27.975C24.3425 29.2425 22.2625 30 20 30C15.665 30 11.9842 27.2359 10.5975 23.3784L5.16254 27.5659C7.92087 32.9634 13.5225 36.6667 20 36.6667Z", fill: "#4CAF50" }), d.jsx("path", { d: "M36.3425 16.7358H35V16.6667H20V23.3333H29.4192C28.7592 25.1975 27.56 26.805 26.0133 27.9758C26.0142 27.975 26.015 27.975 26.0158 27.9742L31.1742 32.3392C30.8092 32.6708 36.6667 28.3333 36.6667 20C36.6667 18.8825 36.5517 17.7917 36.3425 16.7358Z", fill: "#1976D2" })] }) }), d.jsx("span", { className: "w-5/6 px-4 py-3 font-bold text-center", children: "Sign in with Google" })] }), d.jsxs("div", { className: "flex items-center justify-between mt-4", children: [d.jsx("span", { className: "w-1/5 border-b lg:w-1/4" }), d.jsx("div", { className: "text-xs text-center text-gray-500 uppercase hover:underline", children: "or Registration with email" }), d.jsx("span", { className: "w-1/5 border-b lg:w-1/4" })] }), d.jsxs("form", { onSubmit: a, children: [d.jsxs("div", { className: "mt-4", children: [d.jsx("label", { className: "block mb-2 text-sm font-medium text-gray-600", htmlFor: "name", children: "Username" }), d.jsx("input", { id: "name", autoComplete: "name", name: "name", className: "block w-full px-4 py-2 text-gray-700 bg-white border rounded-lg focus:border-blue-400 focus:ring-opacity-40 focus:outline-none focus:ring focus:ring-blue-300", type: "text" })] }), d.jsxs("div", { className: "mt-4", children: [d.jsx("label", { className: "block mb-2 text-sm font-medium text-gray-600", htmlFor: "role", children: "Role" }), d.jsxs("select", { id: "role", name: "role", className: "block w-full px-4 py-2 text-gray-700 bg-white border rounded-lg focus:border-blue-400 focus:ring-opacity-40 focus:outline-none focus:ring focus:ring-blue-300", children: [d.jsx("option", { value: "buyer", children: "Buyer" }), d.jsx("option", { value: "seller", children: "Seller" }), d.jsx("option", { value: "admin", children: "Admin" })] })] }), d.jsxs("div", { className: "mt-4", children: [d.jsx("label", { className: "block mb-2 text-sm font-medium text-gray-600", htmlFor: "LoggingEmailAddress", children: "Email Address" }), d.jsx("input", { id: "LoggingEmailAddress", autoComplete: "email", name: "email", className: "block w-full px-4 py-2 text-gray-700 bg-white border rounded-lg focus:border-blue-400 focus:ring-opacity-40 focus:outline-none focus:ring focus:ring-blue-300", type: "email" })] }), d.jsxs("div", { className: "mt-4", children: [d.jsx("div", { className: "flex justify-between", children: d.jsx("label", { className: "block mb-2 text-sm font-medium text-gray-600", htmlFor: "loggingPassword", children: "Password" }) }), d.jsx("input", { id: "loggingPassword", name: "password", autoComplete: "new-password", className: "block w-full px-4 py-2 text-gray-700 bg-white border rounded-lg focus:border-blue-400 focus:ring-opacity-40 focus:outline-none focus:ring focus:ring-blue-300", type: "password" })] }), o && d.jsx("p", { className: " text-sm mb-4 text-red-500", children: o }), d.jsx("div", { className: "mt-4", children: d.jsx("button", { className: "w-full px-4 py-2 tracking-wide text-white transition-colors duration-300 transform bg-blue-600 rounded hover:bg-blue-500 focus:outline-none focus:bg-blue-500", children: "Register" }) })] })] }), d.jsx("div", { className: "hidden bg-cover lg:block lg:w-1/2", style: { backgroundImage: "url('https://images.unsplash.com/photo-1677705148585-1f2b218287a8?ixlib=rb-4.0.3&ixid=MnwxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8&auto=format&fit=crop&w=800&q=80')" } })] }) }) }, DN = () => { b.useContext(Ke); const t = Ll(), { _id: e, service_title: n, description: r, price: i, photo: s, provider: o } = t || {}, [l, a] = b.useState([]); return b.useEffect(() => { (async () => { const { data: u } = await re("undefined/job"); a(u) })() }, []), d.jsxs("div", { className: " border rounded-lg  p-5", children: [d.jsx("img", { className: "w-full lg:h-96 h-32 rounded-lg mb-5", src: s, alt: "" }), d.jsxs("div", { className: " grid md:grid-cols-2 grid-cols-1 rounded-md gap-8 ", children: [d.jsx("div", { className: "w-full shadow-lg lg:p-5 justify-between p-2  bg-[#e2e3e8]  border rounded-lg ", children: d.jsxs("div", { className: "", children: [d.jsxs("h1", { className: " lg:text-3xl text-xl font-semibold ", children: ["Service Name: ", n, " "] }), d.jsx("p", { className: "lg:text-lg ", children: r }), d.jsxs("p", { className: " text-lg font-bold  ", children: ["Price : ", i, "  "] })] }) }), d.jsxs("section", { className: " w-full shadow-lg border rounded-lg  bg-[#e2e3e8]  p-6 ", children: [d.jsx("h1", { className: " lg:text-3xl font-semibold ", children: "Service Provider Information" }), d.jsxs("div", { className: "flex items-center gap-5", children: [d.jsx("div", { className: "rounded-full object-cover overflow-hidden w-14 h-14 m-2", children: d.jsx("img", { src: o == null ? void 0 : o.photo, alt: "" }) }), d.jsxs("div", { children: [d.jsxs("p", { className: " text-sm   ", children: [" Name: ", o == null ? void 0 : o.name, " "] }), d.jsxs("p", { className: " text-sm  ", children: [" Area: ", o == null ? void 0 : o.area, " "] })] })] })] })] }), d.jsx("div", { className: " flex justify-center my-6", children: d.jsx(dr, { to: `/booked/${e}`, className: "btn min-w-full  bg-[#56bcd1bc]", children: "Book Now" }) })] }) }, MN = () => { const { user: t } = b.useContext(Ke), e = qr(), n = async r => { r.preventDefault(); const i = r.target, s = i.job_title.value, o = i.email.value, l = parseFloat(i.price.value), a = i.description.value, c = i.photo.value, u = i.area.value, f = { service_title: s, price: l, description: a, photo: c, area: u, buyer: { email: o, name: t == null ? void 0 : t.displayName, photo: t == null ? void 0 : t.photoURL } }; try { const { data: h } = await re.post("undefined/job", f); console.log(h), Br.success("Job Data Added Successfully!"), e("/my_posted_jobs") } catch (h) { console.log(h) } }; return d.jsx("div", { className: "flex justify-center items-center min-h-[calc(100vh-306px)] my-12 ", children: d.jsxs("section", { className: " p-2 md:p-6 mx-auto rounded-md shadow-2xl border bg-[#c4c4cc]", children: [d.jsx("h2", { className: "text-lg font-semibold  capitalize ", children: "Post a Service" }), d.jsx($l, { children: d.jsx("title", { children: "Add Service" }) }), d.jsxs("form", { onSubmit: n, children: [d.jsxs("div", { className: "grid grid-cols-1 gap-6 mt-4 sm:grid-cols-2", children: [d.jsxs("div", { children: [d.jsx("label", { className: " ", htmlFor: "job_title", children: "Service Name " }), d.jsx("input", { id: "job_title", name: "job_title", type: "text", className: "block w-full px-4 py-2 mt-2 text-gray-700 bg-white border border-gray-200 rounded-md  focus:border-blue-400 focus:ring-blue-300 focus:ring-opacity-40  focus:outline-none focus:ring" })] }), d.jsxs("div", { children: [d.jsx("label", { className: " ", htmlFor: "emailAddress", children: " Email Address " }), d.jsx("input", { id: "emailAddress", type: "email", name: "email", disabled: !0, defaultValue: t == null ? void 0 : t.email, className: "block w-full px-4 py-2 mt-2 text-gray-700 bg-white border border-gray-200 rounded-md  focus:border-blue-400 focus:ring-blue-300 focus:ring-opacity-40  focus:outline-none focus:ring" })] }), d.jsxs("div", { className: "flex flex-col  ", children: [d.jsx("h1", { children: "Service Area" }), d.jsx("input", { name: "area", type: "text", className: "block w-full px-4 py-2 mt-2 text-gray-700 bg-white border border-gray-200 rounded-md  focus:border-blue-400 focus:ring-blue-300 focus:ring-opacity-40  focus:outline-none focus:ring" })] }), d.jsxs("div", { children: [d.jsx("label", { className: "", htmlFor: "min_price", children: "Price" }), d.jsx("input", { id: "price", name: "price", type: "number", className: "block w-full px-4 py-2 mt-2 text-gray-700 bg-white border border-gray-200 rounded-md  focus:border-blue-400 focus:ring-blue-300 focus:ring-opacity-40  focus:outline-none focus:ring" })] }), d.jsxs("div", { className: "", children: [d.jsx("h1", { children: "Photo URL" }), d.jsx("input", { type: "text", id: "photo", name: "photo", className: "block w-full px-4 py-2 mt-2 text-gray-700 bg-white border border-gray-200 rounded-md  focus:border-blue-400 focus:ring-blue-300 focus:ring-opacity-4" })] })] }), d.jsxs("div", { className: "flex flex-col gap-2 mt-4", children: [d.jsx("label", { className: "", htmlFor: "description", children: " Description  " }), d.jsx("textarea", { className: "block w-full px-4 py-2 mt-2 text-gray-700 bg-white border border-gray-200 rounded-md  focus:border-blue-400 focus:ring-blue-300 focus:ring-opacity-40  focus:outline-none focus:ring", name: "description", id: "description" })] }), d.jsx("div", { className: "flex justify-center mt-6", children: d.jsx("button", { className: "px-8 py-2.5 leading-5 shadow-2xl border  bg-[#56bcd1bc]  transition-colors duration-300 transhtmlForm  rounded-md hover:bg-gray-600 focus:outline-none focus:bg-gray-600", children: " Add Services " }) })] })] }) }) }; var Kl = {}, cw = { exports: {} }, FN = "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED", UN = FN, zN = UN; function uw() { } function dw() { } dw.resetWarningCache = uw; var $N = function () { function t(r, i, s, o, l, a) { if (a !== zN) { var c = new Error("Calling PropTypes validators directly is not supported by the `prop-types` package. Use PropTypes.checkPropTypes() to call them. Read more at http://fb.me/use-check-prop-types"); throw c.name = "Invariant Violation", c } } t.isRequired = t; function e() { return t } var n = { array: t, bigint: t, bool: t, func: t, number: t, object: t, string: t, symbol: t, any: t, arrayOf: e, element: t, elementType: t, instanceOf: e, node: t, objectOf: e, oneOf: e, oneOfType: e, shape: e, exact: e, checkPropTypes: dw, resetWarningCache: uw }; return n.PropTypes = n, n }; cw.exports = $N(); var BN = cw.exports; Object.defineProperty(Kl, "__esModule", { value: !0 }); Kl.default = void 0; var HN = Object.assign || function (t) { for (var e = 1; e < arguments.length; e++) { var n = arguments[e]; for (var r in n) Object.prototype.hasOwnProperty.call(n, r) && (t[r] = n[r]) } return t }, VN = function () { function t(e, n) { for (var r = 0; r < n.length; r++) { var i = n[r]; i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(e, i.key, i) } } return function (e, n, r) { return n && t(e.prototype, n), r && t(e, r), e } }(), Yc, Um, WN = Kl.confirmAlert = tR, fw = b, Fn = pw(fw), GN = BN, Je = pw(GN), zm = Ta; function pw(t) { return t && t.__esModule ? t : { default: t } } function KN(t, e) { if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function") } function $m(t, e) { if (!t) throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); return e && (typeof e == "object" || typeof e == "function") ? e : t } function qN(t, e) { if (typeof e != "function" && e !== null) throw new TypeError("Super expression must either be null or a function, not " + typeof e); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, enumerable: !1, writable: !0, configurable: !0 } }), e && (Object.setPrototypeOf ? Object.setPrototypeOf(t, e) : t.__proto__ = e) } var Sd = (Um = Yc = function (t) { qN(e, t); function e() { var n, r, i, s; KN(this, e); for (var o = arguments.length, l = Array(o), a = 0; a < o; a++)l[a] = arguments[a]; return s = (r = (i = $m(this, (n = e.__proto__ || Object.getPrototypeOf(e)).call.apply(n, [this].concat(l))), i), i.handleClickButton = function (c) { c.onClick && c.onClick(), i.close() }, i.handleClickOverlay = function (c) { var u = i.props, f = u.closeOnClickOutside, h = u.onClickOutside, y = c.target === i.overlay; f && y && (h(), i.close()), c.stopPropagation() }, i.close = function () { var c = i.props.afterClose; eR(), QN(i.props), JN(c) }, i.keyboard = function (c) { var u = i.props, f = u.closeOnEscape, h = u.onKeypressEscape, y = u.onkeyPress, g = u.keyCodeForClose, w = c.keyCode, E = w === 27; g.includes(w) && i.close(), f && E && (h(c), i.close()), y && y() }, i.componentDidMount = function () { document.addEventListener("keydown", i.keyboard, !1) }, i.componentWillUnmount = function () { document.removeEventListener("keydown", i.keyboard, !1), i.props.willUnmount() }, i.renderCustomUI = function () { var c = i.props, u = c.title, f = c.message, h = c.buttons, y = c.customUI, g = { title: u, message: f, buttons: h, onClose: i.close }; return y(g) }, r), $m(i, s) } return VN(e, [{ key: "render", value: function () { var r = this, i = this.props, s = i.title, o = i.message, l = i.buttons, a = i.childrenElement, c = i.customUI, u = i.overlayClassName; return Fn.default.createElement("div", { className: "react-confirm-alert-overlay " + u, ref: function (h) { return r.overlay = h }, onClick: this.handleClickOverlay }, Fn.default.createElement("div", { className: "react-confirm-alert" }, c ? this.renderCustomUI() : Fn.default.createElement("div", { className: "react-confirm-alert-body" }, s && Fn.default.createElement("h1", null, s), o, a(), Fn.default.createElement("div", { className: "react-confirm-alert-button-group" }, l.map(function (f, h) { return Fn.default.createElement("button", HN({ key: h, className: f.className }, f, { onClick: function (g) { return r.handleClickButton(f) } }), f.label) }))))) } }]), e }(fw.Component), Yc.propTypes = { title: Je.default.string, message: Je.default.string, buttons: Je.default.array.isRequired, childrenElement: Je.default.func, customUI: Je.default.func, closeOnClickOutside: Je.default.bool, closeOnEscape: Je.default.bool, keyCodeForClose: Je.default.arrayOf(Je.default.number), willUnmount: Je.default.func, afterClose: Je.default.func, onClickOutside: Je.default.func, onKeypressEscape: Je.default.func, onkeyPress: Je.default.func, overlayClassName: Je.default.string }, Yc.defaultProps = { buttons: [{ label: "Cancel", onClick: function () { return null }, className: null }, { label: "Confirm", onClick: function () { return null }, className: null }], childrenElement: function () { return null }, closeOnClickOutside: !0, closeOnEscape: !0, keyCodeForClose: [], willUnmount: function () { return null }, afterClose: function () { return null }, onClickOutside: function () { return null }, onKeypressEscape: function () { return null } }, Um); Kl.default = Sd; var Es = null, Ed = "react-confirm-alert"; function YN() { var t = document.getElementById("react-confirm-alert-firm-svg"); if (!t) { var e = "http://www.w3.org/2000/svg", n = document.createElementNS(e, "feGaussianBlur"); n.setAttribute("stdDeviation", "0.3"); var r = document.createElementNS(e, "filter"); r.setAttribute("id", "gaussian-blur"), r.appendChild(n); var i = document.createElementNS(e, "svg"); i.setAttribute("id", "react-confirm-alert-firm-svg"), i.setAttribute("class", "react-confirm-alert-svg"), i.appendChild(r), document.body.appendChild(i) } } function JN(t) { var e = document.getElementById("react-confirm-alert-firm-svg"); e && e.parentNode.removeChild(e), document.body.children[0].classList.remove("react-confirm-alert-blur"), t() } function XN(t) { var e = document.getElementById(t.targetId || Ed); t.targetId && !e && console.error("React Confirm Alert:", "Can not get element id (#" + t.targetId + ")"), e ? (Es = (0, zm.createRoot)(e), Es.render(Fn.default.createElement(Sd, t))) : (document.body.children[0].classList.add("react-confirm-alert-blur"), e = document.createElement("div"), e.id = Ed, document.body.appendChild(e), Es = (0, zm.createRoot)(e), Es.render(Fn.default.createElement(Sd, t))) } function QN(t) { var e = document.getElementById(t.targetId || Ed); e && Es.unmount(e) } function ZN() { document.body.classList.add("react-confirm-alert-body-element") } function eR() { document.body.classList.remove("react-confirm-alert-body-element") } function tR(t) { ZN(), YN(), XN(t) } const nR = () => { const { user: t } = b.useContext(Ke), [e, n] = b.useState([]); console.log(e), b.useEffect(() => { r() }, [t]); const r = async () => { try { const s = await fetch(`undefined/jobs/${t == null ? void 0 : t.email}`); if (!s.ok) throw new Error("Failed to fetch data"); const o = await s.json(); n(o), console.log(o) } catch (s) { console.error("Error fetching data:", s) } }, i = async s => { try { WN({ title: "Confirm Deletion", message: "Are you sure you want to delete this item?", buttons: [{ label: "Yes", onClick: async () => { const { data: o } = await re.delete(`undefined/job/${s}`); console.log(o), Br.success("Delete Successful"), r() } }, { label: "No", onClick: () => { } }] }) } catch (o) { console.error(o), Br.error("Failed to delete item") } }; return d.jsx("div", { children: e.length > 0 ? d.jsxs("section", { className: "container px-4 mx-auto pt-12", children: [d.jsx($l, { children: d.jsx("title", { children: "My Posted Jobs" }) }), d.jsxs("div", { className: "flex items-center gap-x-3", children: [d.jsx("h2", { className: "text-lg font-medium  ", children: "My Posted Jobs" }), d.jsxs("span", { className: "px-3 py-1 text-xs text-blue-600 bg-blue-100 rounded-full ", children: [e.length, " Job"] })] }), d.jsx("div", { className: "flex flex-col mt-6", children: d.jsx("div", { className: "-mx-4 -my-2 overflow-x-auto sm:-mx-6 lg:-mx-8", children: d.jsx("div", { className: "inline-block min-w-full py-2 align-middle md:px-6 lg:px-8", children: d.jsx("div", { className: "overflow-hidden border border-gray-200  md:rounded-lg", children: d.jsxs("table", { className: "min-w-full divide-y divide-gray-200", children: [d.jsx("thead", { className: "", children: d.jsxs("tr", { children: [d.jsx("th", { scope: "col", className: "py-3.5 px-4 text-sm font-normal text-left rtl:text-right    ", children: d.jsx("div", { className: "flex items-center gap-x-3", children: d.jsx("span", { children: "Title" }) }) }), d.jsx("th", { scope: "col", className: "px-4 py-3.5 text-sm font-normal text-left rtl:text-right    ", children: d.jsx("button", { className: "flex items-center gap-x-2", children: d.jsx("span", { children: "Price " }) }) }), d.jsx("th", { scope: "col", className: "px-4 py-3.5 text-sm font-normal text-left rtl:text-right    ", children: "Date" }), d.jsx("th", { className: "px-4 py-3.5 text-sm font-normal text-left rtl:text-right    ", children: "Edit" })] }) }), d.jsx("tbody", { className: "     divide-y divide-gray-200 ", children: e.map(s => d.jsxs("tr", { children: [d.jsx("td", { className: "px-4 py-4 text-sm    whitespace-nowrap", children: s.service_title }), d.jsx("td", { className: "px-4 py-4 text-sm    whitespace-nowrap", children: s.price }), d.jsx("td", { title: s.area, className: "px-4 py-4 text-sm    whitespace-nowrap", children: s.area }), d.jsx("td", { className: "px-4 py-4 text-sm whitespace-nowrap", children: d.jsxs("div", { className: "flex items-center gap-x-6", children: [d.jsx("button", { onClick: () => i(s._id), className: "  transition-colors duration-200   hover:text-red-500 focus:outline-none", children: d.jsx("svg", { xmlns: "http://www.w3.org/2000/svg", fill: "none", viewBox: "0 0 24 24", strokeWidth: "1.5", stroke: "currentColor", className: "w-5 h-5", children: d.jsx("path", { strokeLinecap: "round", strokeLinejoin: "round", d: "M14.74 9l-.346 9m-4.788 0L9.26 9m9.968-3.21c.342.052.682.107 1.022.166m-1.022-.165L18.16 19.673a2.25 2.25 0 01-2.244 2.077H8.084a2.25 2.25 0 01-2.244-2.077L4.772 5.79m14.456 0a48.108 48.108 0 00-3.478-.397m-12 .562c.34-.059.68-.114 1.022-.165m0 0a48.11 48.11 0 013.478-.397m7.5 0v-.916c0-1.18-.91-2.164-2.09-2.201a51.964 51.964 0 00-3.32 0c-1.18.037-2.09 1.022-2.09 2.201v.916m7.5 0a48.667 48.667 0 00-7.5 0" }) }) }), d.jsx(dr, { to: `/update/${s._id}`, className: "  transition-colors duration-200   hover:text-yellow-500 focus:outline-none", children: d.jsx("svg", { xmlns: "http://www.w3.org/2000/svg", fill: "none", viewBox: "0 0 24 24", strokeWidth: "1.5", stroke: "currentColor", className: "w-5 h-5", children: d.jsx("path", { strokeLinecap: "round", strokeLinejoin: "round", d: "M16.862 4.487l1.687-1.688a1.875 1.875 0 112.652 2.652L10.582 16.07a4.5 4.5 0 01-1.897 1.13L6 18l.8-2.685a4.5 4.5 0 011.13-1.897l8.932-8.931zm0 0L19.5 7.125M18 14v4.75A2.25 2.25 0 0115.75 21H5.25A2.25 2.25 0 013 18.75V8.25A2.25 2.25 0 015.25 6H10" }) }) })] }) })] }, s._id)) })] }) }) }) }) })] }) : d.jsx("p", { className: "text-6xl font-bold text-center text-red-700", children: "You Have No Data Pushed on the Form" }) }) }, rR = () => { const t = qr(), e = Ll(); console.log(e); const { _id: n, service_title: r, price: i, description: s } = e || {}, { user: o } = b.useContext(Ke), l = async a => { a.preventDefault(); const c = a.target, u = c.job_title.value, f = c.email.value, h = parseFloat(c.price.value), y = c.description.value, g = c.photo.value, w = { service_title: u, price: h, description: y, photo: g, buyer: { email: f, name: o == null ? void 0 : o.displayName, photo: o == null ? void 0 : o.photoURL } }; try { const { data: E } = await re.put(`undefined/job/${n}`, w); console.log(E), Br.success("Job Data Updated Successfully!"), t("/my_posted_jobs") } catch (E) { console.log(E), Br.error(E.message) } }; return d.jsx("div", { className: "flex justify-center items-center min-h-[calc(100vh-306px)] my-12", children: d.jsxs("section", { className: " p-2 md:p-6 mx-auto bg-white rounded-md shadow-2xl ", children: [d.jsx("h2", { className: "text-lg font-semibold text-gray-700 capitalize ", children: "Post a Service" }), d.jsxs("form", { onSubmit: l, children: [d.jsxs("div", { className: "grid grid-cols-1 gap-6 mt-4 sm:grid-cols-2", children: [d.jsxs("div", { children: [d.jsx("label", { className: "text-gray-700 ", htmlFor: "job_title", children: "Service Name " }), d.jsx("input", { id: "job_title", name: "job_title", type: "text", defaultValue: r, className: "block w-full px-4 py-2 mt-2 text-gray-700 bg-white border border-gray-200 rounded-md  focus:border-blue-400 focus:ring-blue-300 focus:ring-opacity-40  focus:outline-none focus:ring" })] }), d.jsxs("div", { children: [d.jsx("label", { className: "text-gray-700 ", htmlFor: "emailAddress", children: " Email Address " }), d.jsx("input", { id: "emailAddress", type: "email", name: "email", disabled: !0, defaultValue: o == null ? void 0 : o.email, className: "block w-full px-4 py-2 mt-2 text-gray-700 bg-white border border-gray-200 rounded-md  focus:border-blue-400 focus:ring-blue-300 focus:ring-opacity-40  focus:outline-none focus:ring" })] }), d.jsxs("div", { className: "flex flex-col  ", children: [d.jsx("h1", { children: "Service Area" }), d.jsx("input", { type: "text", defaultValue: "", className: "block w-full px-4 py-2 mt-2 text-gray-700 bg-white border border-gray-200 rounded-md  focus:border-blue-400 focus:ring-blue-300 focus:ring-opacity-40  focus:outline-none focus:ring" })] }), d.jsxs("div", { children: [d.jsx("label", { className: "text-gray-700 ", htmlFor: "min_price", children: "Price" }), d.jsx("input", { id: "price", name: "price", type: "number", className: "block w-full px-4 py-2 mt-2 text-gray-700 bg-white border border-gray-200 rounded-md  focus:border-blue-400 focus:ring-blue-300 focus:ring-opacity-40  focus:outline-none focus:ring" })] }), d.jsxs("div", { className: "  ", children: [d.jsx("h1", { children: "Photo URL" }), d.jsx("input", { type: "text", name: "photo", className: "block w-full px-4 py-2 mt-2 text-gray-700 bg-white border border-gray-200 rounded-md  focus:border-blue-400 focus:ring-blue-300 focus:ring-opacity-4" })] })] }), d.jsxs("div", { className: "flex flex-col gap-2 mt-4", children: [d.jsx("label", { className: "text-gray-700 ", htmlFor: "description", children: " Description  " }), d.jsx("textarea", { className: "block w-full px-4 py-2 mt-2 text-gray-700 bg-white border border-gray-200 rounded-md  focus:border-blue-400 focus:ring-blue-300 focus:ring-opacity-40  focus:outline-none focus:ring", name: "description", id: "description" })] }), d.jsx("div", { className: "flex justify-center mt-6", children: d.jsx("button", { className: "px-8 py-2.5 leading-5 text-white transition-colors duration-300 transhtmlForm bg-gray-700 rounded-md hover:bg-gray-600 focus:outline-none focus:bg-gray-600", children: " Update Services " }) })] })] }) }) }, iR = ({ job: t }) => { const { _id: e, description: n, service_title: r, price: i, photo: s, provider: o } = t || {}; return d.jsxs("div", { className: "w-full  p-5 relative border rounded-md shadow-md hover:scale-[1.05] transition-all bg-[#a3a4ac]", children: [d.jsx("img", { className: "w-full h-48 rounded-t-xl", src: s, alt: "" }), d.jsxs("div", { children: [d.jsxs("h1", { className: "mt-2 text-lg font-semibold  ", children: [" ", r, " "] }), d.jsxs("p", { title: n, className: "mt-2 text-sm ", children: [" ", n.substring(0, 100), "... "] }), d.jsxs("p", { children: ["Price : ", i] })] }), d.jsxs("div", { className: "flex justify-between ", children: [d.jsxs("div", { className: " shadow-lg p-5 ab bottom-0 border", children: [d.jsx("h1", { className: "text-center", children: "Provider" }), d.jsx("img", { className: "rounded-full", src: o == null ? void 0 : o.photo, alt: "" }), d.jsxs("h1", { children: [" ", o == null ? void 0 : o.name] })] }), d.jsx(dr, { to: `/job/${e}`, className: "absolute bottom-3 right-3   btn btn-lg mt-7  bg-[#56bcd1bc]", children: "View Details" })] })] }) }, sR = () => { const [t, e] = b.useState(4), [n, r] = b.useState(0), [i, s] = b.useState(1), [o, l] = b.useState([]); b.useEffect(() => { (async () => { const { data: h } = await re("undefined/jobs"); l(h) })() }, []), b.useEffect(() => { (async () => { const { data: h } = await re("undefined/jobs-count"); r(h.count) })() }, []); const a = Math.ceil(n / t), c = [...Array(a).keys()].map(f => f + 1); console.log(c); const u = f => { console.log(f), s(f) }; return d.jsxs("div", { className: "container px-6 py-10 mx-auto min-h-[calc(100vh-306px)] flex flex-col justify-between", children: [d.jsxs("div", { children: [d.jsxs("div", { className: "flex flex-col md:flex-row justify-center items-center gap-5 ", children: [d.jsx("div", { children: d.jsxs("select", { name: "category", id: "category", className: "border p-4 rounded-lg", children: [d.jsx("option", { value: "", children: "Filter By Category" }), d.jsx("option", { value: "Web Development", children: "Web Development" }), d.jsx("option", { value: "Graphics Design", children: "Graphics Design" }), d.jsx("option", { value: "Digital Marketing", children: "Digital Marketing" })] }) }), d.jsx("form", { children: d.jsxs("div", { className: "flex p-1 overflow-hidden border rounded-lg    focus-within:ring focus-within:ring-opacity-40 focus-within:border-blue-400 focus-within:ring-blue-300", children: [d.jsx("input", { className: "px-6 py-2  placeholder-gray-500 bg-white outline-none focus:placeholder-transparent", type: "text", name: "search", placeholder: "Enter Job Title", "aria-label": "Enter Job Title" }), d.jsx("button", { className: "px-1 md:px-4 py-3 text-sm font-medium tracking-wider  uppercase transition-colors duration-300 transform bg-gray-700 rounded-md hover:bg-gray-600 focus:bg-gray-600 focus:outline-none", children: "Search" })] }) }), d.jsx("div", { children: d.jsxs("select", { name: "category", id: "category", className: "border p-4 rounded-md", children: [d.jsx("option", { value: "", children: "Sort By Deadline" }), d.jsx("option", { value: "dsc", children: "Descending Order" }), d.jsx("option", { value: "asc", children: "Ascending Order" })] }) }), d.jsx("button", { className: "btn", children: "Reset" })] }), d.jsx("div", { className: "grid grid-cols-1 gap-8 mt-8 xl:mt-16 md:grid-cols-2 lg:grid-cols-3 xl:grid-cols-4", children: o.map(f => d.jsx(iR, { job: f }, f._id)) })] }), d.jsxs("div", { className: "flex justify-center mt-12", children: [d.jsx("button", { className: "px-4 py-2 mx-1   capitalize bg-gray-200 rounded-md disabled:cursor-not-allowed disabled:hover:bg-gray-200 disabled:hover:text-gray-500 hover:bg-blue-500  hover:text-white", children: d.jsxs("div", { className: "flex items-center -mx-1", children: [d.jsx("svg", { xmlns: "http://www.w3.org/2000/svg", className: "w-6 h-6 mx-1 rtl:-scale-x-100", fill: "none", viewBox: "0 0 24 24", stroke: "currentColor", children: d.jsx("path", { strokeLinecap: "round", strokeLinejoin: "round", strokeWidth: "2", d: "M7 16l-4-4m0 0l4-4m-4 4h18" }) }), d.jsx("span", { className: "mx-1", children: "previous" })] }) }), c.map(f => d.jsx("button", { onClick: () => u(f), className: "hidden px-4 py-2 mx-1 transition-colors duration-300 transform  rounded-md sm:inline hover:bg-blue-500  hover:text-white", children: f }, f)), d.jsx("button", { className: "px-4 py-2 mx-1  transition-colors duration-300 transform bg-gray-200 rounded-md hover:bg-blue-500 disabled:hover:bg-gray-200 disabled:hover:text-gray-500 hover:text-white disabled:cursor-not-allowed disabled:text-gray-500", children: d.jsxs("div", { className: "flex items-center -mx-1", children: [d.jsx("span", { className: "mx-1", children: "Next" }), d.jsx("svg", { xmlns: "http://www.w3.org/2000/svg", className: "w-6 h-6 mx-1 rtl:-scale-x-100", fill: "none", viewBox: "0 0 24 24", stroke: "currentColor", children: d.jsx("path", { strokeLinecap: "round", strokeLinejoin: "round", strokeWidth: "2", d: "M17 8l4 4m0 0l-4 4m4-4H3" }) })] }) })] })] }) }, oR = () => { const { user: t } = b.useContext(Ke), [e, n] = b.useState([]); b.useEffect(() => { r() }, [t]); const r = async () => { try { const i = await fetch(`undefined/bid/${t == null ? void 0 : t.email}`); if (!i.ok) throw new Error("Failed to fetch data"); const s = await i.json(); n(s) } catch (i) { console.error("Error fetching data:", i) } }; return d.jsx("div", { children: e.length > 0 ? d.jsxs("section", { className: "container px-4 mx-auto pt-12", children: [d.jsx($l, { children: d.jsx("title", { children: "My Booked Services" }) }), d.jsxs("div", { className: "flex items-center gap-x-3", children: [d.jsx("h2", { className: "text-lg font-medium  ", children: "My Booked Jobs" }), d.jsxs("span", { className: "px-3 py-1 text-xs text-blue-600 bg-blue-100 rounded-full ", children: [e.length, " Job"] })] }), d.jsx("div", { className: "flex flex-col mt-6", children: d.jsx("div", { className: "-mx-4 -my-2 overflow-x-auto sm:-mx-6 lg:-mx-8", children: d.jsx("div", { className: "inline-block min-w-full py-2 align-middle md:px-6 lg:px-8", children: d.jsx("div", { className: "overflow-hidden border border-gray-200  md:rounded-lg", children: d.jsxs("table", { className: "min-w-full divide-y divide-gray-200 ", children: [d.jsx("thead", { className: "", children: d.jsxs("tr", { children: [d.jsx("th", { scope: "col", className: "px-4 text-sm font-normal text-center  text-gray-500", children: d.jsx("div", { className: "flex items-center mx-auto gap-x-3", children: d.jsx("span", { children: "Title" }) }) }), d.jsx("th", { scope: "col", className: "px-4 py-3.5 text-sm font-normal text-left rtl:text-right ", children: d.jsx("button", { className: "flex items-center gap-x-2", children: d.jsx("span", { children: "Price" }) }) }), d.jsx("th", { scope: "col", className: "px-4 py-3.5 text-sm font-normal text-left rtl:text-right ", children: "Date  " })] }) }), d.jsx("tbody", { className: " divide-y divide-gray-200 ", children: e.map(i => d.jsxs("tr", { children: [d.jsx("td", { className: "px-4 py-4 text-sm   whitespace-nowrap", children: i._id }), d.jsx("td", { className: "px-4 py-4 text-sm   whitespace-nowrap", children: i.price || "null" }), d.jsx("td", { title: i.area, className: "px-4 py-4 text-sm   whitespace-nowrap", children: i.date }), d.jsx("td", { className: "px-4 py-4 text-sm whitespace-nowrap", children: d.jsx("h1", { children: i.comment }) })] }, i._id)) })] }) }) }) }) })] }) : d.jsx("p", { className: "text-6xl font-bold text-center text-red-700", children: "You Have No Booked Data" }) }) }, aR = () => { const { user: t } = b.useContext(Ke); console.log(t); const e = Ll(), { _id: n, service_title: r, price: i, photo: s, provider: o } = e || {}, l = async a => { if (a.preventDefault(), (t == null ? void 0 : t.email) === (o == null ? void 0 : o.email)) return Br.error("Action not permitted!"); const c = a.target, u = n, f = parseFloat(c.price.value), h = c.comment.value, y = t == null ? void 0 : t.email, g = "Pending", w = c.service_title.value, E = c.date.value, v = { jobId: u, price: f, comment: h, email: y, buyer_email: t == null ? void 0 : t.email, status: g, provider: o, service_title: w, date: E }; console.log(v); try { const { data: p } = await re.post("undefined/bid", v); console.log(p), p.insertedId && Br.success("data added successfully") } catch (p) { console.log(p), console.log("Hi, i am error", p.message) } }; return d.jsxs("section", { className: "p-6 w-full   rounded-md shadow-md flex-1 md:min-h-[350px] bg-[#a3a4ac]", children: [d.jsx("h2", { className: "text-lg font-semibold   capitalize ", children: " Get this service " }), d.jsx("img", { className: "w-full h-96", src: s, alt: "" }), d.jsxs("form", { onSubmit: l, children: [d.jsxs("div", { className: "grid grid-cols-1 gap-6 mt-4 sm:grid-cols-2", children: [d.jsxs("div", { children: [d.jsx("label", { className: "  ", htmlFor: "price", children: " Service title " }), d.jsx("input", { id: "service_title", type: "text", name: "service_title", defaultValue: r, className: "block w-full px-4 py-2 mt-2   bg-white border border-gray-200 rounded-md   focus:border-blue-400 focus:ring-blue-300 focus:ring-opacity-40  focus:outline-none focus:ring" })] }), d.jsxs("div", { children: [d.jsx("label", { className: "  ", htmlFor: "price", children: " Service Id" }), d.jsx("input", { id: "service_title", type: "text", name: "service_title", defaultValue: n, className: "block w-full px-4 py-2 mt-2   bg-white border border-gray-200 rounded-md   focus:border-blue-400 focus:ring-blue-300 focus:ring-opacity-40  focus:outline-none focus:ring" })] }), d.jsxs("div", { children: [d.jsx("label", { className: "  ", htmlFor: "price", children: " Price " }), d.jsx("input", { id: "price", type: "text", name: "price", readOnly: !0, defaultValue: i, value: i, className: "block w-full px-4 py-2 mt-2   bg-white border border-gray-200 rounded-md   focus:border-blue-400 focus:ring-blue-300 focus:ring-opacity-40  focus:outline-none focus:ring" })] }), d.jsxs("div", { children: [d.jsx("label", { className: "  ", htmlFor: "price", children: " Provider Name  " }), d.jsx("input", { id: "price", type: "text", name: "price", className: "block w-full px-4 py-2 mt-2   bg-white border border-gray-200 rounded-md   focus:border-blue-400 focus:ring-blue-300 focus:ring-opacity-40  focus:outline-none focus:ring" })] }), d.jsxs("div", { children: [d.jsx("label", { className: "  ", htmlFor: "emailAddress", children: " My Email Address " }), d.jsx("input", { id: "emailAddress", type: "email", name: "email", disabled: !0, defaultValue: t == null ? void 0 : t.email, readOnly: !0, className: "block w-full px-4 py-2 mt-2   bg-white border border-gray-200 rounded-md   focus:border-blue-400 focus:ring-blue-300 focus:ring-opacity-40  focus:outline-none focus:ring" })] }), d.jsxs("div", { children: [d.jsx("label", { className: "  ", htmlFor: "emailAddress", children: " My Name  " }), d.jsx("input", { id: "emailAddress", type: "email", name: "email", disabled: !0, defaultValue: t == null ? void 0 : t.displayName, readOnly: !0, className: "block w-full px-4 py-2 mt-2   bg-white border border-gray-200 rounded-md   focus:border-blue-400 focus:ring-blue-300 focus:ring-opacity-40  focus:outline-none focus:ring" })] }), d.jsxs("div", { children: [d.jsx("label", { className: "  ", htmlFor: "comment", children: " Instruction " }), d.jsx("input", { id: "comment", name: "comment", type: "text", className: "block w-full px-4 py-2 mt-2   bg-white border border-gray-200 rounded-md   focus:border-blue-400 focus:ring-blue-300 focus:ring-opacity-40  focus:outline-none focus:ring" })] }), d.jsxs("div", { children: [d.jsx("label", { className: "  ", htmlFor: "comment", children: " Service Taking Date " }), d.jsx("input", { id: "comment", name: "date", type: "date", className: "block w-full px-4 py-2 mt-2   bg-white border border-gray-200 rounded-md   focus:border-blue-400 focus:ring-blue-300 focus:ring-opacity-40  focus:outline-none focus:ring" })] })] }), d.jsx("div", { className: "flex justify-end mt-6", children: d.jsx("button", { type: "submit", className: "px-8 py-2.5 leading-5 text-white transition-colors duration-300 transform bg-gray-700 rounded-md hover:bg-gray-600 focus:outline-none focus:bg-gray-600", children: " Purchase " }) })] })] }) }, lR = () => d.jsxs("div", { className: "text-center mt-96 space-y-10", children: [d.jsx("h1", { className: "text-6xl font-bold", children: "Oops! Something went wrong." }), d.jsx("p", { className: "text-5xl font-medium", children: "We apologize for the inconvenience." }), d.jsx(dr, { to: "/", className: "btn text-3xl  bg-green-500 text-white", children: " Back to Home" })] }), hs = ({ children: t }) => { const { user: e, loading: n } = b.useContext(Ke), r = Kr(); return console.log(r.pathname), e ? t : n ? d.jsx("div", { children: "Loading..." }) : d.jsx(xE, { state: r.pathname, to: "/login" }) }; function cR() { const { user: t } = b.useContext(Ke), [e, n] = b.useState([]), [r, i] = b.useState([]), [s, o] = b.useState(!0), [l, a] = b.useState(null), [c, u] = b.useState(""), [f, h] = b.useState(""), [y, g] = b.useState(""), [w, E] = b.useState(""); b.useEffect(() => { t != null && t.email && v() }, [t == null ? void 0 : t.email]); const v = async () => { try { const { data: P } = await re.get("https://wave55.vercel.app/products"); n(P), i(P) } catch (P) { a(P.message) } finally { o(!1) } }, p = P => { const I = P.target.value.toLowerCase(); u(I), x({ term: I }) }, m = P => { h(P), x({ order: P }) }, S = P => { g(P), x({ category: P }) }, T = P => { E(P), x({ brand: P }) }, x = ({ term: P = c, order: I = f, category: N = y, brand: k = w }) => { let j = e; P && (j = j.filter(F => F.name.toLowerCase().includes(P))), N && (j = j.filter(F => F.category === N)), k && (j = j.filter(F => F.brand === k)), I === "asc" ? j = [...j].sort((F, D) => F.price - D.price) : I === "desc" && (j = [...j].sort((F, D) => D.price - F.price)), i(j) }; return d.jsxs("div", { className: "p-6 min-h-screen bg-gray-50", children: [d.jsx("h1", { className: "text-3xl font-bold mb-6 text-center text-gray-800", children: "Our Products" }), d.jsxs("div", { className: "mb-6 flex flex-wrap gap-4 justify-center", children: [d.jsx("input", { type: "text", placeholder: "Search products...", value: c, onChange: p, className: "w-64 p-2 border rounded-lg shadow-sm focus:outline-none focus:ring focus:border-blue-300" }), d.jsxs("select", { value: f, onChange: P => m(P.target.value), className: "p-2 border rounded-lg shadow-sm focus:outline-none focus:ring focus:border-blue-300", children: [d.jsx("option", { value: "", children: "Sort by Price" }), d.jsx("option", { value: "asc", children: "Price: Low to High" }), d.jsx("option", { value: "desc", children: "Price: High to Low" })] }), d.jsxs("select", { value: y, onChange: P => S(P.target.value), className: "p-2 border rounded-lg shadow-sm focus:outline-none focus:ring focus:border-blue-300", children: [d.jsx("option", { value: "", children: "Filter by Category" }), Array.from(new Set(e.map(P => P.category))).map((P, I) => d.jsx("option", { value: P, children: P }, I))] }), d.jsxs("select", { value: w, onChange: P => T(P.target.value), className: "p-2 border rounded-lg shadow-sm focus:outline-none focus:ring focus:border-blue-300", children: [d.jsx("option", { value: "", children: "Filter by Brand" }), Array.from(new Set(e.map(P => P.brand))).map((P, I) => d.jsx("option", { value: P, children: P }, I))] })] }), s ? d.jsx("p", { className: "text-center text-gray-500", children: "Loading products..." }) : l ? d.jsxs("p", { className: "text-red-500 text-center", children: ["Error: ", l] }) : r.length === 0 ? d.jsx("p", { className: "text-center text-gray-500", children: "No products match your criteria." }) : d.jsx("div", { className: "grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-3 gap-6", children: r.map(P => d.jsxs("div", { className: "border p-4 rounded-lg shadow-md bg-white hover:shadow-lg transition-shadow duration-300", children: [d.jsx("img", { src: P.image || "https://via.placeholder.com/150", alt: P.name, className: "w-full h-48 object-cover rounded-md mb-4" }), d.jsx("h2", { className: "text-lg font-semibold text-gray-800", children: P.name }), d.jsxs("p", { className: "text-gray-600 mt-2", children: ["Price: ", d.jsxs("span", { className: "text-blue-500 font-medium", children: ["$", P.price] })] }), d.jsxs("p", { className: "text-gray-500", children: ["Category: ", P.category] }), d.jsxs("p", { className: "text-gray-500", children: ["Brand: ", P.brand] }), d.jsxs("p", { className: "text-gray-500 line-clamp-2", children: ["Description: ", P.description] }), d.jsx("button", { className: "mt-4 w-full bg-blue-500 text-white py-2 rounded-lg hover:bg-blue-600 transition duration-300", children: "Add to wishlist" })] }, P._id)) })] }) } function uR() { return d.jsx("div", { children: d.jsx("ul", { className: "flex flex-col gap-5 mb-8 mt-10 ", children: d.jsx("li", { children: d.jsx(St, { className: "btn  w-full", to: "/dashboard/buyerwishlist", children: "WishList" }) }) }) }) } function dR() { return d.jsx("div", { children: d.jsxs("ul", { className: "flex flex-col gap-5 mb-8 mt-10 ", children: [d.jsx("li", { children: d.jsx(St, { className: "btn  w-full", to: "/dashboard/addProduct", children: "Add New product" }) }), d.jsx("li", { children: d.jsx(St, { className: "btn  w-full", to: "/dashboard/listedProduct", children: "listed Product" }) })] }) }) } function fR() { return d.jsx("div", { children: d.jsx("ul", { className: "flex flex-col gap-5 mb-8 mt-10 ", children: d.jsx("li", { children: d.jsx(St, { className: "btn  w-full", to: "/dashboard/viewalluser", children: "View All Users" }) }) }) }) } function pR() { const t = qr(), { user: e, logOut: n } = b.useContext(Ke), [r, i] = b.useState(null), [s, o] = b.useState(!0), [l, a] = b.useState(null), c = () => { n(), t("/") }; console.log("User:", e), b.useEffect(() => { console.log("User in useEffect:", e), e != null && e.email && u() }, [e == null ? void 0 : e.email]); const u = async () => { try { const { data: f } = await re.get(`https://wave55.vercel.app/users/${e.email}`); console.log("Fetched Data:", f), i(f) } catch (f) { console.error("Error fetching data:", f.message), a(f.message) } finally { o(!1) } }; return s ? d.jsx("div", { children: "Loading..." }) : l ? d.jsxs("div", { children: ["Error: ", l] }) : d.jsxs("div", { className: "flex flex-col h-screen justify-between", children: [d.jsxs("div", { children: [(r == null ? void 0 : r.role) === "buyer" && d.jsx(uR, {}), (r == null ? void 0 : r.role) === "seller" && d.jsx(dR, {}), (r == null ? void 0 : r.role) === "admin" && d.jsx(fR, {})] }), d.jsx("div", { children: d.jsx("button", { onClick: () => c(), className: "w-full btn", children: "Log Out" }) })] }) } function hR() { return d.jsx("div", { className: "border-2 border-black min-h-screen", children: d.jsx("div", { children: d.jsx(pR, {}) }) }) } function mR() { return d.jsxs("div", { className: "grid grid-cols-12", children: [d.jsx("div", { className: "col-span-2", children: d.jsx(hR, {}) }), d.jsx("div", { className: "col-span-10", children: d.jsx(hy, {}) })] }) } const gR = () => { const { user: t } = b.useContext(Ke), [e, n] = b.useState({ name: "", price: "", category: "", brand: "", description: "", email: t.email }), [r, i] = b.useState(!1), [s, o] = b.useState(null), l = c => { const { name: u, value: f } = c.target; n({ ...e, [u]: f }) }, a = async c => { var u, f; c.preventDefault(), i(!0), o(null); try { const h = await re.post("https://wave55.vercel.app/product", e, { headers: { "Content-Type": "application/json" } }); console.log("Submitted Product:", h.data), alert("Product submitted successfully!"), n({ name: "", price: "", category: "", brand: "", description: "" }) } catch (h) { o(((f = (u = h.response) == null ? void 0 : u.data) == null ? void 0 : f.message) || "Failed to submit product. Please try again.") } finally { i(!1) } }; return d.jsxs("div", { style: { margin: "20px" }, children: [d.jsx("h3", { children: "Add Product" }), s && d.jsx("p", { style: { color: "red" }, children: s }), d.jsxs("form", { onSubmit: a, style: { maxWidth: "400px" }, children: [d.jsxs("div", { style: { marginBottom: "10px" }, children: [d.jsx("label", { children: "Name:" }), d.jsx("input", { type: "text", name: "name", value: e.name, onChange: l, placeholder: "Enter product name", style: { width: "100%" }, required: !0 })] }), d.jsxs("div", { style: { marginBottom: "10px" }, children: [d.jsx("label", { children: "Price:" }), d.jsx("input", { type: "number", name: "price", value: e.price, onChange: l, placeholder: "Enter product price", style: { width: "100%" }, required: !0 })] }), d.jsxs("div", { style: { marginBottom: "10px" }, children: [d.jsx("label", { children: "Category:" }), d.jsx("input", { type: "text", name: "category", value: e.category, onChange: l, placeholder: "Enter product category", style: { width: "100%" }, required: !0 })] }), d.jsxs("div", { style: { marginBottom: "10px" }, children: [d.jsx("label", { children: "Brand:" }), d.jsx("input", { type: "text", name: "brand", value: e.brand, onChange: l, placeholder: "Enter product brand", style: { width: "100%" }, required: !0 })] }), d.jsxs("div", { style: { marginBottom: "10px" }, children: [d.jsx("label", { children: "Description:" }), d.jsx("textarea", { name: "description", value: e.description, onChange: l, placeholder: "Enter product description", style: { width: "100%" }, required: !0 })] }), d.jsx("button", { type: "submit", style: { marginRight: "10px" }, disabled: r, children: r ? "Submitting..." : "Submit" }), d.jsx("button", { type: "reset", onClick: () => n({ name: "", price: "", category: "", brand: "", description: "" }), disabled: r, children: "Reset" })] })] }) }; function vR() { const [t, e] = b.useState([]), [n, r] = b.useState(null), { user: i, loading: s } = b.useContext(Ke); b.useEffect(() => { !s && (i != null && i.email) && o() }, [s, i == null ? void 0 : i.email]); const o = async () => { try { const a = await re.get(`https://wave55.vercel.app/products/${i.email}`); e(a.data), console.log(a.data) } catch (a) { console.error("Error fetching product:", a), r(a.message) } }, l = async a => { try { await re.delete(`https://wave55.vercel.app/products/${a}`), e(t.filter(c => c._id !== a)), console.log("Product deleted successfully") } catch (c) { console.error("Error deleting product:", c), r(c.message) } }; return s ? d.jsx("div", { className: "text-center mt-5", children: "Loading user data..." }) : n ? d.jsxs("div", { className: "text-center mt-5 text-red-500", children: ["Error: ", n] }) : i != null && i.email ? d.jsxs("div", { children: [d.jsx("h1", { children: "View Product Page" }), (t == null ? void 0 : t.length) > 0 ? d.jsxs("table", { className: "table-auto w-full border-collapse", children: [d.jsx("thead", { children: d.jsxs("tr", { children: [d.jsx("th", { className: "px-4 py-2 border", children: "Name" }), d.jsx("th", { className: "px-4 py-2 border", children: "Email" }), d.jsx("th", { className: "px-4 py-2 border", children: "Price" }), d.jsx("th", { className: "px-4 py-2 border", children: "Description" }), d.jsx("th", { className: "px-4 py-2 border", children: "Actions" })] }) }), d.jsx("tbody", { children: t.map((a, c) => d.jsxs("tr", { children: [d.jsx("td", { className: "px-4 py-2 border", children: a.name }), d.jsx("td", { className: "px-4 py-2 border", children: a.email }), d.jsx("td", { className: "px-4 py-2 border", children: a.price }), d.jsx("td", { className: "px-4 py-2 border", children: a.description }), d.jsx("td", { className: "px-4 py-2 border", children: d.jsx("button", { className: "bg-red-500 text-white py-1 px-3 rounded", onClick: () => l(a._id), children: "Delete" }) })] }, a._id)) })] }) : d.jsx("p", { children: "Loading product data..." })] }) : d.jsx("div", { className: "text-center mt-5", children: "No user logged in." }) } function yR() { return d.jsx("div", { children: "editProductPage" }) } function wR() { const { user: t } = b.useContext(Ke), [e, n] = b.useState([]), [r, i] = b.useState(!0), [s, o] = b.useState(null), [l, a] = b.useState(null), [c, u] = b.useState(""); b.useEffect(() => { t != null && t.email && f() }, [t == null ? void 0 : t.email]); const f = async () => { try { const { data: g } = await re.get("https://wave55.vercel.app/users"); n(g) } catch (g) { o(g.message) } finally { i(!1) } }, h = async g => { const w = e.map(E => E.email === g ? { ...E, role: c } : E); n(w); try { const E = await re.put(`https://wave55.vercel.app/users/${g}`, { role: c }); console.log("Response after role update:", E), f(), a(null) } catch (E) { console.error("Error changing role:", E.message), f() } }, y = async g => { if (console.log("Deleting user:", g), window.confirm("Are you sure you want to delete this user?")) try { await re.delete(`https://wave55.vercel.app/users/${g}`), f(), n(e) } catch (w) { console.error("Error deleting user:", w.message) } }; return r ? d.jsx("div", { className: "text-center mt-5", children: "Loading..." }) : s ? d.jsxs("div", { className: "text-center mt-5 text-red-500", children: ["Error: ", s] }) : d.jsxs("div", { className: "p-5", children: [d.jsx("h1", { className: "text-2xl font-bold mb-5", children: "All Users" }), e && e.length > 0 ? d.jsxs("table", { className: "table-auto w-full border-collapse border border-gray-200", children: [d.jsx("thead", { children: d.jsxs("tr", { className: "bg-gray-100", children: [d.jsx("th", { className: "border border-gray-300 px-4 py-2", children: "#" }), d.jsx("th", { className: "border border-gray-300 px-4 py-2", children: "Name" }), d.jsx("th", { className: "border border-gray-300 px-4 py-2", children: "Email" }), d.jsx("th", { className: "border border-gray-300 px-4 py-2", children: "Role" }), d.jsx("th", { className: "border border-gray-300 px-4 py-2", children: "Actions" })] }) }), d.jsx("tbody", { children: e.map((g, w) => d.jsxs("tr", { className: "text-center", children: [d.jsx("td", { className: "border border-gray-300 px-4 py-2", children: w + 1 }), d.jsx("td", { className: "border border-gray-300 px-4 py-2", children: g.name || "N/A" }), d.jsx("td", { className: "border border-gray-300 px-4 py-2", children: g.email }), d.jsx("td", { className: "border border-gray-300 px-4 py-2", children: g.role }), d.jsxs("td", { className: "border border-gray-300 px-4 py-2", children: [d.jsx("button", { onClick: () => { a(g.email), u(g.role) }, className: "bg-yellow-500 text-white px-3 py-1 rounded mr-2", children: "Edit Role" }), d.jsx("button", { onClick: () => y(g.email), className: "bg-red-500 text-white px-3 py-1 rounded", children: "Delete" })] })] }, w)) })] }) : d.jsx("div", { className: "text-center text-gray-500", children: "No users found." }), l && d.jsx("div", { className: "fixed inset-0 bg-gray-600 bg-opacity-50 flex justify-center items-center", children: d.jsxs("div", { className: "bg-white p-5 rounded-md shadow-lg w-1/3", children: [d.jsx("h2", { className: "text-xl font-bold mb-4", children: "Edit User Role" }), d.jsxs("select", { value: c, onChange: g => u(g.target.value), className: "border border-gray-300 px-3 py-2 rounded mb-4 w-full", children: [d.jsx("option", { value: "buyer", children: "Buyer" }), d.jsx("option", { value: "seller", children: "Seller" }), d.jsx("option", { value: "admin", children: "Admin" })] }), d.jsxs("div", { className: "flex justify-end", children: [d.jsx("button", { onClick: () => a(null), className: "bg-gray-300 text-black px-3 py-1 rounded mr-2", children: "Cancel" }), d.jsx("button", { onClick: () => h(l), className: "bg-blue-500 text-white px-3 py-1 rounded", children: "Save" })] })] }) })] }) } function xR() { return d.jsx("div", { children: "You are no added to Wishlist" }) } const SR = IE([{ path: "/", element: d.jsx(G_, {}), errorElement: d.jsx(lR, {}), children: [{ index: !0, element: d.jsx(ek, {}), loader: () => fetch("undefined/job") }, { path: "/login", element: d.jsx(F2, {}) }, { path: "/register", element: d.jsx(LN, {}) }, { path: "/job/:id", element: d.jsx(hs, { children: d.jsx(DN, {}) }), loader: ({ params: t }) => fetch(`undefined/job/${t.id}`) }, { path: "/update/:id", element: d.jsx(rR, {}), loader: ({ params: t }) => fetch(`undefined/job/${t.id}`) }, { path: "/add_job", element: d.jsx(hs, { children: d.jsx(MN, {}) }) }, { path: "/my_posted_jobs", element: d.jsx(nR, {}) }, { path: "/jobs", element: d.jsx(sR, {}) }, { path: "/booked_section", element: d.jsx(hs, { children: d.jsx(oR, {}) }) }, { path: "/booked/:id", element: d.jsx(hs, { children: d.jsx(aR, {}) }), loader: ({ params: t }) => fetch(`undefined/job/${t.id}`) }, { path: "/productPage", element: d.jsx(cR, {}), loader: () => fetch("https://wave55.vercel.app/products") }] }, { path: "/dashboard", element: d.jsx(hs, { children: d.jsx(mR, {}) }), loader: ({ params: t }) => fetch(`https://wave55.vercel.app/users/${t.email}`), children: [{ path: "/dashboard/addProduct", element: d.jsx(gR, {}) }, { path: "/dashboard/listedProduct", element: d.jsx(vR, {}), loader: ({ params: t }) => fetch(`https://wave55.vercel.app/products/${t.email}`) }, { path: "/dashboard/editProduct", element: d.jsx(yR, {}) }, { path: "/dashboard/viewalluser", element: d.jsx(wR, {}), loader: () => fetch("https://wave55.vercel.app/users") }, { path: "/dashboard/buyerwishlist", element: d.jsx(xR, {}) }] }]); Ta.createRoot(document.getElementById("root")).render(d.jsxs(L0, { children: [d.jsx(ce.StrictMode, { children: d.jsxs(H_, { children: [d.jsx(DE, { router: SR }), d.jsx(M2, {})] }) }), ","] }));
